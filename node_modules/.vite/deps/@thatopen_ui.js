import "./chunk-4337NVKS.js";

// node_modules/@thatopen/ui/dist/index.js
var js = Object.defineProperty;
var Bs = (i, t, e) => t in i ? js(i, t, { enumerable: true, configurable: true, writable: true, value: e }) : i[t] = e;
var et = (i, t, e) => (Bs(i, typeof t != "symbol" ? t + "" : t, e), e);
var It = Math.min;
var W = Math.max;
var xe = Math.round;
var st = (i) => ({
  x: i,
  y: i
});
var Hs = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var Ns = {
  start: "end",
  end: "start"
};
function Zi(i, t, e) {
  return W(i, It(t, e));
}
function oe(i, t) {
  return typeof i == "function" ? i(t) : i;
}
function Q(i) {
  return i.split("-")[0];
}
function je(i) {
  return i.split("-")[1];
}
function Mn(i) {
  return i === "x" ? "y" : "x";
}
function jn(i) {
  return i === "y" ? "height" : "width";
}
function wt(i) {
  return ["top", "bottom"].includes(Q(i)) ? "y" : "x";
}
function Bn(i) {
  return Mn(wt(i));
}
function Ds(i, t, e) {
  e === void 0 && (e = false);
  const s = je(i), n = Bn(i), r = jn(n);
  let o = n === "x" ? s === (e ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
  return t.reference[r] > t.floating[r] && (o = $e(o)), [o, $e(o)];
}
function Fs(i) {
  const t = $e(i);
  return [ii(i), t, ii(t)];
}
function ii(i) {
  return i.replace(/start|end/g, (t) => Ns[t]);
}
function Vs(i, t, e) {
  const s = ["left", "right"], n = ["right", "left"], r = ["top", "bottom"], o = ["bottom", "top"];
  switch (i) {
    case "top":
    case "bottom":
      return e ? t ? n : s : t ? s : n;
    case "left":
    case "right":
      return t ? r : o;
    default:
      return [];
  }
}
function Us(i, t, e, s) {
  const n = je(i);
  let r = Vs(Q(i), e === "start", s);
  return n && (r = r.map((o) => o + "-" + n), t && (r = r.concat(r.map(ii)))), r;
}
function $e(i) {
  return i.replace(/left|right|bottom|top/g, (t) => Hs[t]);
}
function qs(i) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...i
  };
}
function Hn(i) {
  return typeof i != "number" ? qs(i) : {
    top: i,
    right: i,
    bottom: i,
    left: i
  };
}
function zt(i) {
  const {
    x: t,
    y: e,
    width: s,
    height: n
  } = i;
  return {
    width: s,
    height: n,
    top: e,
    left: t,
    right: t + s,
    bottom: e + n,
    x: t,
    y: e
  };
}
function tn(i, t, e) {
  let {
    reference: s,
    floating: n
  } = i;
  const r = wt(t), o = Bn(t), a = jn(o), l = Q(t), c = r === "y", u = s.x + s.width / 2 - n.width / 2, h = s.y + s.height / 2 - n.height / 2, f = s[a] / 2 - n[a] / 2;
  let p;
  switch (l) {
    case "top":
      p = {
        x: u,
        y: s.y - n.height
      };
      break;
    case "bottom":
      p = {
        x: u,
        y: s.y + s.height
      };
      break;
    case "right":
      p = {
        x: s.x + s.width,
        y: h
      };
      break;
    case "left":
      p = {
        x: s.x - n.width,
        y: h
      };
      break;
    default:
      p = {
        x: s.x,
        y: s.y
      };
  }
  switch (je(t)) {
    case "start":
      p[o] -= f * (e && c ? -1 : 1);
      break;
    case "end":
      p[o] += f * (e && c ? -1 : 1);
      break;
  }
  return p;
}
var Ws = async (i, t, e) => {
  const {
    placement: s = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o
  } = e, a = r.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let c = await o.getElementRects({
    reference: i,
    floating: t,
    strategy: n
  }), {
    x: u,
    y: h
  } = tn(c, s, l), f = s, p = {}, b = 0;
  for (let v = 0; v < a.length; v++) {
    const {
      name: g,
      fn: S
    } = a[v], {
      x: E,
      y: w,
      data: $,
      reset: O
    } = await S({
      x: u,
      y: h,
      initialPlacement: s,
      placement: f,
      strategy: n,
      middlewareData: p,
      rects: c,
      platform: o,
      elements: {
        reference: i,
        floating: t
      }
    });
    u = E ?? u, h = w ?? h, p = {
      ...p,
      [g]: {
        ...p[g],
        ...$
      }
    }, O && b <= 50 && (b++, typeof O == "object" && (O.placement && (f = O.placement), O.rects && (c = O.rects === true ? await o.getElementRects({
      reference: i,
      floating: t,
      strategy: n
    }) : O.rects), {
      x: u,
      y: h
    } = tn(c, f, l)), v = -1);
  }
  return {
    x: u,
    y: h,
    placement: f,
    strategy: n,
    middlewareData: p
  };
};
async function bi(i, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: s,
    y: n,
    platform: r,
    rects: o,
    elements: a,
    strategy: l
  } = i, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: h = "floating",
    altBoundary: f = false,
    padding: p = 0
  } = oe(t, i), b = Hn(p), g = a[f ? h === "floating" ? "reference" : "floating" : h], S = zt(await r.getClippingRect({
    element: (e = await (r.isElement == null ? void 0 : r.isElement(g))) == null || e ? g : g.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), E = h === "floating" ? {
    x: s,
    y: n,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, w = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(a.floating)), $ = await (r.isElement == null ? void 0 : r.isElement(w)) ? await (r.getScale == null ? void 0 : r.getScale(w)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, O = zt(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: E,
    offsetParent: w,
    strategy: l
  }) : E);
  return {
    top: (S.top - O.top + b.top) / $.y,
    bottom: (O.bottom - S.bottom + b.bottom) / $.y,
    left: (S.left - O.left + b.left) / $.x,
    right: (O.right - S.right + b.right) / $.x
  };
}
var Qs = function(i) {
  return i === void 0 && (i = {}), {
    name: "flip",
    options: i,
    async fn(t) {
      var e, s;
      const {
        placement: n,
        middlewareData: r,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: c
      } = t, {
        mainAxis: u = true,
        crossAxis: h = true,
        fallbackPlacements: f,
        fallbackStrategy: p = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: v = true,
        ...g
      } = oe(i, t);
      if ((e = r.arrow) != null && e.alignmentOffset)
        return {};
      const S = Q(n), E = wt(a), w = Q(a) === a, $ = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), O = f || (w || !v ? [$e(a)] : Fs(a)), _ = b !== "none";
      !f && _ && O.push(...Us(a, v, b, $));
      const T = [a, ...O], j = await bi(t, g), B = [];
      let A = ((s = r.flip) == null ? void 0 : s.overflows) || [];
      if (u && B.push(j[S]), h) {
        const F = Ds(n, o, $);
        B.push(j[F[0]], j[F[1]]);
      }
      if (A = [...A, {
        placement: n,
        overflows: B
      }], !B.every((F) => F <= 0)) {
        var St, Ut;
        const F = (((St = r.flip) == null ? void 0 : St.index) || 0) + 1, Ot = T[F];
        if (Ot)
          return {
            data: {
              index: F,
              overflows: A
            },
            reset: {
              placement: Ot
            }
          };
        let K = (Ut = A.filter((Z) => Z.overflows[0] <= 0).sort((Z, V) => Z.overflows[1] - V.overflows[1])[0]) == null ? void 0 : Ut.placement;
        if (!K)
          switch (p) {
            case "bestFit": {
              var At;
              const Z = (At = A.filter((V) => {
                if (_) {
                  const tt = wt(V.placement);
                  return tt === E || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  tt === "y";
                }
                return true;
              }).map((V) => [V.placement, V.overflows.filter((tt) => tt > 0).reduce((tt, Ms) => tt + Ms, 0)]).sort((V, tt) => V[1] - tt[1])[0]) == null ? void 0 : At[0];
              Z && (K = Z);
              break;
            }
            case "initialPlacement":
              K = a;
              break;
          }
        if (n !== K)
          return {
            reset: {
              placement: K
            }
          };
      }
      return {};
    }
  };
};
function Nn(i) {
  const t = It(...i.map((r) => r.left)), e = It(...i.map((r) => r.top)), s = W(...i.map((r) => r.right)), n = W(...i.map((r) => r.bottom));
  return {
    x: t,
    y: e,
    width: s - t,
    height: n - e
  };
}
function Ys(i) {
  const t = i.slice().sort((n, r) => n.y - r.y), e = [];
  let s = null;
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    !s || r.y - s.y > s.height / 2 ? e.push([r]) : e[e.length - 1].push(r), s = r;
  }
  return e.map((n) => zt(Nn(n)));
}
var Gs = function(i) {
  return i === void 0 && (i = {}), {
    name: "inline",
    options: i,
    async fn(t) {
      const {
        placement: e,
        elements: s,
        rects: n,
        platform: r,
        strategy: o
      } = t, {
        padding: a = 2,
        x: l,
        y: c
      } = oe(i, t), u = Array.from(await (r.getClientRects == null ? void 0 : r.getClientRects(s.reference)) || []), h = Ys(u), f = zt(Nn(u)), p = Hn(a);
      function b() {
        if (h.length === 2 && h[0].left > h[1].right && l != null && c != null)
          return h.find((g) => l > g.left - p.left && l < g.right + p.right && c > g.top - p.top && c < g.bottom + p.bottom) || f;
        if (h.length >= 2) {
          if (wt(e) === "y") {
            const A = h[0], St = h[h.length - 1], Ut = Q(e) === "top", At = A.top, F = St.bottom, Ot = Ut ? A.left : St.left, K = Ut ? A.right : St.right, Z = K - Ot, V = F - At;
            return {
              top: At,
              bottom: F,
              left: Ot,
              right: K,
              width: Z,
              height: V,
              x: Ot,
              y: At
            };
          }
          const g = Q(e) === "left", S = W(...h.map((A) => A.right)), E = It(...h.map((A) => A.left)), w = h.filter((A) => g ? A.left === E : A.right === S), $ = w[0].top, O = w[w.length - 1].bottom, _ = E, T = S, j = T - _, B = O - $;
          return {
            top: $,
            bottom: O,
            left: _,
            right: T,
            width: j,
            height: B,
            x: _,
            y: $
          };
        }
        return f;
      }
      const v = await r.getElementRects({
        reference: {
          getBoundingClientRect: b
        },
        floating: s.floating,
        strategy: o
      });
      return n.reference.x !== v.reference.x || n.reference.y !== v.reference.y || n.reference.width !== v.reference.width || n.reference.height !== v.reference.height ? {
        reset: {
          rects: v
        }
      } : {};
    }
  };
};
async function Xs(i, t) {
  const {
    placement: e,
    platform: s,
    elements: n
  } = i, r = await (s.isRTL == null ? void 0 : s.isRTL(n.floating)), o = Q(e), a = je(e), l = wt(e) === "y", c = ["left", "top"].includes(o) ? -1 : 1, u = r && l ? -1 : 1, h = oe(t, i);
  let {
    mainAxis: f,
    crossAxis: p,
    alignmentAxis: b
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...h
  };
  return a && typeof b == "number" && (p = a === "end" ? b * -1 : b), l ? {
    x: p * u,
    y: f * c
  } : {
    x: f * c,
    y: p * u
  };
}
var Dn = function(i) {
  return {
    name: "offset",
    options: i,
    async fn(t) {
      var e, s;
      const {
        x: n,
        y: r,
        placement: o,
        middlewareData: a
      } = t, l = await Xs(t, i);
      return o === ((e = a.offset) == null ? void 0 : e.placement) && (s = a.arrow) != null && s.alignmentOffset ? {} : {
        x: n + l.x,
        y: r + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
};
var Js = function(i) {
  return i === void 0 && (i = {}), {
    name: "shift",
    options: i,
    async fn(t) {
      const {
        x: e,
        y: s,
        placement: n
      } = t, {
        mainAxis: r = true,
        crossAxis: o = false,
        limiter: a = {
          fn: (g) => {
            let {
              x: S,
              y: E
            } = g;
            return {
              x: S,
              y: E
            };
          }
        },
        ...l
      } = oe(i, t), c = {
        x: e,
        y: s
      }, u = await bi(t, l), h = wt(Q(n)), f = Mn(h);
      let p = c[f], b = c[h];
      if (r) {
        const g = f === "y" ? "top" : "left", S = f === "y" ? "bottom" : "right", E = p + u[g], w = p - u[S];
        p = Zi(E, p, w);
      }
      if (o) {
        const g = h === "y" ? "top" : "left", S = h === "y" ? "bottom" : "right", E = b + u[g], w = b - u[S];
        b = Zi(E, b, w);
      }
      const v = a.fn({
        ...t,
        [f]: p,
        [h]: b
      });
      return {
        ...v,
        data: {
          x: v.x - e,
          y: v.y - s
        }
      };
    }
  };
};
function rt(i) {
  return Fn(i) ? (i.nodeName || "").toLowerCase() : "#document";
}
function z(i) {
  var t;
  return (i == null || (t = i.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function pt(i) {
  var t;
  return (t = (Fn(i) ? i.ownerDocument : i.document) || window.document) == null ? void 0 : t.documentElement;
}
function Fn(i) {
  return i instanceof Node || i instanceof z(i).Node;
}
function Y(i) {
  return i instanceof Element || i instanceof z(i).Element;
}
function U(i) {
  return i instanceof HTMLElement || i instanceof z(i).HTMLElement;
}
function en(i) {
  return typeof ShadowRoot > "u" ? false : i instanceof ShadowRoot || i instanceof z(i).ShadowRoot;
}
function le(i) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: s,
    display: n
  } = R(i);
  return /auto|scroll|overlay|hidden|clip/.test(t + s + e) && !["inline", "contents"].includes(n);
}
function Ks(i) {
  return ["table", "td", "th"].includes(rt(i));
}
function Zs(i) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return i.matches(t);
    } catch {
      return false;
    }
  });
}
function gi(i) {
  const t = vi(), e = R(i);
  return e.transform !== "none" || e.perspective !== "none" || (e.containerType ? e.containerType !== "normal" : false) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : false) || !t && (e.filter ? e.filter !== "none" : false) || ["transform", "perspective", "filter"].some((s) => (e.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some((s) => (e.contain || "").includes(s));
}
function tr(i) {
  let t = Rt(i);
  for (; U(t) && !Be(t); ) {
    if (Zs(t))
      return null;
    if (gi(t))
      return t;
    t = Rt(t);
  }
  return null;
}
function vi() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
function Be(i) {
  return ["html", "body", "#document"].includes(rt(i));
}
function R(i) {
  return z(i).getComputedStyle(i);
}
function He(i) {
  return Y(i) ? {
    scrollLeft: i.scrollLeft,
    scrollTop: i.scrollTop
  } : {
    scrollLeft: i.pageXOffset,
    scrollTop: i.pageYOffset
  };
}
function Rt(i) {
  if (rt(i) === "html")
    return i;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    i.assignedSlot || // DOM Element detected.
    i.parentNode || // ShadowRoot detected.
    en(i) && i.host || // Fallback.
    pt(i)
  );
  return en(t) ? t.host : t;
}
function Vn(i) {
  const t = Rt(i);
  return Be(t) ? i.ownerDocument ? i.ownerDocument.body : i.body : U(t) && le(t) ? t : Vn(t);
}
function ni(i, t, e) {
  var s;
  t === void 0 && (t = []), e === void 0 && (e = true);
  const n = Vn(i), r = n === ((s = i.ownerDocument) == null ? void 0 : s.body), o = z(n);
  return r ? t.concat(o, o.visualViewport || [], le(n) ? n : [], o.frameElement && e ? ni(o.frameElement) : []) : t.concat(n, ni(n, [], e));
}
function Un(i) {
  const t = R(i);
  let e = parseFloat(t.width) || 0, s = parseFloat(t.height) || 0;
  const n = U(i), r = n ? i.offsetWidth : e, o = n ? i.offsetHeight : s, a = xe(e) !== r || xe(s) !== o;
  return a && (e = r, s = o), {
    width: e,
    height: s,
    $: a
  };
}
function qn(i) {
  return Y(i) ? i : i.contextElement;
}
function Pt(i) {
  const t = qn(i);
  if (!U(t))
    return st(1);
  const e = t.getBoundingClientRect(), {
    width: s,
    height: n,
    $: r
  } = Un(t);
  let o = (r ? xe(e.width) : e.width) / s, a = (r ? xe(e.height) : e.height) / n;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
var er = st(0);
function Wn(i) {
  const t = z(i);
  return !vi() || !t.visualViewport ? er : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function ir(i, t, e) {
  return t === void 0 && (t = false), !e || t && e !== z(i) ? false : t;
}
function Kt(i, t, e, s) {
  t === void 0 && (t = false), e === void 0 && (e = false);
  const n = i.getBoundingClientRect(), r = qn(i);
  let o = st(1);
  t && (s ? Y(s) && (o = Pt(s)) : o = Pt(i));
  const a = ir(r, e, s) ? Wn(r) : st(0);
  let l = (n.left + a.x) / o.x, c = (n.top + a.y) / o.y, u = n.width / o.x, h = n.height / o.y;
  if (r) {
    const f = z(r), p = s && Y(s) ? z(s) : s;
    let b = f, v = b.frameElement;
    for (; v && s && p !== b; ) {
      const g = Pt(v), S = v.getBoundingClientRect(), E = R(v), w = S.left + (v.clientLeft + parseFloat(E.paddingLeft)) * g.x, $ = S.top + (v.clientTop + parseFloat(E.paddingTop)) * g.y;
      l *= g.x, c *= g.y, u *= g.x, h *= g.y, l += w, c += $, b = z(v), v = b.frameElement;
    }
  }
  return zt({
    width: u,
    height: h,
    x: l,
    y: c
  });
}
var nr = [":popover-open", ":modal"];
function Qn(i) {
  return nr.some((t) => {
    try {
      return i.matches(t);
    } catch {
      return false;
    }
  });
}
function sr(i) {
  let {
    elements: t,
    rect: e,
    offsetParent: s,
    strategy: n
  } = i;
  const r = n === "fixed", o = pt(s), a = t ? Qn(t.floating) : false;
  if (s === o || a && r)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = st(1);
  const u = st(0), h = U(s);
  if ((h || !h && !r) && ((rt(s) !== "body" || le(o)) && (l = He(s)), U(s))) {
    const f = Kt(s);
    c = Pt(s), u.x = f.x + s.clientLeft, u.y = f.y + s.clientTop;
  }
  return {
    width: e.width * c.x,
    height: e.height * c.y,
    x: e.x * c.x - l.scrollLeft * c.x + u.x,
    y: e.y * c.y - l.scrollTop * c.y + u.y
  };
}
function rr(i) {
  return Array.from(i.getClientRects());
}
function Yn(i) {
  return Kt(pt(i)).left + He(i).scrollLeft;
}
function or(i) {
  const t = pt(i), e = He(i), s = i.ownerDocument.body, n = W(t.scrollWidth, t.clientWidth, s.scrollWidth, s.clientWidth), r = W(t.scrollHeight, t.clientHeight, s.scrollHeight, s.clientHeight);
  let o = -e.scrollLeft + Yn(i);
  const a = -e.scrollTop;
  return R(s).direction === "rtl" && (o += W(t.clientWidth, s.clientWidth) - n), {
    width: n,
    height: r,
    x: o,
    y: a
  };
}
function lr(i, t) {
  const e = z(i), s = pt(i), n = e.visualViewport;
  let r = s.clientWidth, o = s.clientHeight, a = 0, l = 0;
  if (n) {
    r = n.width, o = n.height;
    const c = vi();
    (!c || c && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: r,
    height: o,
    x: a,
    y: l
  };
}
function ar(i, t) {
  const e = Kt(i, true, t === "fixed"), s = e.top + i.clientTop, n = e.left + i.clientLeft, r = U(i) ? Pt(i) : st(1), o = i.clientWidth * r.x, a = i.clientHeight * r.y, l = n * r.x, c = s * r.y;
  return {
    width: o,
    height: a,
    x: l,
    y: c
  };
}
function nn(i, t, e) {
  let s;
  if (t === "viewport")
    s = lr(i, e);
  else if (t === "document")
    s = or(pt(i));
  else if (Y(t))
    s = ar(t, e);
  else {
    const n = Wn(i);
    s = {
      ...t,
      x: t.x - n.x,
      y: t.y - n.y
    };
  }
  return zt(s);
}
function Gn(i, t) {
  const e = Rt(i);
  return e === t || !Y(e) || Be(e) ? false : R(e).position === "fixed" || Gn(e, t);
}
function cr(i, t) {
  const e = t.get(i);
  if (e)
    return e;
  let s = ni(i, [], false).filter((a) => Y(a) && rt(a) !== "body"), n = null;
  const r = R(i).position === "fixed";
  let o = r ? Rt(i) : i;
  for (; Y(o) && !Be(o); ) {
    const a = R(o), l = gi(o);
    !l && a.position === "fixed" && (n = null), (r ? !l && !n : !l && a.position === "static" && !!n && ["absolute", "fixed"].includes(n.position) || le(o) && !l && Gn(i, o)) ? s = s.filter((u) => u !== o) : n = a, o = Rt(o);
  }
  return t.set(i, s), s;
}
function ur(i) {
  let {
    element: t,
    boundary: e,
    rootBoundary: s,
    strategy: n
  } = i;
  const o = [...e === "clippingAncestors" ? cr(t, this._c) : [].concat(e), s], a = o[0], l = o.reduce((c, u) => {
    const h = nn(t, u, n);
    return c.top = W(h.top, c.top), c.right = It(h.right, c.right), c.bottom = It(h.bottom, c.bottom), c.left = W(h.left, c.left), c;
  }, nn(t, a, n));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function hr(i) {
  const {
    width: t,
    height: e
  } = Un(i);
  return {
    width: t,
    height: e
  };
}
function dr(i, t, e) {
  const s = U(t), n = pt(t), r = e === "fixed", o = Kt(i, true, r, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = st(0);
  if (s || !s && !r)
    if ((rt(t) !== "body" || le(n)) && (a = He(t)), s) {
      const h = Kt(t, true, r, t);
      l.x = h.x + t.clientLeft, l.y = h.y + t.clientTop;
    } else
      n && (l.x = Yn(n));
  const c = o.left + a.scrollLeft - l.x, u = o.top + a.scrollTop - l.y;
  return {
    x: c,
    y: u,
    width: o.width,
    height: o.height
  };
}
function sn(i, t) {
  return !U(i) || R(i).position === "fixed" ? null : t ? t(i) : i.offsetParent;
}
function Xn(i, t) {
  const e = z(i);
  if (!U(i) || Qn(i))
    return e;
  let s = sn(i, t);
  for (; s && Ks(s) && R(s).position === "static"; )
    s = sn(s, t);
  return s && (rt(s) === "html" || rt(s) === "body" && R(s).position === "static" && !gi(s)) ? e : s || tr(i) || e;
}
var fr = async function(i) {
  const t = this.getOffsetParent || Xn, e = this.getDimensions;
  return {
    reference: dr(i.reference, await t(i.floating), i.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await e(i.floating)
    }
  };
};
function pr(i) {
  return R(i).direction === "rtl";
}
var mr = {
  convertOffsetParentRelativeRectToViewportRelativeRect: sr,
  getDocumentElement: pt,
  getClippingRect: ur,
  getOffsetParent: Xn,
  getElementRects: fr,
  getClientRects: rr,
  getDimensions: hr,
  getScale: Pt,
  isElement: Y,
  isRTL: pr
};
var Jn = Js;
var Kn = Qs;
var Zn = Gs;
var ts = (i, t, e) => {
  const s = /* @__PURE__ */ new Map(), n = {
    platform: mr,
    ...e
  }, r = {
    ...n.platform,
    _c: s
  };
  return Ws(i, t, {
    ...n,
    platform: r
  });
};
var ye = globalThis;
var yi = ye.ShadowRoot && (ye.ShadyCSS === void 0 || ye.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var _i = Symbol();
var rn = /* @__PURE__ */ new WeakMap();
var es = class {
  constructor(t, e, s) {
    if (this._$cssResult$ = true, s !== _i)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (yi && t === void 0) {
      const s = e !== void 0 && e.length === 1;
      s && (t = rn.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), s && rn.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
var br = (i) => new es(typeof i == "string" ? i : i + "", void 0, _i);
var C = (i, ...t) => {
  const e = i.length === 1 ? i[0] : t.reduce((s, n, r) => s + ((o) => {
    if (o._$cssResult$ === true)
      return o.cssText;
    if (typeof o == "number")
      return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(n) + i[r + 1], i[0]);
  return new es(e, i, _i);
};
var gr = (i, t) => {
  if (yi)
    i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else
    for (const e of t) {
      const s = document.createElement("style"), n = ye.litNonce;
      n !== void 0 && s.setAttribute("nonce", n), s.textContent = e.cssText, i.appendChild(s);
    }
};
var on = yi ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const s of t.cssRules)
    e += s.cssText;
  return br(e);
})(i) : i;
var { is: vr, defineProperty: yr, getOwnPropertyDescriptor: _r, getOwnPropertyNames: wr, getOwnPropertySymbols: xr, getPrototypeOf: $r } = Object;
var nt = globalThis;
var ln = nt.trustedTypes;
var Cr = ln ? ln.emptyScript : "";
var Qe = nt.reactiveElementPolyfillSupport;
var Qt = (i, t) => i;
var Ce = { toAttribute(i, t) {
  switch (t) {
    case Boolean:
      i = i ? Cr : null;
      break;
    case Object:
    case Array:
      i = i == null ? i : JSON.stringify(i);
  }
  return i;
}, fromAttribute(i, t) {
  let e = i;
  switch (t) {
    case Boolean:
      e = i !== null;
      break;
    case Number:
      e = i === null ? null : Number(i);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(i);
      } catch {
        e = null;
      }
  }
  return e;
} };
var wi = (i, t) => !vr(i, t);
var an = { attribute: true, type: String, converter: Ce, reflect: false, hasChanged: wi };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), nt.litPropertyMetadata ?? (nt.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
var kt = class extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = an) {
    if (e.state && (e.attribute = false), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {
      const s = Symbol(), n = this.getPropertyDescriptor(t, s, e);
      n !== void 0 && yr(this.prototype, t, n);
    }
  }
  static getPropertyDescriptor(t, e, s) {
    const { get: n, set: r } = _r(this.prototype, t) ?? { get() {
      return this[e];
    }, set(o) {
      this[e] = o;
    } };
    return { get() {
      return n == null ? void 0 : n.call(this);
    }, set(o) {
      const a = n == null ? void 0 : n.call(this);
      r.call(this, o), this.requestUpdate(t, a, s);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? an;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Qt("elementProperties")))
      return;
    const t = $r(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(Qt("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(Qt("properties"))) {
      const e = this.properties, s = [...wr(e), ...xr(e)];
      for (const n of s)
        this.createProperty(n, e[n]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0)
        for (const [s, n] of e)
          this.elementProperties.set(s, n);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, s] of this.elementProperties) {
      const n = this._$Eu(e, s);
      n !== void 0 && this._$Eh.set(n, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const s = new Set(t.flat(1 / 0).reverse());
      for (const n of s)
        e.unshift(on(n));
    } else
      t !== void 0 && e.push(on(t));
    return e;
  }
  static _$Eu(t, e) {
    const s = e.attribute;
    return s === false ? void 0 : typeof s == "string" ? s : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
  }
  addController(t) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$EO) == null || e.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const s of e.keys())
      this.hasOwnProperty(s) && (t.set(s, this[s]), delete this[s]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return gr(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t = this._$EO) == null || t.forEach((e) => {
      var s;
      return (s = e.hostConnected) == null ? void 0 : s.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var s;
      return (s = e.hostDisconnected) == null ? void 0 : s.call(e);
    });
  }
  attributeChangedCallback(t, e, s) {
    this._$AK(t, s);
  }
  _$EC(t, e) {
    var r;
    const s = this.constructor.elementProperties.get(t), n = this.constructor._$Eu(t, s);
    if (n !== void 0 && s.reflect === true) {
      const o = (((r = s.converter) == null ? void 0 : r.toAttribute) !== void 0 ? s.converter : Ce).toAttribute(e, s.type);
      this._$Em = t, o == null ? this.removeAttribute(n) : this.setAttribute(n, o), this._$Em = null;
    }
  }
  _$AK(t, e) {
    var r;
    const s = this.constructor, n = s._$Eh.get(t);
    if (n !== void 0 && this._$Em !== n) {
      const o = s.getPropertyOptions(n), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((r = o.converter) == null ? void 0 : r.fromAttribute) !== void 0 ? o.converter : Ce;
      this._$Em = n, this[n] = a.fromAttribute(e, o.type), this._$Em = null;
    }
  }
  requestUpdate(t, e, s) {
    if (t !== void 0) {
      if (s ?? (s = this.constructor.getPropertyOptions(t)), !(s.hasChanged ?? wi)(this[t], e))
        return;
      this.P(t, e, s);
    }
    this.isUpdatePending === false && (this._$ES = this._$ET());
  }
  P(t, e, s) {
    this._$AL.has(t) || this._$AL.set(t, e), s.reflect === true && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var s;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [r, o] of this._$Ep)
          this[r] = o;
        this._$Ep = void 0;
      }
      const n = this.constructor.elementProperties;
      if (n.size > 0)
        for (const [r, o] of n)
          o.wrapped !== true || this._$AL.has(r) || this[r] === void 0 || this.P(r, this[r], o);
    }
    let t = false;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), (s = this._$EO) == null || s.forEach((n) => {
        var r;
        return (r = n.hostUpdate) == null ? void 0 : r.call(n);
      }), this.update(e)) : this._$EU();
    } catch (n) {
      throw t = false, this._$EU(), n;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$EO) == null || e.forEach((s) => {
      var n;
      return (n = s.hostUpdated) == null ? void 0 : n.call(s);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t)), this.updated(t);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return true;
  }
  update(t) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
kt.elementStyles = [], kt.shadowRootOptions = { mode: "open" }, kt[Qt("elementProperties")] = /* @__PURE__ */ new Map(), kt[Qt("finalized")] = /* @__PURE__ */ new Map(), Qe == null || Qe({ ReactiveElement: kt }), (nt.reactiveElementVersions ?? (nt.reactiveElementVersions = [])).push("2.0.4");
var Yt = globalThis;
var Ee = Yt.trustedTypes;
var cn = Ee ? Ee.createPolicy("lit-html", { createHTML: (i) => i }) : void 0;
var is = "$lit$";
var it = `lit$${Math.random().toFixed(9).slice(2)}$`;
var ns = "?" + it;
var Er = `<${ns}>`;
var xt = document;
var Zt = () => xt.createComment("");
var te = (i) => i === null || typeof i != "object" && typeof i != "function";
var ss = Array.isArray;
var Sr = (i) => ss(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == "function";
var Ye = `[ 	
\f\r]`;
var qt = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var un = /-->/g;
var hn = />/g;
var vt = RegExp(`>|${Ye}(?:([^\\s"'>=/]+)(${Ye}*=${Ye}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var dn = /'/g;
var fn = /"/g;
var rs = /^(?:script|style|textarea|title)$/i;
var Ar = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e });
var m = Ar(1);
var $t = Symbol.for("lit-noChange");
var k = Symbol.for("lit-nothing");
var pn = /* @__PURE__ */ new WeakMap();
var yt = xt.createTreeWalker(xt, 129);
function os(i, t) {
  if (!Array.isArray(i) || !i.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return cn !== void 0 ? cn.createHTML(t) : t;
}
var Or = (i, t) => {
  const e = i.length - 1, s = [];
  let n, r = t === 2 ? "<svg>" : "", o = qt;
  for (let a = 0; a < e; a++) {
    const l = i[a];
    let c, u, h = -1, f = 0;
    for (; f < l.length && (o.lastIndex = f, u = o.exec(l), u !== null); )
      f = o.lastIndex, o === qt ? u[1] === "!--" ? o = un : u[1] !== void 0 ? o = hn : u[2] !== void 0 ? (rs.test(u[2]) && (n = RegExp("</" + u[2], "g")), o = vt) : u[3] !== void 0 && (o = vt) : o === vt ? u[0] === ">" ? (o = n ?? qt, h = -1) : u[1] === void 0 ? h = -2 : (h = o.lastIndex - u[2].length, c = u[1], o = u[3] === void 0 ? vt : u[3] === '"' ? fn : dn) : o === fn || o === dn ? o = vt : o === un || o === hn ? o = qt : (o = vt, n = void 0);
    const p = o === vt && i[a + 1].startsWith("/>") ? " " : "";
    r += o === qt ? l + Er : h >= 0 ? (s.push(c), l.slice(0, h) + is + l.slice(h) + it + p) : l + it + (h === -2 ? a : p);
  }
  return [os(i, r + (i[e] || "<?>") + (t === 2 ? "</svg>" : "")), s];
};
var ee = class _ee {
  constructor({ strings: t, _$litType$: e }, s) {
    let n;
    this.parts = [];
    let r = 0, o = 0;
    const a = t.length - 1, l = this.parts, [c, u] = Or(t, e);
    if (this.el = _ee.createElement(c, s), yt.currentNode = this.el.content, e === 2) {
      const h = this.el.content.firstChild;
      h.replaceWith(...h.childNodes);
    }
    for (; (n = yt.nextNode()) !== null && l.length < a; ) {
      if (n.nodeType === 1) {
        if (n.hasAttributes())
          for (const h of n.getAttributeNames())
            if (h.endsWith(is)) {
              const f = u[o++], p = n.getAttribute(h).split(it), b = /([.?@])?(.*)/.exec(f);
              l.push({ type: 1, index: r, name: b[2], strings: p, ctor: b[1] === "." ? Pr : b[1] === "?" ? Tr : b[1] === "@" ? Lr : Ne }), n.removeAttribute(h);
            } else
              h.startsWith(it) && (l.push({ type: 6, index: r }), n.removeAttribute(h));
        if (rs.test(n.tagName)) {
          const h = n.textContent.split(it), f = h.length - 1;
          if (f > 0) {
            n.textContent = Ee ? Ee.emptyScript : "";
            for (let p = 0; p < f; p++)
              n.append(h[p], Zt()), yt.nextNode(), l.push({ type: 2, index: ++r });
            n.append(h[f], Zt());
          }
        }
      } else if (n.nodeType === 8)
        if (n.data === ns)
          l.push({ type: 2, index: r });
        else {
          let h = -1;
          for (; (h = n.data.indexOf(it, h + 1)) !== -1; )
            l.push({ type: 7, index: r }), h += it.length - 1;
        }
      r++;
    }
  }
  static createElement(t, e) {
    const s = xt.createElement("template");
    return s.innerHTML = t, s;
  }
};
function Mt(i, t, e = i, s) {
  var o, a;
  if (t === $t)
    return t;
  let n = s !== void 0 ? (o = e._$Co) == null ? void 0 : o[s] : e._$Cl;
  const r = te(t) ? void 0 : t._$litDirective$;
  return (n == null ? void 0 : n.constructor) !== r && ((a = n == null ? void 0 : n._$AO) == null || a.call(n, false), r === void 0 ? n = void 0 : (n = new r(i), n._$AT(i, e, s)), s !== void 0 ? (e._$Co ?? (e._$Co = []))[s] = n : e._$Cl = n), n !== void 0 && (t = Mt(i, n._$AS(i, t.values), n, s)), t;
}
var kr = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: s } = this._$AD, n = ((t == null ? void 0 : t.creationScope) ?? xt).importNode(e, true);
    yt.currentNode = n;
    let r = yt.nextNode(), o = 0, a = 0, l = s[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let c;
        l.type === 2 ? c = new ae(r, r.nextSibling, this, t) : l.type === 1 ? c = new l.ctor(r, l.name, l.strings, this, t) : l.type === 6 && (c = new Ir(r, this, t)), this._$AV.push(c), l = s[++a];
      }
      o !== (l == null ? void 0 : l.index) && (r = yt.nextNode(), o++);
    }
    return yt.currentNode = xt, n;
  }
  p(t) {
    let e = 0;
    for (const s of this._$AV)
      s !== void 0 && (s.strings !== void 0 ? (s._$AI(t, s, e), e += s.strings.length - 2) : s._$AI(t[e])), e++;
  }
};
var ae = class _ae {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
  }
  constructor(t, e, s, n) {
    this.type = 2, this._$AH = k, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = s, this.options = n, this._$Cv = (n == null ? void 0 : n.isConnected) ?? true;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = Mt(this, t, e), te(t) ? t === k || t == null || t === "" ? (this._$AH !== k && this._$AR(), this._$AH = k) : t !== this._$AH && t !== $t && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : Sr(t) ? this.k(t) : this._(t);
  }
  S(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.S(t));
  }
  _(t) {
    this._$AH !== k && te(this._$AH) ? this._$AA.nextSibling.data = t : this.T(xt.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var r;
    const { values: e, _$litType$: s } = t, n = typeof s == "number" ? this._$AC(t) : (s.el === void 0 && (s.el = ee.createElement(os(s.h, s.h[0]), this.options)), s);
    if (((r = this._$AH) == null ? void 0 : r._$AD) === n)
      this._$AH.p(e);
    else {
      const o = new kr(n, this), a = o.u(this.options);
      o.p(e), this.T(a), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = pn.get(t.strings);
    return e === void 0 && pn.set(t.strings, e = new ee(t)), e;
  }
  k(t) {
    ss(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let s, n = 0;
    for (const r of t)
      n === e.length ? e.push(s = new _ae(this.S(Zt()), this.S(Zt()), this, this.options)) : s = e[n], s._$AI(r), n++;
    n < e.length && (this._$AR(s && s._$AB.nextSibling, n), e.length = n);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var s;
    for ((s = this._$AP) == null ? void 0 : s.call(this, false, true, e); t && t !== this._$AB; ) {
      const n = t.nextSibling;
      t.remove(), t = n;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));
  }
};
var Ne = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, s, n, r) {
    this.type = 1, this._$AH = k, this._$AN = void 0, this.element = t, this.name = e, this._$AM = n, this.options = r, s.length > 2 || s[0] !== "" || s[1] !== "" ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = k;
  }
  _$AI(t, e = this, s, n) {
    const r = this.strings;
    let o = false;
    if (r === void 0)
      t = Mt(this, t, e, 0), o = !te(t) || t !== this._$AH && t !== $t, o && (this._$AH = t);
    else {
      const a = t;
      let l, c;
      for (t = r[0], l = 0; l < r.length - 1; l++)
        c = Mt(this, a[s + l], e, l), c === $t && (c = this._$AH[l]), o || (o = !te(c) || c !== this._$AH[l]), c === k ? t = k : t !== k && (t += (c ?? "") + r[l + 1]), this._$AH[l] = c;
    }
    o && !n && this.j(t);
  }
  j(t) {
    t === k ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
};
var Pr = class extends Ne {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === k ? void 0 : t;
  }
};
var Tr = class extends Ne {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== k);
  }
};
var Lr = class extends Ne {
  constructor(t, e, s, n, r) {
    super(t, e, s, n, r), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = Mt(this, t, e, 0) ?? k) === $t)
      return;
    const s = this._$AH, n = t === k && s !== k || t.capture !== s.capture || t.once !== s.once || t.passive !== s.passive, r = t !== k && (s === k || n);
    n && this.element.removeEventListener(this.name, this, s), r && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
};
var Ir = class {
  constructor(t, e, s) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = s;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Mt(this, t);
  }
};
var Ge = Yt.litHtmlPolyfillSupport;
Ge == null || Ge(ee, ae), (Yt.litHtmlVersions ?? (Yt.litHtmlVersions = [])).push("3.1.4");
var jt = (i, t, e) => {
  const s = (e == null ? void 0 : e.renderBefore) ?? t;
  let n = s._$litPart$;
  if (n === void 0) {
    const r = (e == null ? void 0 : e.renderBefore) ?? null;
    s._$litPart$ = n = new ae(t.insertBefore(Zt(), r), r, void 0, e ?? {});
  }
  return n._$AI(i), n;
};
var x = class extends kt {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var e;
    const t = super.createRenderRoot();
    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = jt(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(true);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(false);
  }
  render() {
    return $t;
  }
};
var Rn;
x._$litElement$ = true, x.finalized = true, (Rn = globalThis.litElementHydrateSupport) == null || Rn.call(globalThis, { LitElement: x });
var Xe = globalThis.litElementPolyfillSupport;
Xe == null || Xe({ LitElement: x });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.6");
var zr = { attribute: true, type: String, converter: Ce, reflect: false, hasChanged: wi };
var Rr = (i = zr, t, e) => {
  const { kind: s, metadata: n } = e;
  let r = globalThis.litPropertyMetadata.get(n);
  if (r === void 0 && globalThis.litPropertyMetadata.set(n, r = /* @__PURE__ */ new Map()), r.set(e.name, i), s === "accessor") {
    const { name: o } = e;
    return { set(a) {
      const l = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(o, l, i);
    }, init(a) {
      return a !== void 0 && this.P(o, void 0, i), a;
    } };
  }
  if (s === "setter") {
    const { name: o } = e;
    return function(a) {
      const l = this[o];
      t.call(this, a), this.requestUpdate(o, l, i);
    };
  }
  throw Error("Unsupported decorator location: " + s);
};
function d(i) {
  return (t, e) => typeof e == "object" ? Rr(i, t, e) : ((s, n, r) => {
    const o = n.hasOwnProperty(r);
    return n.constructor.createProperty(r, o ? { ...s, wrapped: true } : s), o ? Object.getOwnPropertyDescriptor(n, r) : void 0;
  })(i, t, e);
}
function ce(i) {
  return d({ ...i, state: true, attribute: false });
}
var Mr = (i) => i.strings === void 0;
var ls = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var as = (i) => (...t) => ({ _$litDirective$: i, values: t });
var cs = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, s) {
    this._$Ct = t, this._$AM = e, this._$Ci = s;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
};
var Gt = (i, t) => {
  var s;
  const e = i._$AN;
  if (e === void 0)
    return false;
  for (const n of e)
    (s = n._$AO) == null || s.call(n, t, false), Gt(n, t);
  return true;
};
var Se = (i) => {
  let t, e;
  do {
    if ((t = i._$AM) === void 0)
      break;
    e = t._$AN, e.delete(i), i = t;
  } while ((e == null ? void 0 : e.size) === 0);
};
var us = (i) => {
  for (let t; t = i._$AM; i = t) {
    let e = t._$AN;
    if (e === void 0)
      t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(i))
      break;
    e.add(i), Hr(t);
  }
};
function jr(i) {
  this._$AN !== void 0 ? (Se(this), this._$AM = i, us(this)) : this._$AM = i;
}
function Br(i, t = false, e = 0) {
  const s = this._$AH, n = this._$AN;
  if (n !== void 0 && n.size !== 0)
    if (t)
      if (Array.isArray(s))
        for (let r = e; r < s.length; r++)
          Gt(s[r], false), Se(s[r]);
      else
        s != null && (Gt(s, false), Se(s));
    else
      Gt(this, i);
}
var Hr = (i) => {
  i.type == ls.CHILD && (i._$AP ?? (i._$AP = Br), i._$AQ ?? (i._$AQ = jr));
};
var Nr = class extends cs {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, s) {
    super._$AT(t, e, s), us(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = true) {
    var s, n;
    t !== this.isConnected && (this.isConnected = t, t ? (s = this.reconnected) == null || s.call(this) : (n = this.disconnected) == null || n.call(this)), e && (Gt(this, t), Se(this));
  }
  setValue(t) {
    if (Mr(this._$Ct))
      this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
var Tt = () => new Dr();
var Dr = class {
};
var Je = /* @__PURE__ */ new WeakMap();
var Lt = as(class extends Nr {
  render(i) {
    return k;
  }
  update(i, [t]) {
    var s;
    const e = t !== this.Y;
    return e && this.Y !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.Y = t, this.ht = (s = i.options) == null ? void 0 : s.host, this.rt(this.ct = i.element)), k;
  }
  rt(i) {
    if (this.isConnected || (i = void 0), typeof this.Y == "function") {
      const t = this.ht ?? globalThis;
      let e = Je.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), Je.set(t, e)), e.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), e.set(this.Y, i), i !== void 0 && this.Y.call(this.ht, i);
    } else
      this.Y.value = i;
  }
  get lt() {
    var i, t;
    return typeof this.Y == "function" ? (i = Je.get(this.ht ?? globalThis)) == null ? void 0 : i.get(this.Y) : (t = this.Y) == null ? void 0 : t.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
var hs = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
var Ae = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
var ue = Object.freeze({
  ...hs,
  ...Ae
});
var si = Object.freeze({
  ...ue,
  body: "",
  hidden: false
});
var Fr = Object.freeze({
  width: null,
  height: null
});
var ds = Object.freeze({
  // Dimensions
  ...Fr,
  // Transformations
  ...Ae
});
function Vr(i, t = 0) {
  const e = i.replace(/^-?[0-9.]*/, "");
  function s(n) {
    for (; n < 0; )
      n += 4;
    return n % 4;
  }
  if (e === "") {
    const n = parseInt(i);
    return isNaN(n) ? 0 : s(n);
  } else if (e !== i) {
    let n = 0;
    switch (e) {
      case "%":
        n = 25;
        break;
      case "deg":
        n = 90;
    }
    if (n) {
      let r = parseFloat(i.slice(0, i.length - e.length));
      return isNaN(r) ? 0 : (r = r / n, r % 1 === 0 ? s(r) : 0);
    }
  }
  return t;
}
var Ur = /[\s,]+/;
function qr(i, t) {
  t.split(Ur).forEach((e) => {
    switch (e.trim()) {
      case "horizontal":
        i.hFlip = true;
        break;
      case "vertical":
        i.vFlip = true;
        break;
    }
  });
}
var fs = {
  ...ds,
  preserveAspectRatio: ""
};
function mn(i) {
  const t = {
    ...fs
  }, e = (s, n) => i.getAttribute(s) || n;
  return t.width = e("width", null), t.height = e("height", null), t.rotate = Vr(e("rotate", "")), qr(t, e("flip", "")), t.preserveAspectRatio = e("preserveAspectRatio", e("preserveaspectratio", "")), t;
}
function Wr(i, t) {
  for (const e in fs)
    if (i[e] !== t[e])
      return true;
  return false;
}
var Xt = /^[a-z0-9]+(-[a-z0-9]+)*$/;
var he = (i, t, e, s = "") => {
  const n = i.split(":");
  if (i.slice(0, 1) === "@") {
    if (n.length < 2 || n.length > 3)
      return null;
    s = n.shift().slice(1);
  }
  if (n.length > 3 || !n.length)
    return null;
  if (n.length > 1) {
    const a = n.pop(), l = n.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: n.length > 0 ? n[0] : s,
      prefix: l,
      name: a
    };
    return t && !_e(c) ? null : c;
  }
  const r = n[0], o = r.split("-");
  if (o.length > 1) {
    const a = {
      provider: s,
      prefix: o.shift(),
      name: o.join("-")
    };
    return t && !_e(a) ? null : a;
  }
  if (e && s === "") {
    const a = {
      provider: s,
      prefix: "",
      name: r
    };
    return t && !_e(a, e) ? null : a;
  }
  return null;
};
var _e = (i, t) => i ? !!((i.provider === "" || i.provider.match(Xt)) && (t && i.prefix === "" || i.prefix.match(Xt)) && i.name.match(Xt)) : false;
function Qr(i, t) {
  const e = {};
  !i.hFlip != !t.hFlip && (e.hFlip = true), !i.vFlip != !t.vFlip && (e.vFlip = true);
  const s = ((i.rotate || 0) + (t.rotate || 0)) % 4;
  return s && (e.rotate = s), e;
}
function bn(i, t) {
  const e = Qr(i, t);
  for (const s in si)
    s in Ae ? s in i && !(s in e) && (e[s] = Ae[s]) : s in t ? e[s] = t[s] : s in i && (e[s] = i[s]);
  return e;
}
function Yr(i, t) {
  const e = i.icons, s = i.aliases || /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  function r(o) {
    if (e[o])
      return n[o] = [];
    if (!(o in n)) {
      n[o] = null;
      const a = s[o] && s[o].parent, l = a && r(a);
      l && (n[o] = [a].concat(l));
    }
    return n[o];
  }
  return Object.keys(e).concat(Object.keys(s)).forEach(r), n;
}
function Gr(i, t, e) {
  const s = i.icons, n = i.aliases || /* @__PURE__ */ Object.create(null);
  let r = {};
  function o(a) {
    r = bn(
      s[a] || n[a],
      r
    );
  }
  return o(t), e.forEach(o), bn(i, r);
}
function ps(i, t) {
  const e = [];
  if (typeof i != "object" || typeof i.icons != "object")
    return e;
  i.not_found instanceof Array && i.not_found.forEach((n) => {
    t(n, null), e.push(n);
  });
  const s = Yr(i);
  for (const n in s) {
    const r = s[n];
    r && (t(n, Gr(i, n, r)), e.push(n));
  }
  return e;
}
var Xr = {
  provider: "",
  aliases: {},
  not_found: {},
  ...hs
};
function Ke(i, t) {
  for (const e in t)
    if (e in i && typeof i[e] != typeof t[e])
      return false;
  return true;
}
function ms(i) {
  if (typeof i != "object" || i === null)
    return null;
  const t = i;
  if (typeof t.prefix != "string" || !i.icons || typeof i.icons != "object" || !Ke(i, Xr))
    return null;
  const e = t.icons;
  for (const n in e) {
    const r = e[n];
    if (!n.match(Xt) || typeof r.body != "string" || !Ke(
      r,
      si
    ))
      return null;
  }
  const s = t.aliases || /* @__PURE__ */ Object.create(null);
  for (const n in s) {
    const r = s[n], o = r.parent;
    if (!n.match(Xt) || typeof o != "string" || !e[o] && !s[o] || !Ke(
      r,
      si
    ))
      return null;
  }
  return t;
}
var Oe = /* @__PURE__ */ Object.create(null);
function Jr(i, t) {
  return {
    provider: i,
    prefix: t,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function ot(i, t) {
  const e = Oe[i] || (Oe[i] = /* @__PURE__ */ Object.create(null));
  return e[t] || (e[t] = Jr(i, t));
}
function xi(i, t) {
  return ms(t) ? ps(t, (e, s) => {
    s ? i.icons[e] = s : i.missing.add(e);
  }) : [];
}
function Kr(i, t, e) {
  try {
    if (typeof e.body == "string")
      return i.icons[t] = { ...e }, true;
  } catch {
  }
  return false;
}
function Zr(i, t) {
  let e = [];
  return (typeof i == "string" ? [i] : Object.keys(Oe)).forEach((n) => {
    (typeof n == "string" && typeof t == "string" ? [t] : Object.keys(Oe[n] || {})).forEach((o) => {
      const a = ot(n, o);
      e = e.concat(
        Object.keys(a.icons).map(
          (l) => (n !== "" ? "@" + n + ":" : "") + o + ":" + l
        )
      );
    });
  }), e;
}
var ie = false;
function bs(i) {
  return typeof i == "boolean" && (ie = i), ie;
}
function ne(i) {
  const t = typeof i == "string" ? he(i, true, ie) : i;
  if (t) {
    const e = ot(t.provider, t.prefix), s = t.name;
    return e.icons[s] || (e.missing.has(s) ? null : void 0);
  }
}
function gs(i, t) {
  const e = he(i, true, ie);
  if (!e)
    return false;
  const s = ot(e.provider, e.prefix);
  return Kr(s, e.name, t);
}
function gn(i, t) {
  if (typeof i != "object")
    return false;
  if (typeof t != "string" && (t = i.provider || ""), ie && !t && !i.prefix) {
    let n = false;
    return ms(i) && (i.prefix = "", ps(i, (r, o) => {
      o && gs(r, o) && (n = true);
    })), n;
  }
  const e = i.prefix;
  if (!_e({
    provider: t,
    prefix: e,
    name: "a"
  }))
    return false;
  const s = ot(t, e);
  return !!xi(s, i);
}
function vn(i) {
  return !!ne(i);
}
function to(i) {
  const t = ne(i);
  return t ? {
    ...ue,
    ...t
  } : null;
}
function eo(i) {
  const t = {
    loaded: [],
    missing: [],
    pending: []
  }, e = /* @__PURE__ */ Object.create(null);
  i.sort((n, r) => n.provider !== r.provider ? n.provider.localeCompare(r.provider) : n.prefix !== r.prefix ? n.prefix.localeCompare(r.prefix) : n.name.localeCompare(r.name));
  let s = {
    provider: "",
    prefix: "",
    name: ""
  };
  return i.forEach((n) => {
    if (s.name === n.name && s.prefix === n.prefix && s.provider === n.provider)
      return;
    s = n;
    const r = n.provider, o = n.prefix, a = n.name, l = e[r] || (e[r] = /* @__PURE__ */ Object.create(null)), c = l[o] || (l[o] = ot(r, o));
    let u;
    a in c.icons ? u = t.loaded : o === "" || c.missing.has(a) ? u = t.missing : u = t.pending;
    const h = {
      provider: r,
      prefix: o,
      name: a
    };
    u.push(h);
  }), t;
}
function vs(i, t) {
  i.forEach((e) => {
    const s = e.loaderCallbacks;
    s && (e.loaderCallbacks = s.filter((n) => n.id !== t));
  });
}
function io(i) {
  i.pendingCallbacksFlag || (i.pendingCallbacksFlag = true, setTimeout(() => {
    i.pendingCallbacksFlag = false;
    const t = i.loaderCallbacks ? i.loaderCallbacks.slice(0) : [];
    if (!t.length)
      return;
    let e = false;
    const s = i.provider, n = i.prefix;
    t.forEach((r) => {
      const o = r.icons, a = o.pending.length;
      o.pending = o.pending.filter((l) => {
        if (l.prefix !== n)
          return true;
        const c = l.name;
        if (i.icons[c])
          o.loaded.push({
            provider: s,
            prefix: n,
            name: c
          });
        else if (i.missing.has(c))
          o.missing.push({
            provider: s,
            prefix: n,
            name: c
          });
        else
          return e = true, true;
        return false;
      }), o.pending.length !== a && (e || vs([i], r.id), r.callback(
        o.loaded.slice(0),
        o.missing.slice(0),
        o.pending.slice(0),
        r.abort
      ));
    });
  }));
}
var no = 0;
function so(i, t, e) {
  const s = no++, n = vs.bind(null, e, s);
  if (!t.pending.length)
    return n;
  const r = {
    id: s,
    icons: t,
    callback: i,
    abort: n
  };
  return e.forEach((o) => {
    (o.loaderCallbacks || (o.loaderCallbacks = [])).push(r);
  }), n;
}
var ri = /* @__PURE__ */ Object.create(null);
function yn(i, t) {
  ri[i] = t;
}
function oi(i) {
  return ri[i] || ri[""];
}
function ro(i, t = true, e = false) {
  const s = [];
  return i.forEach((n) => {
    const r = typeof n == "string" ? he(n, t, e) : n;
    r && s.push(r);
  }), s;
}
var oo = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function lo(i, t, e, s) {
  const n = i.resources.length, r = i.random ? Math.floor(Math.random() * n) : i.index;
  let o;
  if (i.random) {
    let _ = i.resources.slice(0);
    for (o = []; _.length > 1; ) {
      const T = Math.floor(Math.random() * _.length);
      o.push(_[T]), _ = _.slice(0, T).concat(_.slice(T + 1));
    }
    o = o.concat(_);
  } else
    o = i.resources.slice(r).concat(i.resources.slice(0, r));
  const a = Date.now();
  let l = "pending", c = 0, u, h = null, f = [], p = [];
  typeof s == "function" && p.push(s);
  function b() {
    h && (clearTimeout(h), h = null);
  }
  function v() {
    l === "pending" && (l = "aborted"), b(), f.forEach((_) => {
      _.status === "pending" && (_.status = "aborted");
    }), f = [];
  }
  function g(_, T) {
    T && (p = []), typeof _ == "function" && p.push(_);
  }
  function S() {
    return {
      startTime: a,
      payload: t,
      status: l,
      queriesSent: c,
      queriesPending: f.length,
      subscribe: g,
      abort: v
    };
  }
  function E() {
    l = "failed", p.forEach((_) => {
      _(void 0, u);
    });
  }
  function w() {
    f.forEach((_) => {
      _.status === "pending" && (_.status = "aborted");
    }), f = [];
  }
  function $(_, T, j) {
    const B = T !== "success";
    switch (f = f.filter((A) => A !== _), l) {
      case "pending":
        break;
      case "failed":
        if (B || !i.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (T === "abort") {
      u = j, E();
      return;
    }
    if (B) {
      u = j, f.length || (o.length ? O() : E());
      return;
    }
    if (b(), w(), !i.random) {
      const A = i.resources.indexOf(_.resource);
      A !== -1 && A !== i.index && (i.index = A);
    }
    l = "completed", p.forEach((A) => {
      A(j);
    });
  }
  function O() {
    if (l !== "pending")
      return;
    b();
    const _ = o.shift();
    if (_ === void 0) {
      if (f.length) {
        h = setTimeout(() => {
          b(), l === "pending" && (w(), E());
        }, i.timeout);
        return;
      }
      E();
      return;
    }
    const T = {
      status: "pending",
      resource: _,
      callback: (j, B) => {
        $(T, j, B);
      }
    };
    f.push(T), c++, h = setTimeout(O, i.rotate), e(_, t, T.callback);
  }
  return setTimeout(O), S;
}
function ys(i) {
  const t = {
    ...oo,
    ...i
  };
  let e = [];
  function s() {
    e = e.filter((a) => a().status === "pending");
  }
  function n(a, l, c) {
    const u = lo(
      t,
      a,
      l,
      (h, f) => {
        s(), c && c(h, f);
      }
    );
    return e.push(u), u;
  }
  function r(a) {
    return e.find((l) => a(l)) || null;
  }
  return {
    query: n,
    find: r,
    setIndex: (a) => {
      t.index = a;
    },
    getIndex: () => t.index,
    cleanup: s
  };
}
function $i(i) {
  let t;
  if (typeof i.resources == "string")
    t = [i.resources];
  else if (t = i.resources, !(t instanceof Array) || !t.length)
    return null;
  return {
    // API hosts
    resources: t,
    // Root path
    path: i.path || "/",
    // URL length limit
    maxURL: i.maxURL || 500,
    // Timeout before next host is used.
    rotate: i.rotate || 750,
    // Timeout before failing query.
    timeout: i.timeout || 5e3,
    // Randomise default API end point.
    random: i.random === true,
    // Start index
    index: i.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: i.dataAfterTimeout !== false
  };
}
var De = /* @__PURE__ */ Object.create(null);
var Wt = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
var we = [];
for (; Wt.length > 0; )
  Wt.length === 1 || Math.random() > 0.5 ? we.push(Wt.shift()) : we.push(Wt.pop());
De[""] = $i({
  resources: ["https://api.iconify.design"].concat(we)
});
function _n(i, t) {
  const e = $i(t);
  return e === null ? false : (De[i] = e, true);
}
function Fe(i) {
  return De[i];
}
function ao() {
  return Object.keys(De);
}
function wn() {
}
var Ze = /* @__PURE__ */ Object.create(null);
function co(i) {
  if (!Ze[i]) {
    const t = Fe(i);
    if (!t)
      return;
    const e = ys(t), s = {
      config: t,
      redundancy: e
    };
    Ze[i] = s;
  }
  return Ze[i];
}
function _s(i, t, e) {
  let s, n;
  if (typeof i == "string") {
    const r = oi(i);
    if (!r)
      return e(void 0, 424), wn;
    n = r.send;
    const o = co(i);
    o && (s = o.redundancy);
  } else {
    const r = $i(i);
    if (r) {
      s = ys(r);
      const o = i.resources ? i.resources[0] : "", a = oi(o);
      a && (n = a.send);
    }
  }
  return !s || !n ? (e(void 0, 424), wn) : s.query(t, n, e)().abort;
}
var xn = "iconify2";
var se = "iconify";
var ws = se + "-count";
var $n = se + "-version";
var xs = 36e5;
var uo = 168;
var ho = 50;
function li(i, t) {
  try {
    return i.getItem(t);
  } catch {
  }
}
function Ci(i, t, e) {
  try {
    return i.setItem(t, e), true;
  } catch {
  }
}
function Cn(i, t) {
  try {
    i.removeItem(t);
  } catch {
  }
}
function ai(i, t) {
  return Ci(i, ws, t.toString());
}
function ci(i) {
  return parseInt(li(i, ws)) || 0;
}
var _t = {
  local: true,
  session: true
};
var $s = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
var Ei = false;
function fo(i) {
  Ei = i;
}
var ve = typeof window > "u" ? {} : window;
function Cs(i) {
  const t = i + "Storage";
  try {
    if (ve && ve[t] && typeof ve[t].length == "number")
      return ve[t];
  } catch {
  }
  _t[i] = false;
}
function Es(i, t) {
  const e = Cs(i);
  if (!e)
    return;
  const s = li(e, $n);
  if (s !== xn) {
    if (s) {
      const a = ci(e);
      for (let l = 0; l < a; l++)
        Cn(e, se + l.toString());
    }
    Ci(e, $n, xn), ai(e, 0);
    return;
  }
  const n = Math.floor(Date.now() / xs) - uo, r = (a) => {
    const l = se + a.toString(), c = li(e, l);
    if (typeof c == "string") {
      try {
        const u = JSON.parse(c);
        if (typeof u == "object" && typeof u.cached == "number" && u.cached > n && typeof u.provider == "string" && typeof u.data == "object" && typeof u.data.prefix == "string" && // Valid item: run callback
        t(u, a))
          return true;
      } catch {
      }
      Cn(e, l);
    }
  };
  let o = ci(e);
  for (let a = o - 1; a >= 0; a--)
    r(a) || (a === o - 1 ? (o--, ai(e, o)) : $s[i].add(a));
}
function Ss() {
  if (!Ei) {
    fo(true);
    for (const i in _t)
      Es(i, (t) => {
        const e = t.data, s = t.provider, n = e.prefix, r = ot(
          s,
          n
        );
        if (!xi(r, e).length)
          return false;
        const o = e.lastModified || -1;
        return r.lastModifiedCached = r.lastModifiedCached ? Math.min(r.lastModifiedCached, o) : o, true;
      });
  }
}
function po(i, t) {
  const e = i.lastModifiedCached;
  if (
    // Matches or newer
    e && e >= t
  )
    return e === t;
  if (i.lastModifiedCached = t, e)
    for (const s in _t)
      Es(s, (n) => {
        const r = n.data;
        return n.provider !== i.provider || r.prefix !== i.prefix || r.lastModified === t;
      });
  return true;
}
function mo(i, t) {
  Ei || Ss();
  function e(s) {
    let n;
    if (!_t[s] || !(n = Cs(s)))
      return;
    const r = $s[s];
    let o;
    if (r.size)
      r.delete(o = Array.from(r).shift());
    else if (o = ci(n), o >= ho || !ai(n, o + 1))
      return;
    const a = {
      cached: Math.floor(Date.now() / xs),
      provider: i.provider,
      data: t
    };
    return Ci(
      n,
      se + o.toString(),
      JSON.stringify(a)
    );
  }
  t.lastModified && !po(i, t.lastModified) || Object.keys(t.icons).length && (t.not_found && (t = Object.assign({}, t), delete t.not_found), e("local") || e("session"));
}
function En() {
}
function bo(i) {
  i.iconsLoaderFlag || (i.iconsLoaderFlag = true, setTimeout(() => {
    i.iconsLoaderFlag = false, io(i);
  }));
}
function go(i, t) {
  i.iconsToLoad ? i.iconsToLoad = i.iconsToLoad.concat(t).sort() : i.iconsToLoad = t, i.iconsQueueFlag || (i.iconsQueueFlag = true, setTimeout(() => {
    i.iconsQueueFlag = false;
    const { provider: e, prefix: s } = i, n = i.iconsToLoad;
    delete i.iconsToLoad;
    let r;
    if (!n || !(r = oi(e)))
      return;
    r.prepare(e, s, n).forEach((a) => {
      _s(e, a, (l) => {
        if (typeof l != "object")
          a.icons.forEach((c) => {
            i.missing.add(c);
          });
        else
          try {
            const c = xi(
              i,
              l
            );
            if (!c.length)
              return;
            const u = i.pendingIcons;
            u && c.forEach((h) => {
              u.delete(h);
            }), mo(i, l);
          } catch (c) {
            console.error(c);
          }
        bo(i);
      });
    });
  }));
}
var Si = (i, t) => {
  const e = ro(i, true, bs()), s = eo(e);
  if (!s.pending.length) {
    let l = true;
    return t && setTimeout(() => {
      l && t(
        s.loaded,
        s.missing,
        s.pending,
        En
      );
    }), () => {
      l = false;
    };
  }
  const n = /* @__PURE__ */ Object.create(null), r = [];
  let o, a;
  return s.pending.forEach((l) => {
    const { provider: c, prefix: u } = l;
    if (u === a && c === o)
      return;
    o = c, a = u, r.push(ot(c, u));
    const h = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));
    h[u] || (h[u] = []);
  }), s.pending.forEach((l) => {
    const { provider: c, prefix: u, name: h } = l, f = ot(c, u), p = f.pendingIcons || (f.pendingIcons = /* @__PURE__ */ new Set());
    p.has(h) || (p.add(h), n[c][u].push(h));
  }), r.forEach((l) => {
    const { provider: c, prefix: u } = l;
    n[c][u].length && go(l, n[c][u]);
  }), t ? so(t, s, r) : En;
};
var vo = (i) => new Promise((t, e) => {
  const s = typeof i == "string" ? he(i, true) : i;
  if (!s) {
    e(i);
    return;
  }
  Si([s || i], (n) => {
    if (n.length && s) {
      const r = ne(s);
      if (r) {
        t({
          ...ue,
          ...r
        });
        return;
      }
    }
    e(i);
  });
});
function yo(i) {
  try {
    const t = typeof i == "string" ? JSON.parse(i) : i;
    if (typeof t.body == "string")
      return {
        ...t
      };
  } catch {
  }
}
function _o(i, t) {
  const e = typeof i == "string" ? he(i, true, true) : null;
  if (!e) {
    const r = yo(i);
    return {
      value: i,
      data: r
    };
  }
  const s = ne(e);
  if (s !== void 0 || !e.prefix)
    return {
      value: i,
      name: e,
      data: s
      // could be 'null' -> icon is missing
    };
  const n = Si([e], () => t(i, e, ne(e)));
  return {
    value: i,
    name: e,
    loading: n
  };
}
function ti(i) {
  return i.hasAttribute("inline");
}
var As = false;
try {
  As = navigator.vendor.indexOf("Apple") === 0;
} catch {
}
function wo(i, t) {
  switch (t) {
    case "svg":
    case "bg":
    case "mask":
      return t;
  }
  return t !== "style" && (As || i.indexOf("<a") === -1) ? "svg" : i.indexOf("currentColor") === -1 ? "bg" : "mask";
}
var xo = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var $o = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function ui(i, t, e) {
  if (t === 1)
    return i;
  if (e = e || 100, typeof i == "number")
    return Math.ceil(i * t * e) / e;
  if (typeof i != "string")
    return i;
  const s = i.split(xo);
  if (s === null || !s.length)
    return i;
  const n = [];
  let r = s.shift(), o = $o.test(r);
  for (; ; ) {
    if (o) {
      const a = parseFloat(r);
      isNaN(a) ? n.push(r) : n.push(Math.ceil(a * t * e) / e);
    } else
      n.push(r);
    if (r = s.shift(), r === void 0)
      return n.join("");
    o = !o;
  }
}
function Co(i, t = "defs") {
  let e = "";
  const s = i.indexOf("<" + t);
  for (; s >= 0; ) {
    const n = i.indexOf(">", s), r = i.indexOf("</" + t);
    if (n === -1 || r === -1)
      break;
    const o = i.indexOf(">", r);
    if (o === -1)
      break;
    e += i.slice(n + 1, r).trim(), i = i.slice(0, s).trim() + i.slice(o + 1);
  }
  return {
    defs: e,
    content: i
  };
}
function Eo(i, t) {
  return i ? "<defs>" + i + "</defs>" + t : t;
}
function So(i, t, e) {
  const s = Co(i);
  return Eo(s.defs, t + s.content + e);
}
var Ao = (i) => i === "unset" || i === "undefined" || i === "none";
function Os(i, t) {
  const e = {
    ...ue,
    ...i
  }, s = {
    ...ds,
    ...t
  }, n = {
    left: e.left,
    top: e.top,
    width: e.width,
    height: e.height
  };
  let r = e.body;
  [e, s].forEach((v) => {
    const g = [], S = v.hFlip, E = v.vFlip;
    let w = v.rotate;
    S ? E ? w += 2 : (g.push(
      "translate(" + (n.width + n.left).toString() + " " + (0 - n.top).toString() + ")"
    ), g.push("scale(-1 1)"), n.top = n.left = 0) : E && (g.push(
      "translate(" + (0 - n.left).toString() + " " + (n.height + n.top).toString() + ")"
    ), g.push("scale(1 -1)"), n.top = n.left = 0);
    let $;
    switch (w < 0 && (w -= Math.floor(w / 4) * 4), w = w % 4, w) {
      case 1:
        $ = n.height / 2 + n.top, g.unshift(
          "rotate(90 " + $.toString() + " " + $.toString() + ")"
        );
        break;
      case 2:
        g.unshift(
          "rotate(180 " + (n.width / 2 + n.left).toString() + " " + (n.height / 2 + n.top).toString() + ")"
        );
        break;
      case 3:
        $ = n.width / 2 + n.left, g.unshift(
          "rotate(-90 " + $.toString() + " " + $.toString() + ")"
        );
        break;
    }
    w % 2 === 1 && (n.left !== n.top && ($ = n.left, n.left = n.top, n.top = $), n.width !== n.height && ($ = n.width, n.width = n.height, n.height = $)), g.length && (r = So(
      r,
      '<g transform="' + g.join(" ") + '">',
      "</g>"
    ));
  });
  const o = s.width, a = s.height, l = n.width, c = n.height;
  let u, h;
  o === null ? (h = a === null ? "1em" : a === "auto" ? c : a, u = ui(h, l / c)) : (u = o === "auto" ? l : o, h = a === null ? ui(u, c / l) : a === "auto" ? c : a);
  const f = {}, p = (v, g) => {
    Ao(g) || (f[v] = g.toString());
  };
  p("width", u), p("height", h);
  const b = [n.left, n.top, l, c];
  return f.viewBox = b.join(" "), {
    attributes: f,
    viewBox: b,
    body: r
  };
}
function Ai(i, t) {
  let e = i.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const s in t)
    e += " " + s + '="' + t[s] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + e + ">" + i + "</svg>";
}
function Oo(i) {
  return i.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function ko(i) {
  return "data:image/svg+xml," + Oo(i);
}
function ks(i) {
  return 'url("' + ko(i) + '")';
}
var Po = () => {
  let i;
  try {
    if (i = fetch, typeof i == "function")
      return i;
  } catch {
  }
};
var ke = Po();
function To(i) {
  ke = i;
}
function Lo() {
  return ke;
}
function Io(i, t) {
  const e = Fe(i);
  if (!e)
    return 0;
  let s;
  if (!e.maxURL)
    s = 0;
  else {
    let n = 0;
    e.resources.forEach((o) => {
      n = Math.max(n, o.length);
    });
    const r = t + ".json?icons=";
    s = e.maxURL - n - e.path.length - r.length;
  }
  return s;
}
function zo(i) {
  return i === 404;
}
var Ro = (i, t, e) => {
  const s = [], n = Io(i, t), r = "icons";
  let o = {
    type: r,
    provider: i,
    prefix: t,
    icons: []
  }, a = 0;
  return e.forEach((l, c) => {
    a += l.length + 1, a >= n && c > 0 && (s.push(o), o = {
      type: r,
      provider: i,
      prefix: t,
      icons: []
    }, a = l.length), o.icons.push(l);
  }), s.push(o), s;
};
function Mo(i) {
  if (typeof i == "string") {
    const t = Fe(i);
    if (t)
      return t.path;
  }
  return "/";
}
var jo = (i, t, e) => {
  if (!ke) {
    e("abort", 424);
    return;
  }
  let s = Mo(t.provider);
  switch (t.type) {
    case "icons": {
      const r = t.prefix, a = t.icons.join(","), l = new URLSearchParams({
        icons: a
      });
      s += r + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const r = t.uri;
      s += r.slice(0, 1) === "/" ? r.slice(1) : r;
      break;
    }
    default:
      e("abort", 400);
      return;
  }
  let n = 503;
  ke(i + s).then((r) => {
    const o = r.status;
    if (o !== 200) {
      setTimeout(() => {
        e(zo(o) ? "abort" : "next", o);
      });
      return;
    }
    return n = 501, r.json();
  }).then((r) => {
    if (typeof r != "object" || r === null) {
      setTimeout(() => {
        r === 404 ? e("abort", r) : e("next", n);
      });
      return;
    }
    setTimeout(() => {
      e("success", r);
    });
  }).catch(() => {
    e("next", n);
  });
};
var Bo = {
  prepare: Ro,
  send: jo
};
function Sn(i, t) {
  switch (i) {
    case "local":
    case "session":
      _t[i] = t;
      break;
    case "all":
      for (const e in _t)
        _t[e] = t;
      break;
  }
}
var ei = "data-style";
var Ps = "";
function Ho(i) {
  Ps = i;
}
function An(i, t) {
  let e = Array.from(i.childNodes).find((s) => s.hasAttribute && s.hasAttribute(ei));
  e || (e = document.createElement("style"), e.setAttribute(ei, ei), i.appendChild(e)), e.textContent = ":host{display:inline-block;vertical-align:" + (t ? "-0.125em" : "0") + "}span,svg{display:block}" + Ps;
}
function Ts() {
  yn("", Bo), bs(true);
  let i;
  try {
    i = window;
  } catch {
  }
  if (i) {
    if (Ss(), i.IconifyPreload !== void 0) {
      const e = i.IconifyPreload, s = "Invalid IconifyPreload syntax.";
      typeof e == "object" && e !== null && (e instanceof Array ? e : [e]).forEach((n) => {
        try {
          (typeof n != "object" || n === null || n instanceof Array || // Check for 'icons' and 'prefix'
          typeof n.icons != "object" || typeof n.prefix != "string" || // Add icon set
          !gn(n)) && console.error(s);
        } catch {
          console.error(s);
        }
      });
    }
    if (i.IconifyProviders !== void 0) {
      const e = i.IconifyProviders;
      if (typeof e == "object" && e !== null)
        for (const s in e) {
          const n = "IconifyProviders[" + s + "] is invalid.";
          try {
            const r = e[s];
            if (typeof r != "object" || !r || r.resources === void 0)
              continue;
            _n(s, r) || console.error(n);
          } catch {
            console.error(n);
          }
        }
    }
  }
  return {
    enableCache: (e) => Sn(e, true),
    disableCache: (e) => Sn(e, false),
    iconLoaded: vn,
    iconExists: vn,
    getIcon: to,
    listIcons: Zr,
    addIcon: gs,
    addCollection: gn,
    calculateSize: ui,
    buildIcon: Os,
    iconToHTML: Ai,
    svgToURL: ks,
    loadIcons: Si,
    loadIcon: vo,
    addAPIProvider: _n,
    appendCustomStyle: Ho,
    _api: {
      getAPIConfig: Fe,
      setAPIModule: yn,
      sendAPIQuery: _s,
      setFetch: To,
      getFetch: Lo,
      listAPIProviders: ao
    }
  };
}
var hi = {
  "background-color": "currentColor"
};
var Ls = {
  "background-color": "transparent"
};
var On = {
  image: "var(--svg)",
  repeat: "no-repeat",
  size: "100% 100%"
};
var kn = {
  "-webkit-mask": hi,
  mask: hi,
  background: Ls
};
for (const i in kn) {
  const t = kn[i];
  for (const e in On)
    t[i + "-" + e] = On[e];
}
function Pn(i) {
  return i ? i + (i.match(/^[-0-9.]+$/) ? "px" : "") : "inherit";
}
function No(i, t, e) {
  const s = document.createElement("span");
  let n = i.body;
  n.indexOf("<a") !== -1 && (n += "<!-- " + Date.now() + " -->");
  const r = i.attributes, o = Ai(n, {
    ...r,
    width: t.width + "",
    height: t.height + ""
  }), a = ks(o), l = s.style, c = {
    "--svg": a,
    width: Pn(r.width),
    height: Pn(r.height),
    ...e ? hi : Ls
  };
  for (const u in c)
    l.setProperty(u, c[u]);
  return s;
}
var Jt;
function Do() {
  try {
    Jt = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (i) => i
    });
  } catch {
    Jt = null;
  }
}
function Fo(i) {
  return Jt === void 0 && Do(), Jt ? Jt.createHTML(i) : i;
}
function Vo(i) {
  const t = document.createElement("span"), e = i.attributes;
  let s = "";
  e.width || (s = "width: inherit;"), e.height || (s += "height: inherit;"), s && (e.style = s);
  const n = Ai(i.body, e);
  return t.innerHTML = Fo(n), t.firstChild;
}
function di(i) {
  return Array.from(i.childNodes).find((t) => {
    const e = t.tagName && t.tagName.toUpperCase();
    return e === "SPAN" || e === "SVG";
  });
}
function Tn(i, t) {
  const e = t.icon.data, s = t.customisations, n = Os(e, s);
  s.preserveAspectRatio && (n.attributes.preserveAspectRatio = s.preserveAspectRatio);
  const r = t.renderedMode;
  let o;
  switch (r) {
    case "svg":
      o = Vo(n);
      break;
    default:
      o = No(n, {
        ...ue,
        ...e
      }, r === "mask");
  }
  const a = di(i);
  a ? o.tagName === "SPAN" && a.tagName === o.tagName ? a.setAttribute("style", o.getAttribute("style")) : i.replaceChild(o, a) : i.appendChild(o);
}
function Ln(i, t, e) {
  const s = e && (e.rendered ? e : e.lastRender);
  return {
    rendered: false,
    inline: t,
    icon: i,
    lastRender: s
  };
}
function Uo(i = "iconify-icon") {
  let t, e;
  try {
    t = window.customElements, e = window.HTMLElement;
  } catch {
    return;
  }
  if (!t || !e)
    return;
  const s = t.get(i);
  if (s)
    return s;
  const n = [
    // Icon
    "icon",
    // Mode
    "mode",
    "inline",
    "observe",
    // Customisations
    "width",
    "height",
    "rotate",
    "flip"
  ], r = class extends e {
    /**
     * Constructor
     */
    constructor() {
      super();
      et(this, "_shadowRoot");
      et(this, "_initialised", false);
      et(this, "_state");
      et(this, "_checkQueued", false);
      et(this, "_connected", false);
      et(this, "_observer", null);
      et(this, "_visible", true);
      const l = this._shadowRoot = this.attachShadow({
        mode: "open"
      }), c = ti(this);
      An(l, c), this._state = Ln({
        value: ""
      }, c), this._queueCheck();
    }
    /**
     * Connected to DOM
     */
    connectedCallback() {
      this._connected = true, this.startObserver();
    }
    /**
     * Disconnected from DOM
     */
    disconnectedCallback() {
      this._connected = false, this.stopObserver();
    }
    /**
     * Observed attributes
     */
    static get observedAttributes() {
      return n.slice(0);
    }
    /**
     * Observed properties that are different from attributes
     *
     * Experimental! Need to test with various frameworks that support it
     */
    /*
    static get properties() {
        return {
            inline: {
                type: Boolean,
                reflect: true,
            },
            // Not listing other attributes because they are strings or combination
            // of string and another type. Cannot have multiple types
        };
    }
    */
    /**
     * Attribute has changed
     */
    attributeChangedCallback(l) {
      switch (l) {
        case "inline": {
          const c = ti(this), u = this._state;
          c !== u.inline && (u.inline = c, An(this._shadowRoot, c));
          break;
        }
        case "observer": {
          this.observer ? this.startObserver() : this.stopObserver();
          break;
        }
        default:
          this._queueCheck();
      }
    }
    /**
     * Get/set icon
     */
    get icon() {
      const l = this.getAttribute("icon");
      if (l && l.slice(0, 1) === "{")
        try {
          return JSON.parse(l);
        } catch {
        }
      return l;
    }
    set icon(l) {
      typeof l == "object" && (l = JSON.stringify(l)), this.setAttribute("icon", l);
    }
    /**
     * Get/set inline
     */
    get inline() {
      return ti(this);
    }
    set inline(l) {
      l ? this.setAttribute("inline", "true") : this.removeAttribute("inline");
    }
    /**
     * Get/set observer
     */
    get observer() {
      return this.hasAttribute("observer");
    }
    set observer(l) {
      l ? this.setAttribute("observer", "true") : this.removeAttribute("observer");
    }
    /**
     * Restart animation
     */
    restartAnimation() {
      const l = this._state;
      if (l.rendered) {
        const c = this._shadowRoot;
        if (l.renderedMode === "svg")
          try {
            c.lastChild.setCurrentTime(0);
            return;
          } catch {
          }
        Tn(c, l);
      }
    }
    /**
     * Get status
     */
    get status() {
      const l = this._state;
      return l.rendered ? "rendered" : l.icon.data === null ? "failed" : "loading";
    }
    /**
     * Queue attributes re-check
     */
    _queueCheck() {
      this._checkQueued || (this._checkQueued = true, setTimeout(() => {
        this._check();
      }));
    }
    /**
     * Check for changes
     */
    _check() {
      if (!this._checkQueued)
        return;
      this._checkQueued = false;
      const l = this._state, c = this.getAttribute("icon");
      if (c !== l.icon.value) {
        this._iconChanged(c);
        return;
      }
      if (!l.rendered || !this._visible)
        return;
      const u = this.getAttribute("mode"), h = mn(this);
      (l.attrMode !== u || Wr(l.customisations, h) || !di(this._shadowRoot)) && this._renderIcon(l.icon, h, u);
    }
    /**
     * Icon value has changed
     */
    _iconChanged(l) {
      const c = _o(l, (u, h, f) => {
        const p = this._state;
        if (p.rendered || this.getAttribute("icon") !== u)
          return;
        const b = {
          value: u,
          name: h,
          data: f
        };
        b.data ? this._gotIconData(b) : p.icon = b;
      });
      c.data ? this._gotIconData(c) : this._state = Ln(c, this._state.inline, this._state);
    }
    /**
     * Force render icon on state change
     */
    _forceRender() {
      if (!this._visible) {
        const l = di(this._shadowRoot);
        l && this._shadowRoot.removeChild(l);
        return;
      }
      this._queueCheck();
    }
    /**
     * Got new icon data, icon is ready to (re)render
     */
    _gotIconData(l) {
      this._checkQueued = false, this._renderIcon(l, mn(this), this.getAttribute("mode"));
    }
    /**
     * Re-render based on icon data
     */
    _renderIcon(l, c, u) {
      const h = wo(l.data.body, u), f = this._state.inline;
      Tn(this._shadowRoot, this._state = {
        rendered: true,
        icon: l,
        inline: f,
        customisations: c,
        attrMode: u,
        renderedMode: h
      });
    }
    /**
     * Start observer
     */
    startObserver() {
      if (!this._observer)
        try {
          this._observer = new IntersectionObserver((l) => {
            const c = l.some((u) => u.isIntersecting);
            c !== this._visible && (this._visible = c, this._forceRender());
          }), this._observer.observe(this);
        } catch {
          if (this._observer) {
            try {
              this._observer.disconnect();
            } catch {
            }
            this._observer = null;
          }
        }
    }
    /**
     * Stop observer
     */
    stopObserver() {
      this._observer && (this._observer.disconnect(), this._observer = null, this._visible = true, this._connected && this._forceRender());
    }
  };
  n.forEach((a) => {
    a in r.prototype || Object.defineProperty(r.prototype, a, {
      get: function() {
        return this.getAttribute(a);
      },
      set: function(l) {
        l !== null ? this.setAttribute(a, l) : this.removeAttribute(a);
      }
    });
  });
  const o = Ts();
  for (const a in o)
    r[a] = r.prototype[a] = o[a];
  return t.define(i, r), r;
}
Uo() || Ts();
var qo = Object.defineProperty;
var q = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && qo(t, e, n), n;
};
var Nt;
var D = (Nt = class extends x {
  constructor() {
    super(), this.labelHidden = false, this.active = false, this.disabled = false, this.vertical = false, this.tooltipVisible = false, this._parent = Tt(), this._tooltip = Tt(), this._contextMenu = Tt(), this._mouseLeave = false, this.onWindowMouseUp = (t) => {
      const { value: e } = this._contextMenu;
      !this.contains(t.target) && e && (e.visible = false);
    }, this.mouseLeave = true;
  }
  set mouseLeave(t) {
    this._mouseLeave = t, t && (this.tooltipVisible = false, clearTimeout(this.timeoutID));
  }
  get mouseLeave() {
    return this._mouseLeave;
  }
  computeTooltipPosition() {
    const { value: t } = this._parent, { value: e } = this._tooltip;
    t && e && ts(t, e, {
      placement: "bottom",
      middleware: [Dn(10), Zn(), Kn(), Jn({ padding: 5 })]
    }).then((s) => {
      const { x: n, y: r } = s;
      Object.assign(e.style, {
        left: `${n}px`,
        top: `${r}px`
      });
    });
  }
  onMouseEnter() {
    if (!(this.tooltipTitle || this.tooltipText))
      return;
    this.mouseLeave = false;
    const t = this.tooltipTime ?? 700;
    this.timeoutID = setTimeout(() => {
      this.mouseLeave || (this.computeTooltipPosition(), this.tooltipVisible = true);
    }, t);
  }
  onChildrenClick(t) {
    t.stopPropagation();
    const { value: e } = this._contextMenu;
    e && (e.visible = !e.visible);
  }
  onSlotChange(t) {
    const { value: e } = this._contextMenu, s = t.target.assignedElements();
    for (const n of s) {
      if (!(n instanceof Nt)) {
        n.remove(), console.warn(
          "Only bim-button is allowed inside bim-button. Child has been removed."
        );
        continue;
      }
      n.addEventListener("click", () => e == null ? void 0 : e.updatePosition());
    }
    this.requestUpdate();
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("mouseup", this.onWindowMouseUp);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("mouseup", this.onWindowMouseUp);
  }
  render() {
    const t = m`
      <div ${Lt(this._tooltip)} class="tooltip">
        ${this.tooltipTitle ? m`<p style="text-wrap: nowrap;">
              <strong>${this.tooltipTitle}</strong>
            </p>` : null}
        ${this.tooltipText ? m`<p style="width: 9rem;">${this.tooltipText}</p>` : null}
      </div>
    `, e = this.children.length > 0;
    return m`
      <div ${Lt(this._parent)} class="parent">
        ${this.label || this.icon ? m`
              <div
                class="button"
                @mouseenter=${this.onMouseEnter}
                @mouseleave=${() => this.mouseLeave = true}
              >
                <bim-label
                  .icon=${this.icon}
                  .vertical=${this.vertical}
                  .labelHidden=${this.labelHidden}
                  >${this.label}</bim-label
                >
              </div>
            ` : null}
        ${this.tooltipTitle || this.tooltipText ? t : null}
        ${e ? m`
              <div class="children" @click=${this.onChildrenClick}>
                <svg
                  style="flex-shrink: 0; fill: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100))"
                  xmlns="http://www.w3.org/2000/svg"
                  height="1.125rem"
                  viewBox="0 0 24 24"
                  width="1.125rem"
                  fill="#9ca3af"
                >
                  <path d="M0 0h24v24H0V0z" fill="none" />
                  <path
                    d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"
                  />
                </svg>
              </div>
            ` : null}
        <bim-context-menu
          ${Lt(this._contextMenu)}
          style="row-gap: var(--bim-ui_size-4xs)"
        >
          <slot @slotchange=${this.onSlotChange}></slot>
        </bim-context-menu>
      </div>
    `;
  }
}, Nt.styles = C`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100, white);
      display: block;
      flex: 1;
      pointer-events: none;
      background-color: var(--bim-button--bgc, var(--bim-ui_bg-contrast-20));
      border-radius: var(--bim-ui_size-4xs);
      transition: all 0.15s;
    }

    :host(:not([disabled]):hover) {
      cursor: pointer;
    }

    bim-label {
      pointer-events: none;
    }

    .parent {
      --bim-icon--c: var(--bim-label--c);
      position: relative;
      display: flex;
      height: 100%;
      user-select: none;
      row-gap: 0.125rem;
      min-height: var(--bim-ui_size-5xl);
      min-width: var(--bim-ui_size-5xl);
    }

    .button,
    .children {
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }

    .children {
      padding: 0 0.375rem;
      position: absolute;
      height: 100%;
      right: 0;
    }

    :host(:not([label-hidden])[icon][vertical]) .parent {
      min-height: 2.5rem;
    }

    .button {
      flex-grow: 1;
    }

    :host(:not([label-hidden])[label]) .button {
      justify-content: var(--bim-button--jc, center);
    }

    :host(:hover),
    :host([active]) {
      --bim-label--c: var(--bim-ui_main-contrast);
      background-color: var(--bim-ui_main-base);
    }

    :host(:not([label]):not([icon])) .children {
      flex: 1;
    }

    :host([vertical]) .parent {
      justify-content: center;
    }

    :host(:not([label-hidden])[label]) .button {
      padding: 0 0.5rem;
    }

    :host([disabled]) .parent {
      background-color: gray;
    }

    ::slotted(bim-button) {
      --bim-icon--fz: var(--bim-ui_size-base);
      --bim-button--bdrs: var(--bim-ui_size-4xs);
      --bim-button--olw: 0;
      --bim-button--olc: transparent;
    }

    .tooltip {
      position: absolute;
      padding: 0.75rem;
      z-index: 99;
      display: flex;
      flex-flow: column;
      row-gap: 0.375rem;
      box-shadow: 0 0 10px 3px rgba(0 0 0 / 20%);
      outline: 1px solid var(--bim-ui_bg-contrast-40);
      font-size: var(--bim-ui_size-xs);
      border-radius: var(--bim-ui_size-4xs);
      background-color: var(--bim-ui_bg-contrast-20);
      color: var(--bim-ui_bg-contrast-100);
    }

    .tooltip p {
      margin: 0;
      padding: 0;
    }

    :host(:not([tooltip-visible])) .tooltip {
      display: none;
    }
  `, Nt);
q([
  d({ type: String, reflect: true })
], D.prototype, "label");
q([
  d({ type: Boolean, attribute: "label-hidden", reflect: true })
], D.prototype, "labelHidden");
q([
  d({ type: Boolean, reflect: true })
], D.prototype, "active");
q([
  d({ type: Boolean, reflect: true, attribute: "disabled" })
], D.prototype, "disabled");
q([
  d({ type: String, reflect: true })
], D.prototype, "icon");
q([
  d({ type: Boolean, reflect: true })
], D.prototype, "vertical");
q([
  d({ type: Number, attribute: "tooltip-time", reflect: true })
], D.prototype, "tooltipTime");
q([
  d({ type: Boolean, attribute: "tooltip-visible", reflect: true })
], D.prototype, "tooltipVisible");
q([
  d({ type: String, attribute: "tooltip-title", reflect: true })
], D.prototype, "tooltipTitle");
q([
  d({ type: String, attribute: "tooltip-text", reflect: true })
], D.prototype, "tooltipText");
var Wo = D;
var Qo = Object.defineProperty;
var de = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Qo(t, e, n), n;
};
var ki = class ki2 extends x {
  constructor() {
    super(...arguments), this.checked = false, this.inverted = false, this.onValueChange = new Event("change");
  }
  /**
   * A getter that returns the current checked state of the checkbox. This is useful for retrieving the checkbox's value in form submissions or JavaScript interactions as it provides a consistent `value` property as many other components.
   * @type {boolean}
   * @default false
   * @example <script>console.log(document.querySelector('bim-checkbox').value);<\/script>
   * @example
   * const checkbox = document.createElement('bim-checkbox');
   * document.body.appendChild(checkbox);
   * console.log(checkbox.value); // false initially
   */
  get value() {
    return this.checked;
  }
  onChange(t) {
    t.stopPropagation(), this.checked = t.target.checked, this.dispatchEvent(this.onValueChange);
  }
  render() {
    return m`
      <div class="parent">
        ${this.label ? m`<bim-label .icon="${this.icon}">${this.label}</bim-label> ` : null}
        <input
          type="checkbox"
          aria-label=${this.label || this.name || "Checkbox Input"}
          @change="${this.onChange}"
          .checked="${this.checked}"
        />
      </div>
    `;
  }
};
ki.styles = C`
    :host {
      display: block;
    }

    .parent {
      display: flex;
      justify-content: space-between;
      height: 1.75rem;
      column-gap: 0.5rem;
      width: 100%;
      align-items: center;
      transition: all 0.15s;
    }

    :host([inverted]) .parent {
      flex-direction: row-reverse;
      justify-content: start;
    }

    input {
      height: 1rem;
      width: 1rem;
      cursor: pointer;
      border: none;
      outline: none;
      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));
      transition: all 0.15s;
    }

    input:focus {
      outline: var(--bim-checkbox--olw, 2px) solid
        var(--bim-checkbox--olc, var(--bim-ui_accent-base));
    }
  `;
var lt = ki;
de([
  d({ type: String, reflect: true })
], lt.prototype, "icon");
de([
  d({ type: String, reflect: true })
], lt.prototype, "name");
de([
  d({ type: String, reflect: true })
], lt.prototype, "label");
de([
  d({ type: Boolean, reflect: true })
], lt.prototype, "checked");
de([
  d({ type: Boolean, reflect: true })
], lt.prototype, "inverted");
var Yo = Object.defineProperty;
var Dt = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Yo(t, e, n), n;
};
var Pi = class Pi2 extends x {
  constructor() {
    super(...arguments), this.vertical = false, this.color = "#bcf124", this._colorInput = Tt(), this._textInput = Tt(), this.onValueChange = new Event("input"), this.onOpacityInput = (t) => {
      const e = t.target;
      this.opacity = e.value, this.dispatchEvent(this.onValueChange);
    };
  }
  /**
   * Represents both the color and opacity values combined into a single object. This is an instance property, not an HTMLElement attribute.
   * @type {Object}
   * @example
   * const colorInput = document.createElement('bim-color-input');
   * colorInput.value = { color: '#ff0000', opacity: 0.5 };
   */
  set value(t) {
    const { color: e, opacity: s } = t;
    this.color = e, s && (this.opacity = s);
  }
  get value() {
    const t = {
      color: this.color
    };
    return this.opacity && (t.opacity = this.opacity), t;
  }
  onColorInput(t) {
    t.stopPropagation();
    const { value: e } = this._colorInput;
    e && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  onTextInput(t) {
    t.stopPropagation();
    const { value: e } = this._textInput;
    if (!e)
      return;
    const { value: s } = e;
    let n = s.replace(/[^a-fA-F0-9]/g, "");
    n.startsWith("#") || (n = `#${n}`), e.value = n.slice(0, 7), e.value.length === 7 && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  /**
   * Focuses on the color input by programmatically triggering a click event on the underlying color input element.
   * If the color input element is not available, the function does nothing.
   */
  focus() {
    const { value: t } = this._colorInput;
    t && t.click();
  }
  render() {
    return m`
      <div class="parent">
        <bim-input
          .label=${this.label}
          .icon=${this.icon}
          .vertical="${this.vertical}"
        >
          <div class="color-container">
            <div
              style="display: flex; align-items: center; gap: .375rem; height: 100%; flex: 1; padding: 0 0.5rem;"
            >
              <input
                ${Lt(this._colorInput)}
                @input="${this.onColorInput}"
                type="color"
                aria-label=${this.label || this.name || "Color Input"}
                value="${this.color}"
              />
              <div
                @click=${this.focus}
                class="sample"
                style="background-color: ${this.color}"
              ></div>
              <input
                ${Lt(this._textInput)}
                @input="${this.onTextInput}"
                value="${this.color}"
                type="text"
                aria-label=${this.label || this.name || "Text Color Input"}
              />
            </div>
            ${this.opacity !== void 0 ? m`<bim-number-input
                  @change=${this.onOpacityInput}
                  slider
                  suffix="%"
                  min="0"
                  value=${this.opacity}
                  max="100"
                ></bim-number-input>` : null}
          </div>
        </bim-input>
      </div>
    `;
  }
};
Pi.styles = C`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-ui_accent-base);
    }

    .parent {
      display: flex;
      gap: 0.375rem;
    }

    .color-container {
      position: relative;
      outline: none;
      display: flex;
      height: 100%;
      gap: 0.5rem;
      justify-content: flex-start;
      align-items: center;
      flex: 1;
      border-radius: var(--bim-color-input--bdrs, var(--bim-ui_size-4xs));
    }

    .color-container input[type="color"] {
      position: absolute;
      bottom: -0.25rem;
      visibility: hidden;
      width: 0;
      height: 0;
    }

    .color-container .sample {
      width: 1rem;
      height: 1rem;
      border-radius: 0.125rem;
      background-color: #fff;
    }

    .color-container input[type="text"] {
      height: 100%;
      flex: 1;
      width: 3.25rem;
      text-transform: uppercase;
      font-size: 0.75rem;
      background-color: transparent;
      padding: 0%;
      outline: none;
      border: none;
      color: var(--bim-color-input--c, var(--bim-ui_bg-contrast-100));
    }

    bim-number-input {
      flex-grow: 0;
    }
  `;
var G = Pi;
Dt([
  d({ type: String, reflect: true })
], G.prototype, "name");
Dt([
  d({ type: String, reflect: true })
], G.prototype, "label");
Dt([
  d({ type: String, reflect: true })
], G.prototype, "icon");
Dt([
  d({ type: Boolean, reflect: true })
], G.prototype, "vertical");
Dt([
  d({ type: Number, reflect: true })
], G.prototype, "opacity");
Dt([
  d({ type: String, reflect: true })
], G.prototype, "color");
var Go = C`
  ::-webkit-scrollbar {
    width: 0.4rem;
    height: 0.4rem;
    overflow: hidden;
  }

  ::-webkit-scrollbar-thumb {
    border-radius: 0.25rem;
    background-color: var(
      --bim-scrollbar--c,
      color-mix(in lab, var(--bim-ui_main-base), white 15%)
    );
  }

  ::-webkit-scrollbar-track {
    background-color: var(--bim-scrollbar--bgc, var(--bim-ui_bg-base));
  }
`;
var Xo = C`
  :root {
    /* Grayscale Colors */
    --bim-ui_gray-0: hsl(210 10% 5%);
    --bim-ui_gray-1: hsl(210 10% 10%);
    --bim-ui_gray-2: hsl(210 10% 20%);
    --bim-ui_gray-4: hsl(210 10% 40%);
    --bim-ui_gray-6: hsl(210 10% 60%);
    --bim-ui_gray-8: hsl(210 10% 80%);
    --bim-ui_gray-9: hsl(210 10% 90%);
    --bim-ui_gray-10: hsl(210 10% 95%);

    /* Brand Colors */
    --bim-ui_main-base: #6528d7;
    --bim-ui_accent-base: #bcf124;

    /* Brand Colors Contrasts */
    --bim-ui_main-contrast: var(--bim-ui_gray-10);
    --bim-ui_accent-contrast: var(--bim-ui_gray-0);

    /* Sizes */
    --bim-ui_size-4xs: 0.375rem;
    --bim-ui_size-3xs: 0.5rem;
    --bim-ui_size-2xs: 0.625rem;
    --bim-ui_size-xs: 0.75rem;
    --bim-ui_size-sm: 0.875rem;
    --bim-ui_size-base: 1rem;
    --bim-ui_size-lg: 1.125rem;
    --bim-ui_size-xl: 1.25rem;
    --bim-ui_size-2xl: 1.375rem;
    --bim-ui_size-3xl: 1.5rem;
    --bim-ui_size-4xl: 1.625rem;
    --bim-ui_size-5xl: 1.75rem;
    --bim-ui_size-6xl: 1.875rem;
    --bim-ui_size-7xl: 2rem;
    --bim-ui_size-8xl: 2.125rem;
    --bim-ui_size-9xl: 2.25rem;
  }

  /* Background Colors */
  @media (prefers-color-scheme: dark) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-0);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
    }
  }

  @media (prefers-color-scheme: light) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-10);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
      --bim-ui_accent-base: #6528d7;
    }
  }

  html.bim-ui-dark {
    --bim-ui_bg-base: var(--bim-ui_gray-0);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
  }

  html.bim-ui-light {
    --bim-ui_bg-base: var(--bim-ui_gray-10);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
    --bim-ui_accent-base: #6528d7;
  }
`;
var Et = {
  scrollbar: Go,
  globalStyles: Xo
};
var Jo = Object.defineProperty;
var Ko = Object.getOwnPropertyDescriptor;
var Zo = (i, t, e, s) => {
  for (var n = Ko(t, e), r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Jo(t, e, n), n;
};
var Ti = class Ti2 extends x {
  constructor() {
    super(...arguments), this._visible = false, this._middleware = {
      name: "middleware",
      async fn(t) {
        const { right: e, top: s } = await bi(t);
        return t.x -= Math.sign(e) === 1 ? e + 5 : 0, t.y -= Math.sign(s) === 1 ? s + 5 : 0, t;
      }
    };
  }
  get visible() {
    return this._visible;
  }
  set visible(t) {
    this._visible = t, t && this.updatePosition();
  }
  /**
   * Asynchronously updates the position of the context menu relative to a target element.
   * If no target element is provided, it attempts to use the parent node as the target.
   * The position is calculated using the `computePosition` function from `@floating-ui/dom`,
   * which considers various adjustments like offset, inline positioning, flipping, and shifting
   * to ensure the context menu is properly placed relative to the target element.
   *
   * @param [target] - The target element relative to which the context menu should be positioned.
   *                                 If not provided, the parent node is used as the target.
   * @returns A promise that resolves once the position has been updated. This method
   *                          does not explicitly return a value but updates the context menu's style
   *                          properties to position it on the screen.
   */
  async updatePosition(t) {
    const e = t || this.parentNode;
    if (!e) {
      this.visible = false, console.warn("No target element found for context-menu.");
      return;
    }
    const s = await ts(e, this, {
      placement: "right",
      middleware: [
        Dn(10),
        Zn(),
        Kn(),
        Jn({ padding: 5 }),
        this._middleware
      ]
    }), { x: n, y: r } = s;
    this.style.left = `${n}px`, this.style.top = `${r}px`;
  }
  render() {
    return m` <slot></slot> `;
  }
};
Ti.styles = [
  Et.scrollbar,
  C`
      :host {
        --bim-label--fz: var(--bim-ui_size-xs);
        position: absolute;
        top: 0;
        left: 0;
        z-index: 999;
        overflow: auto;
        max-height: 20rem;
        min-width: 3rem;
        flex-direction: column;
        box-shadow: 1px 2px 8px 2px rgba(0, 0, 0, 0.15);
        padding: 0.5rem;
        border-radius: var(--bim-ui_size-4xs);
        background-color: var(
          --bim-context-menu--bgc,
          var(--bim-ui_bg-contrast-20)
        );
      }

      :host([visible]) {
        display: flex;
      }

      :host(:not([visible])) {
        display: none;
      }
    `
];
var Pe = Ti;
Zo([
  d({ type: Boolean, reflect: true })
], Pe.prototype, "visible");
var tl = class extends x {
  constructor() {
    super(...arguments), this._lazyLoadObserver = null, this._visibleElements = [], this.ELEMENTS_BEFORE_OBSERVER = 20, this.useObserver = false, this.elements = /* @__PURE__ */ new Set(), this.observe = (t) => {
      if (!this.useObserver)
        return;
      for (const s of t)
        this.elements.add(s);
      const e = t.slice(this.ELEMENTS_BEFORE_OBSERVER);
      for (const s of e)
        s.remove();
      this.observeLastElement();
    };
  }
  set visibleElements(t) {
    this._visibleElements = this.useObserver ? t : [], this.requestUpdate();
  }
  get visibleElements() {
    return this._visibleElements;
  }
  getLazyObserver() {
    if (!this.useObserver)
      return null;
    if (this._lazyLoadObserver)
      return this._lazyLoadObserver;
    const t = new IntersectionObserver(
      (e) => {
        const s = e[0];
        if (!s.isIntersecting)
          return;
        const n = s.target;
        t.unobserve(n);
        const r = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length, o = [...this.elements][r];
        o && (this.visibleElements = [...this.visibleElements, o], t.observe(o));
      },
      { threshold: 0.5 }
    );
    return t;
  }
  observeLastElement() {
    const t = this.getLazyObserver();
    if (!t)
      return;
    const e = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length - 1, s = [...this.elements][e];
    s && t.observe(s);
  }
  resetVisibleElements() {
    const t = this.getLazyObserver();
    if (t) {
      for (const e of this.elements)
        t.unobserve(e);
      this.visibleElements = [], this.observeLastElement();
    }
  }
  /**
   * Creates a new UI component instance based on the provided template and initial state.
   *
   * @template T - The type of the UI component element.
   * @template S - The type of the component state.
   *
   * @param template - The component template function (stateless or stateful).
   * @param initialState - The initial state of the component (optional for stateless components).
   * @returns The created UI component element or an array containing the element and a function to update its state.
   */
  static create(t, e) {
    const s = document.createDocumentFragment();
    if (t.length === 0)
      return jt(t(), s), s.firstElementChild;
    if (!e)
      throw new Error(
        "UIComponent: Initial state is required for statefull components."
      );
    let n = e;
    const r = t, o = (l) => (n = { ...n, ...l }, jt(r(n), s), n);
    return o(e), [s.firstElementChild, o];
  }
};
var Te = (i, t = true) => {
  let e = {};
  for (const s of i.children) {
    const n = s, r = n.getAttribute("name") || n.getAttribute("label");
    if (r) {
      if ("value" in n) {
        const o = n.value;
        if (typeof o == "object" && !Array.isArray(o) && Object.keys(o).length === 0)
          continue;
        e[r] = n.value;
      } else if (t) {
        const o = Te(n);
        if (Object.keys(o).length === 0)
          continue;
        e[r] = o;
      }
    } else
      t && (e = { ...e, ...Te(n) });
  }
  return e;
};
var Ve = (i) => i === "true" || i === "false" ? i === "true" : i && !isNaN(Number(i)) && i.trim() !== "" ? Number(i) : i;
var el = [">=", "<=", "=", ">", "<", "?", "/", "#"];
function In(i) {
  const t = el.find(
    (a) => i.split(a).length === 2
  ), e = i.split(t).map((a) => a.trim()), [s, n] = e, r = n.startsWith("'") && n.endsWith("'") ? n.replace(/'/g, "") : Ve(n);
  return { key: s, condition: t, value: r };
}
var fi = (i) => {
  try {
    const t = [], e = i.split(/&(?![^()]*\))/).map((s) => s.trim());
    for (const s of e) {
      const n = !s.startsWith("(") && !s.endsWith(")"), r = s.startsWith("(") && s.endsWith(")");
      if (n) {
        const o = In(s);
        t.push(o);
      }
      if (r) {
        const c = {
          operator: "&",
          queries: s.replace(/^(\()|(\))$/g, "").split("&").map((u) => u.trim()).map((u, h) => {
            const f = In(u);
            return h > 0 && (f.operator = "&"), f;
          })
        };
        t.push(c);
      }
    }
    return t;
  } catch {
    return null;
  }
};
var zn = (i, t, e) => {
  let s = false;
  switch (t) {
    case "=":
      s = i === e;
      break;
    case "?":
      s = String(i).includes(String(e));
      break;
    case "<":
      (typeof i == "number" || typeof e == "number") && (s = i < e);
      break;
    case "<=":
      (typeof i == "number" || typeof e == "number") && (s = i <= e);
      break;
    case ">":
      (typeof i == "number" || typeof e == "number") && (s = i > e);
      break;
    case ">=":
      (typeof i == "number" || typeof e == "number") && (s = i >= e);
      break;
    case "/":
      s = String(i).startsWith(String(e));
      break;
  }
  return s;
};
var il = Object.defineProperty;
var nl = Object.getOwnPropertyDescriptor;
var mt = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? nl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && il(t, e, n), n;
};
var Li = class Li2 extends x {
  constructor() {
    super(...arguments), this.checked = false, this.checkbox = false, this.noMark = false, this.vertical = false;
  }
  get value() {
    return this._value !== void 0 ? this._value : this.label ? Ve(this.label) : this.label;
  }
  set value(t) {
    this._value = t;
  }
  render() {
    return m`
      <div class="parent" .title=${this.label ?? ""}>
        ${this.img || this.icon || this.label ? m` <div style="display: flex; column-gap: 0.375rem">
              ${this.checkbox && !this.noMark ? m`<bim-checkbox
                    style="pointer-events: none"
                    .checked=${this.checked}
                  ></bim-checkbox>` : null}
              <bim-label
                .vertical=${this.vertical}
                .icon=${this.icon}
                .img=${this.img}
                >${this.label}</bim-label
              >
            </div>` : null}
        ${!this.checkbox && !this.noMark && this.checked ? m`<svg
              xmlns="http://www.w3.org/2000/svg"
              height="1.125rem"
              viewBox="0 0 24 24"
              width="1.125rem"
              fill="#FFFFFF"
            >
              <path d="M0 0h24v24H0z" fill="none" />
              <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" />
            </svg>` : null}
        <slot></slot>
      </div>
    `;
  }
};
Li.styles = C`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
      display: block;
      box-sizing: border-box;
      flex: 1;
      padding: 0rem 0.5rem;
      border-radius: var(--bim-ui_size-4xs);
      transition: all 0.15s;
    }

    :host(:hover) {
      cursor: pointer;
      background-color: color-mix(
        in lab,
        var(--bim-selector--bgc, var(--bim-ui_bg-contrast-20)),
        var(--bim-ui_main-base) 10%
      );
    }

    :host([checked]) {
      --bim-label--c: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    :host([checked]) svg {
      fill: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    .parent {
      box-sizing: border-box;
      display: flex;
      justify-content: var(--bim-option--jc, space-between);
      column-gap: 0.5rem;
      align-items: center;
      min-height: 1.75rem;
      height: 100%;
    }

    input {
      height: 1rem;
      width: 1rem;
      cursor: pointer;
      border: none;
      outline: none;
      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));
    }

    input:focus {
      outline: var(--bim-checkbox--olw, 2px) solid
        var(--bim-checkbox--olc, var(--bim-ui_accent-base));
    }

    bim-label {
      pointer-events: none;
    }
  `;
var P = Li;
mt([
  d({ type: String, reflect: true })
], P.prototype, "img", 2);
mt([
  d({ type: String, reflect: true })
], P.prototype, "label", 2);
mt([
  d({ type: String, reflect: true })
], P.prototype, "icon", 2);
mt([
  d({ type: Boolean, reflect: true })
], P.prototype, "checked", 2);
mt([
  d({ type: Boolean, reflect: true })
], P.prototype, "checkbox", 2);
mt([
  d({ type: Boolean, attribute: "no-mark", reflect: true })
], P.prototype, "noMark", 2);
mt([
  d({
    converter: {
      fromAttribute(i) {
        return i && Ve(i);
      }
    }
  })
], P.prototype, "value", 1);
mt([
  d({ type: Boolean, reflect: true })
], P.prototype, "vertical", 2);
var sl = Object.defineProperty;
var rl = Object.getOwnPropertyDescriptor;
var bt = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? rl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && sl(t, e, n), n;
};
var Ii = class Ii2 extends tl {
  constructor() {
    super(), this.multiple = false, this.required = false, this.vertical = false, this._visible = false, this._value = /* @__PURE__ */ new Set(), this.onValueChange = new Event("change"), this.onWindowMouseUp = (t) => {
      this.visible && (this.contains(t.target) || (this.visible = false));
    }, this.onOptionClick = (t) => {
      const e = t.target, s = this._value.has(e);
      if (!this.multiple && !this.required && !s)
        this._value = /* @__PURE__ */ new Set([e]);
      else if (!this.multiple && !this.required && s)
        this._value = /* @__PURE__ */ new Set([]);
      else if (!this.multiple && this.required && !s)
        this._value = /* @__PURE__ */ new Set([e]);
      else if (this.multiple && !this.required && !s)
        this._value = /* @__PURE__ */ new Set([...this._value, e]);
      else if (this.multiple && !this.required && s) {
        const n = [...this._value].filter((r) => r !== e);
        this._value = new Set(n);
      } else if (this.multiple && this.required && !s)
        this._value = /* @__PURE__ */ new Set([...this._value, e]);
      else if (this.multiple && this.required && s) {
        const n = [...this._value].filter((o) => o !== e), r = new Set(n);
        r.size !== 0 && (this._value = r);
      }
      this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
    }, this.useObserver = true;
  }
  set visible(t) {
    this._visible = t, t || this.resetVisibleElements();
  }
  get visible() {
    return this._visible;
  }
  /**
   * The selected values in the dropdown.
   * @type {any[]}
   * @example
   * const dropdown = document.createElement('bim-dropdown');
   * dropdown.value = ['option1', 'option2'];
   */
  set value(t) {
    if (this.required && Object.keys(t).length === 0)
      return;
    const e = /* @__PURE__ */ new Set();
    for (const s of t) {
      const n = this.findOption(s);
      if (n && (e.add(n), !this.multiple && Object.keys(t).length === 1))
        break;
    }
    this._value = e, this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
  }
  get value() {
    return [...this._value].filter(
      (e) => e instanceof P && e.checked
    ).map((e) => e.value);
  }
  get _options() {
    const t = /* @__PURE__ */ new Set([...this.elements]);
    for (const e of this.children)
      e instanceof P && t.add(e);
    return [...t];
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    this.observe(e);
    const s = /* @__PURE__ */ new Set();
    for (const n of this.elements) {
      if (!(n instanceof P)) {
        n.remove();
        continue;
      }
      n.checked && s.add(n), n.removeEventListener("click", this.onOptionClick), n.addEventListener("click", this.onOptionClick);
    }
    this._value = s;
  }
  updateOptionsState() {
    for (const t of this._options)
      t instanceof P && (t.checked = this._value.has(t));
  }
  findOption(t) {
    return this._options.find((s) => s instanceof P ? s.label === t || s.value === t : false);
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("mouseup", this.onWindowMouseUp);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("mouseup", this.onWindowMouseUp);
  }
  render() {
    let t, e, s;
    if (this._value.size === 0)
      t = "Select an option...";
    else if (this._value.size === 1) {
      const n = [...this._value][0];
      t = (n == null ? void 0 : n.label) || (n == null ? void 0 : n.value), e = n == null ? void 0 : n.img, s = n == null ? void 0 : n.icon;
    } else
      t = `Multiple (${this._value.size})`;
    return m`
      <bim-input
        title=${this.label ?? ""}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        <div class="input" @click=${() => this.visible = !this.visible}>
          <bim-label
            .img=${e}
            .icon=${s}
            style="overflow: hidden;"
            >${t}</bim-label
          >
          <svg
            style="flex-shrink: 0; fill: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100))"
            xmlns="http://www.w3.org/2000/svg"
            height="1.125rem"
            viewBox="0 0 24 24"
            width="1.125rem"
            fill="#9ca3af"
          >
            <path d="M0 0h24v24H0V0z" fill="none" />
            <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
          </svg>
        </div>
        <bim-context-menu .visible=${this.visible}>
          <slot @slotchange=${this.onSlotChange}></slot>
          ${this.visibleElements.map((n) => n)}
        </bim-context-menu>
      </bim-input>
    `;
  }
};
Ii.styles = [
  Et.scrollbar,
  C`
      :host {
        --bim-input--bgc: var(
          --bim-dropdown--bgc,
          var(--bim-ui_bg-contrast-20)
        );
        --bim-input--olw: 2px;
        --bim-input--olc: transparent;
        --bim-input--bdrs: var(--bim-ui_size-4xs);
        flex: 1;
        display: block;
      }

      :host([visible]) {
        --bim-input--olc: var(--bim-ui_accent-base);
      }

      .input {
        --bim-label--fz: var(--bim-drodown--fz, var(--bim-ui_size-xs));
        --bim-label--c: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100));
        height: 100%;
        display: flex;
        flex: 1;
        overflow: hidden;
        column-gap: 0.25rem;
        outline: none;
        cursor: pointer;
        align-items: center;
        justify-content: space-between;
        padding: 0 0.5rem;
      }

      bim-label {
        pointer-events: none;
      }
    `
];
var H = Ii;
bt([
  d({ type: String, reflect: true })
], H.prototype, "name", 2);
bt([
  d({ type: String, reflect: true })
], H.prototype, "icon", 2);
bt([
  d({ type: String, reflect: true })
], H.prototype, "label", 2);
bt([
  d({ type: Boolean, reflect: true })
], H.prototype, "multiple", 2);
bt([
  d({ type: Boolean, reflect: true })
], H.prototype, "required", 2);
bt([
  d({ type: Boolean, reflect: true })
], H.prototype, "vertical", 2);
bt([
  d({ type: Boolean, reflect: true })
], H.prototype, "visible", 1);
bt([
  ce()
], H.prototype, "_value", 2);
var ol = Object.defineProperty;
var Is = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && ol(t, e, n), n;
};
var zi = class zi2 extends x {
  constructor() {
    super(...arguments), this.floating = false, this.layouts = {};
  }
  // private isVerticalArea(area: string) {
  //   const { rows } = this;
  //   const row = rows.find((row) => row.includes(area));
  //   if (!row)
  //     throw new Error(
  //       `${area} wasn't defined in the grid-template of this bim-grid`,
  //     );
  //   const index = rows.indexOf(row);
  //   const abovePanel = index > 0 && rows[index - 1].includes(area);
  //   const belowPanel =
  //     index < rows.length - 1 && rows[index + 1].includes(area);
  //   return abovePanel || belowPanel;
  // }
  getUniqueAreasFromTemplate(t) {
    const n = t.split(`
`).map((o) => o.trim()).map((o) => o.split('"')[1]).filter((o) => o !== void 0).flatMap((o) => o.split(/\s+/));
    return [...new Set(n)].filter((o) => o !== "");
  }
  firstUpdated() {
    this._onLayoutChange = new Event("layoutchange");
  }
  render() {
    if (this.layout) {
      if (this.layouts[this.layout]) {
        this.innerHTML = "";
        const t = this.layouts[this.layout], s = this.getUniqueAreasFromTemplate(t.template).map((n) => {
          const r = t.elements[n];
          return r && (r.style.gridArea = n), r;
        }).filter((n) => !!n);
        this.style.gridTemplate = t.template, this._onLayoutChange && this.dispatchEvent(this._onLayoutChange), this.append(...s);
      }
    } else
      this.innerHTML = "", this.style.gridTemplate = "", this._onLayoutChange && this.dispatchEvent(this._onLayoutChange);
    return m`<slot></slot>`;
  }
};
zi.styles = C`
    :host {
      display: grid;
      height: 100%;
      width: 100%;
      overflow: hidden;
      box-sizing: border-box;
    }

    /* :host(:not([layout])) {
      display: none;
    } */

    :host([floating]) {
      --bim-panel--bdrs: var(--bim-ui_size-4xs);
      background-color: transparent;
      padding: 1rem;
      gap: 1rem;
      position: absolute;
      pointer-events: none;
      top: 0px;
      left: 0px;
    }

    :host(:not([floating])) {
      --bim-panel--bdrs: 0;
      background-color: var(--bim-ui_bg-contrast-20);
      gap: 1px;
    }
  `;
var re = zi;
Is([
  d({ type: Boolean, reflect: true })
], re.prototype, "floating");
Is([
  d({ type: String, reflect: true })
], re.prototype, "layout");
var Me = class Me2 extends x {
  render() {
    return m`
      <iconify-icon .icon=${this.icon} height="none"></iconify-icon>
    `;
  }
};
Me.styles = C`
    :host {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
    }

    iconify-icon {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
      color: var(--bim-icon--c);
      transition: all 0.15s;
    }
  `, Me.properties = {
  icon: { type: String }
};
var pi = Me;
var ll = Object.defineProperty;
var Ue = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && ll(t, e, n), n;
};
var Ri = class Ri2 extends x {
  constructor() {
    super(...arguments), this.vertical = false, this.onValueChange = new Event("change");
  }
  get value() {
    const t = {};
    for (const e of this.children) {
      const s = e;
      "value" in s ? t[s.name || s.label] = s.value : "checked" in s && (t[s.name || s.label] = s.checked);
    }
    return t;
  }
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((a) => {
        const l = a;
        return l.name === s || l.label === s;
      });
      if (!n)
        continue;
      const r = n, o = t[s];
      typeof o == "boolean" ? r.checked = o : r.value = o;
    }
  }
  render() {
    return m`
      <div class="parent">
        ${this.label || this.icon ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="input">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Ri.styles = C`
    :host {
      flex: 1;
      display: block;
    }

    .parent {
      display: flex;
      flex-wrap: wrap;
      column-gap: 1rem;
      row-gap: 0.375rem;
      user-select: none;
      flex: 1;
    }

    :host(:not([vertical])) .parent {
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .input {
      overflow: hidden;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      min-height: 1.75rem;
      min-width: 3rem;
      gap: var(--bim-input--g, var(--bim-ui_size-4xs));
      padding: var(--bim-input--p, 0);
      background-color: var(--bim-input--bgc, transparent);
      outline: var(--bim-input--olw, 2px) solid
        var(--bim-input--olc, transparent);
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
      transition: all 0.15s;
    }

    :host(:not([vertical])) .input {
      flex: 1;
      justify-content: flex-end;
    }

    :host(:not([vertical])[label]) .input {
      max-width: fit-content;
    }
  `;
var Ct = Ri;
Ue([
  d({ type: String, reflect: true })
], Ct.prototype, "name");
Ue([
  d({ type: String, reflect: true })
], Ct.prototype, "label");
Ue([
  d({ type: String, reflect: true })
], Ct.prototype, "icon");
Ue([
  d({ type: Boolean, reflect: true })
], Ct.prototype, "vertical");
var al = Object.defineProperty;
var fe = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && al(t, e, n), n;
};
var Mi = class Mi2 extends x {
  constructor() {
    super(...arguments), this.labelHidden = false, this.iconHidden = false, this.vertical = false;
  }
  get value() {
    return this.textContent ? Ve(this.textContent) : this.textContent;
  }
  render() {
    return m`
      <div class="parent" .title=${this.textContent ?? ""}>
        ${this.img ? m`<img .src=${this.img} .alt=${this.textContent || ""} />` : null}
        ${!this.iconHidden && this.icon ? m`<bim-icon .icon=${this.icon}></bim-icon>` : null}
        <p><slot></slot></p>
      </div>
    `;
  }
};
Mi.styles = C`
    :host {
      --bim-icon--c: var(--bim-label--c);
      color: var(--bim-label--c, var(--bim-ui_bg-contrast-60));
      font-size: var(--bim-label--fz, var(--bim-ui_size-xs));
      overflow: hidden;
      display: block;
      white-space: nowrap;
      line-height: 1.1rem;
      transition: all 0.15s;
    }

    .parent {
      display: flex;
      align-items: center;
      column-gap: 0.25rem;
      row-gap: 0.125rem;
      user-select: none;
      height: 100%;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .parent p {
      margin: 0;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    :host([label-hidden]) .parent p,
    :host(:empty) .parent p {
      display: none;
    }

    img {
      height: 100%;
      aspect-ratio: 1;
      border-radius: 100%;
      margin-right: 0.125rem;
    }

    :host(:not([vertical])) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 1.5)
      );
    }

    :host([vertical]) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 4)
      );
    }
  `;
var at = Mi;
fe([
  d({ type: String, reflect: true })
], at.prototype, "img");
fe([
  d({ type: Boolean, attribute: "label-hidden", reflect: true })
], at.prototype, "labelHidden");
fe([
  d({ type: String, reflect: true })
], at.prototype, "icon");
fe([
  d({ type: Boolean, attribute: "icon-hidden", reflect: true })
], at.prototype, "iconHidden");
fe([
  d({ type: Boolean, reflect: true })
], at.prototype, "vertical");
var cl = Object.defineProperty;
var ul = Object.getOwnPropertyDescriptor;
var M = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? ul(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && cl(t, e, n), n;
};
var ji = class ji2 extends x {
  constructor() {
    super(...arguments), this._value = 0, this.vertical = false, this.slider = false, this._input = Tt(), this.onValueChange = new Event("change");
  }
  set value(t) {
    this.setValue(t.toString());
  }
  get value() {
    return this._value;
  }
  onChange(t) {
    t.stopPropagation();
    const { value: e } = this._input;
    e && this.setValue(e.value);
  }
  setValue(t) {
    const { value: e } = this._input;
    let s = t;
    if (s = s.replace(/[^0-9.-]/g, ""), s = s.replace(/(\..*)\./g, "$1"), s.endsWith(".") || (s.lastIndexOf("-") > 0 && (s = s[0] + s.substring(1).replace(/-/g, "")), s === "-" || s === "-0"))
      return;
    let n = Number(s);
    Number.isNaN(n) || (n = this.min !== void 0 ? Math.max(n, this.min) : n, n = this.max !== void 0 ? Math.min(n, this.max) : n, this.value !== n && (this._value = n, e && (e.value = this.value.toString()), this.requestUpdate(), this.dispatchEvent(this.onValueChange)));
  }
  onBlur() {
    const { value: t } = this._input;
    t && Number.isNaN(Number(t.value)) && (t.value = this.value.toString());
  }
  onSliderMouseDown(t) {
    document.body.style.cursor = "w-resize";
    const { clientX: e } = t, s = this.value;
    let n = false;
    const r = (l) => {
      var v;
      n = true;
      const { clientX: c } = l, u = this.step ?? 1, h = ((v = u.toString().split(".")[1]) == null ? void 0 : v.length) || 0, f = 1 / (this.sensitivity ?? 1), p = (c - e) / f;
      if (Math.floor(Math.abs(p)) !== Math.abs(p))
        return;
      const b = s + p * u;
      this.setValue(b.toFixed(h));
    }, o = () => {
      this.slider = true, this.removeEventListener("blur", o);
    }, a = () => {
      document.removeEventListener("mousemove", r), document.body.style.cursor = "default", n ? n = false : (this.addEventListener("blur", o), this.slider = false, requestAnimationFrame(() => this.focus())), document.removeEventListener("mouseup", a);
    };
    document.addEventListener("mousemove", r), document.addEventListener("mouseup", a);
  }
  onFocus(t) {
    t.stopPropagation();
    const e = (s) => {
      s.key === "Escape" && (this.blur(), window.removeEventListener("keydown", e));
    };
    window.addEventListener("keydown", e);
  }
  connectedCallback() {
    super.connectedCallback(), this.min && this.min > this.value && (this._value = this.min), this.max && this.max < this.value && (this._value = this.max);
  }
  /**
   * Sets focus to the input element of the number input component.
   * This method is useful for programmatically focusing the input element, for example,
   * in response to a user action or to emphasize the input in the UI.
   *
   * If the input element reference is not available (not yet rendered or disconnected),
   * this method will do nothing.
   */
  focus() {
    const { value: t } = this._input;
    t && t.focus();
  }
  render() {
    const t = m`
      ${this.pref || this.icon ? m`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            .icon=${this.icon}
            >${this.pref}</bim-label
          >` : null}
      <input
        ${Lt(this._input)}
        type="text"
        aria-label=${this.label || this.name || "Number Input"}
        size="1"
        @input=${(a) => a.stopPropagation()}
        @change=${this.onChange}
        @blur=${this.onBlur}
        @focus=${this.onFocus}
        .value=${this.value.toString()}
      />
      ${this.suffix ? m`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            >${this.suffix}</bim-label
          >` : null}
    `, e = this.min ?? -1 / 0, s = this.max ?? 1 / 0, n = 100 * (this.value - e) / (s - e), r = m`
      <style>
        .slider-indicator {
          width: ${`${n}%`};
        }
      </style>
      <div class="slider" @mousedown=${this.onSliderMouseDown}>
        <div class="slider-indicator"></div>
        ${this.pref || this.icon ? m`<bim-label
              style="z-index: 1; margin-right: 0.125rem"
              .icon=${this.icon}
              >${`${this.pref}: `}</bim-label
            >` : null}
        <bim-label style="z-index: 1;">${this.value}</bim-label>
        ${this.suffix ? m`<bim-label style="z-index: 1;">${this.suffix}</bim-label>` : null}
      </div>
    `, o = `${this.label || this.name || this.pref ? `${this.label || this.name || this.pref}: ` : ""}${this.value}${this.suffix ?? ""}`;
    return m`
      <bim-input
        title=${o}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        ${this.slider ? r : t}
      </bim-input>
    `;
  }
};
ji.styles = C`
    :host {
      --bim-input--bgc: var(
        --bim-number-input--bgc,
        var(--bim-ui_bg-contrast-20)
      );
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-number-input--olc, transparent);
      --bim-input--bdrs: var(--bim-number-input--bdrs, var(--bim-ui_size-4xs));
      --bim-input--p: 0 0.375rem;
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(
        --bim-number-inputfocus--c,
        var(--bim-ui_accent-base)
      );
    }

    :host(:not([slider])) bim-label {
      --bim-label--c: var(
        --bim-number-input_affixes--c,
        var(--bim-ui_bg-contrast-60)
      );
      --bim-label--fz: var(
        --bim-number-input_affixes--fz,
        var(--bim-ui_size-xs)
      );
    }

    p {
      margin: 0;
      padding: 0;
    }

    input {
      background-color: transparent;
      outline: none;
      border: none;
      padding: 0;
      flex-grow: 1;
      text-align: right;
      font-family: inherit;
      font-feature-settings: inherit;
      font-variation-settings: inherit;
      font-size: var(--bim-number-input--fz, var(--bim-ui_size-xs));
      color: var(--bim-number-input--c, var(--bim-ui_bg-contrast-100));
    }

    :host([suffix]:not([pref])) input {
      text-align: left;
    }

    :host([slider]) {
      --bim-input--p: 0;
    }

    :host([slider]) .slider {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
    }

    .slider {
      position: relative;
      display: flex;
      justify-content: center;
      width: 100%;
      height: 100%;
      padding: 0 0.5rem;
    }

    .slider-indicator {
      height: 100%;
      background-color: var(--bim-ui_main-base);
      position: absolute;
      top: 0;
      left: 0;
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
    }

    bim-input {
      display: flex;
    }

    bim-label {
      pointer-events: none;
    }
  `;
var L = ji;
M([
  d({ type: String, reflect: true })
], L.prototype, "name", 2);
M([
  d({ type: String, reflect: true })
], L.prototype, "icon", 2);
M([
  d({ type: String, reflect: true })
], L.prototype, "label", 2);
M([
  d({ type: String, reflect: true })
], L.prototype, "pref", 2);
M([
  d({ type: Number, reflect: true })
], L.prototype, "min", 2);
M([
  d({ type: Number, reflect: true })
], L.prototype, "value", 1);
M([
  d({ type: Number, reflect: true })
], L.prototype, "step", 2);
M([
  d({ type: Number, reflect: true })
], L.prototype, "sensitivity", 2);
M([
  d({ type: Number, reflect: true })
], L.prototype, "max", 2);
M([
  d({ type: String, reflect: true })
], L.prototype, "suffix", 2);
M([
  d({ type: Boolean, reflect: true })
], L.prototype, "vertical", 2);
M([
  d({ type: Boolean, reflect: true })
], L.prototype, "slider", 2);
var hl = Object.defineProperty;
var dl = Object.getOwnPropertyDescriptor;
var pe = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? dl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && hl(t, e, n), n;
};
var Bi = class Bi2 extends x {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change"), this._hidden = false, this.headerHidden = false, this.activationButton = document.createElement("bim-button");
  }
  set hidden(t) {
    this._hidden = t, this.activationButton.active = !t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  /**
   * The `value` getter computes and returns the current state of the panel's form elements as an object. This property is dynamic and reflects the current input values within the panel. When accessed, it traverses the panel's child elements, collecting values from those that have a `name` or `label` attribute, and constructs an object where each key corresponds to the `name` or `label` of the element, and the value is the element's value. This property is particularly useful for forms or interactive panels where the user's input needs to be retrieved programmatically. The value returned is a snapshot of the panel's state at the time of access, and it does not maintain a live link to the input elements.
   *
   * @type {Record<string, any>}
   * @default {}
   * @example <bim-panel></bim-panel> <!-- Access via JavaScript to get value -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * console.log(panel.value); // Logs the current value object of the panel
   */
  get value() {
    return Te(this);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel's form elements. When a data object is passed to this property, it attempts to match the object's keys with the `name` or `label` attributes of the panel's child elements. If a match is found, the corresponding element's value is updated to the value associated with the key in the data object. This property is useful for initializing the panel with specific data or updating its state based on external inputs. Note that this operation does not affect elements without a matching `name` or `label`, and it only updates the values of elements that are direct children of the panel.
   *
   * @type {Record<string, any>}
   * @example <bim-panel></bim-panel> <!-- Set value via JavaScript -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * panel.value = { 'input-name': 'John Doe', 'checkbox-name': true };
   */
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((o) => {
        const a = o;
        return a.name === s || a.label === s;
      });
      if (!n)
        continue;
      const r = n;
      r.value = t[s];
    }
  }
  connectedCallback() {
    super.connectedCallback(), this.activationButton.active = !this.hidden, this.activationButton.onclick = () => this.hidden = !this.hidden;
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.activationButton.remove();
  }
  /**
   * Collapses all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `true`,
   * effectively hiding their content from view. This can be used to programmatically minimize the space taken up by sections
   * within the panel, making the panel more compact or to hide details that are not immediately necessary.
   */
  collapseSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = true;
  }
  /**
   * Expands all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `false`,
   * effectively showing their content. This can be used to programmatically reveal the content of sections within the panel,
   * making the panel more informative or to display details that are necessary for the user.
   */
  expandSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = false;
  }
  render() {
    return this.activationButton.icon = this.icon, this.activationButton.label = this.label || this.name, this.activationButton.tooltipTitle = this.label || this.name, m`
      <div class="parent">
        ${this.label || this.name || this.icon ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="sections">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Bi.styles = [
  Et.scrollbar,
  C`
      :host {
        display: flex;
        border-radius: var(--bim-ui_size-base);
        background-color: var(--bim-ui_bg-base);
        overflow: auto;
      }

      :host([hidden]) {
        display: none;
      }

      .parent {
        display: flex;
        flex: 1;
        flex-direction: column;
        pointer-events: auto;
        overflow: auto;
      }

      .parent bim-label {
        --bim-label--c: var(--bim-panel--c, var(--bim-ui_bg-contrast-80));
        --bim-label--fz: var(--bim-panel--fz, var(--bim-ui_size-sm));
        font-weight: 600;
        padding: 1rem;
        flex-shrink: 0;
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([header-hidden]) .parent bim-label {
        display: none;
      }

      .sections {
        display: flex;
        flex-direction: column;
        overflow: auto;
      }

      ::slotted(bim-panel-section:not(:last-child)) {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }
    `
];
var ct = Bi;
pe([
  d({ type: String, reflect: true })
], ct.prototype, "icon", 2);
pe([
  d({ type: String, reflect: true })
], ct.prototype, "name", 2);
pe([
  d({ type: String, reflect: true })
], ct.prototype, "label", 2);
pe([
  d({ type: Boolean, reflect: true })
], ct.prototype, "hidden", 1);
pe([
  d({ type: Boolean, attribute: "header-hidden", reflect: true })
], ct.prototype, "headerHidden", 2);
var fl = Object.defineProperty;
var me = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && fl(t, e, n), n;
};
var Hi = class Hi2 extends x {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change");
  }
  /**
   * The `value` getter computes and returns the current state of the panel section's form elements as an object. This object's keys are the `name` or `label` attributes of the child elements, and the values are the corresponding values of these elements. This property is particularly useful for retrieving a consolidated view of the user's input or selections within the panel section. When the value of any child element changes, the returned object from this getter will reflect those changes, providing a dynamic snapshot of the panel section's state. Note that this property does not have a default value as it dynamically reflects the current state of the panel section's form elements.
   * @type {Record<string, any>}
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a getter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * console.log(section.value); // Logs the current value object
   */
  get value() {
    return Te(this);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel section's child elements. It accepts an object where keys correspond to the `name` or `label` attributes of the child elements, and the values are the new values to be set for these elements. This property is useful for initializing the panel section with specific values or updating its state based on external data. When the property changes, the corresponding child elements' values are updated to reflect the new state. This does not have a default value as it is a method for updating child elements' values.
   * @type {Record<string, any>}
   * @default undefined
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a setter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * section.value = { 'user-settings': 'John Doe' }; // Programmatically sets the value of a child element named 'user-settings'
   */
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((o) => {
        const a = o;
        return a.name === s || a.label === s;
      });
      if (!n)
        continue;
      const r = n;
      r.value = t[s];
    }
  }
  onHeaderClick() {
    this.fixed || (this.collapsed = !this.collapsed);
  }
  render() {
    const t = this.label || this.icon || this.name || this.fixed, e = m`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
    >
      <path d="M0 0h24v24H0V0z" fill="none" />
      <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
    </svg>`, s = m`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
    >
      <path d="M0 0h24v24H0z" fill="none" />
      <path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z" />
    </svg>`, n = this.collapsed ? e : s, r = m`
      <div
        class="header"
        title=${this.label ?? ""}
        @click=${this.onHeaderClick}
      >
        ${this.label || this.icon || this.name ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        ${this.fixed ? null : n}
      </div>
    `;
    return m`
      <div class="parent">
        ${t ? r : null}
        <div class="components">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Hi.styles = [
  Et.scrollbar,
  C`
      :host {
        display: block;
        pointer-events: auto;
      }

      :host(:not([fixed])) .header:hover {
        --bim-label--c: var(--bim-ui_accent-base);
        color: var(--bim-ui_accent-base);
        cursor: pointer;
      }

      :host(:not([fixed])) .header:hover svg {
        fill: var(--bim-ui_accent-base);
      }

      .header {
        --bim-label--fz: var(--bim-ui_size-sm);
        --bim-label--c: var(--bim-ui_bg-contrast-80);
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        height: 1.5rem;
        padding: 0.75rem 1rem;
      }

      .header svg {
        fill: var(--bim-ui_bg-contrast-80);
      }

      .title {
        display: flex;
        align-items: center;
        column-gap: 0.5rem;
      }

      .title p {
        font-size: var(--bim-ui_size-sm);
      }

      .components {
        display: flex;
        flex-direction: column;
        row-gap: 0.75rem;
        padding: 0.125rem 1rem 1rem;
      }

      :host(:not([fixed])[collapsed]) .components {
        display: none;
        height: 0px;
      }

      bim-label {
        pointer-events: none;
      }
    `
];
var ut = Hi;
me([
  d({ type: String, reflect: true })
], ut.prototype, "icon");
me([
  d({ type: String, reflect: true })
], ut.prototype, "label");
me([
  d({ type: String, reflect: true })
], ut.prototype, "name");
me([
  d({ type: Boolean, reflect: true })
], ut.prototype, "fixed");
me([
  d({ type: Boolean, reflect: true })
], ut.prototype, "collapsed");
var pl = Object.defineProperty;
var be = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && pl(t, e, n), n;
};
var Ni = class Ni2 extends x {
  constructor() {
    super(...arguments), this.vertical = false, this.onValueChange = new Event("change"), this._canEmitEvents = false, this._value = document.createElement("bim-option"), this.onOptionClick = (t) => {
      this._value = t.target, this.dispatchEvent(this.onValueChange);
      for (const e of this.children)
        e instanceof P && (e.checked = e === t.target);
    };
  }
  get _options() {
    return [...this.querySelectorAll("bim-option")];
  }
  /**
   * Sets the value of the selector.
   * It finds the matching option based on the provided value and sets it as the selected option.
   * If no matching option is found, it does nothing.
   *
   * @param value - The value to set for the selector.
   */
  set value(t) {
    const e = this.findOption(t);
    if (e) {
      for (const s of this._options)
        s.checked = s === e;
      this._value = e, this._canEmitEvents && this.dispatchEvent(this.onValueChange);
    }
  }
  get value() {
    return this._value.value;
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    for (const s of e)
      s instanceof P && (s.noMark = true, s.removeEventListener("click", this.onOptionClick), s.addEventListener("click", this.onOptionClick));
  }
  findOption(t) {
    return this._options.find((s) => s instanceof P ? s.label === t || s.value === t : false);
  }
  firstUpdated() {
    const t = [...this.children].find(
      (e) => e instanceof P && e.checked
    );
    t && (this._value = t);
  }
  render() {
    return m`
      <bim-input
        .vertical=${this.vertical}
        .label=${this.label}
        .icon=${this.icon}
      >
        <slot @slotchange=${this.onSlotChange}></slot>
      </bim-input>
    `;
  }
};
Ni.styles = C`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      --bim-input--g: 0;
      --bim-option--jc: center;
      flex: 1;
      display: block;
    }

    ::slotted(bim-option) {
      border-radius: 0;
    }

    ::slotted(bim-option[checked]) {
      --bim-label--c: var(--bim-ui_main-contrast);
      background-color: var(--bim-ui_main-base);
    }
  `;
var ht = Ni;
be([
  d({ type: String, reflect: true })
], ht.prototype, "name");
be([
  d({ type: String, reflect: true })
], ht.prototype, "icon");
be([
  d({ type: String, reflect: true })
], ht.prototype, "label");
be([
  d({ type: Boolean, reflect: true })
], ht.prototype, "vertical");
be([
  ce()
], ht.prototype, "_value");
var ml = Object.defineProperty;
var bl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && ml(t, e, n), n;
};
var Di = class Di2 extends x {
  constructor() {
    super(...arguments), this.column = "", this.columnIndex = 0, this.rowData = {};
  }
  get data() {
    return this.column ? this.rowData[this.column] : null;
  }
  render() {
    return m`
      <style>
        :host {
          grid-area: ${this.column ?? "unset"};
        }
      </style>
      <slot></slot>
    `;
  }
};
Di.styles = C`
    :host {
      padding: 0.25rem 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    :host([data-column-index="0"]:not([data-cell-header])) {
      justify-content: normal;
    }

    :host([data-column-index="0"]:not([data-cell-header]))
      ::slotted(bim-label) {
      text-align: left;
    }

    ::slotted(*) {
      --bim-input--bgc: transparent;
      --bim-input--olc: var(--bim-ui_bg-contrast-20);
      --bim-input--olw: 1px;
    }

    ::slotted(bim-input) {
      --bim-input--olw: 0;
    }

    ::slotted(bim-label) {
      white-space: normal;
      text-align: center;
    }
  `;
var Le = Di;
bl([
  d({ type: String, reflect: true })
], Le.prototype, "column");
var gl = Object.defineProperty;
var vl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && gl(t, e, n), n;
};
var Fi = class Fi2 extends x {
  constructor() {
    super(...arguments), this._groups = [], this.data = [], this.table = this.closest("bim-table");
  }
  toggleGroups(t, e = false) {
    for (const s of this._groups)
      s.childrenHidden = typeof t > "u" ? !s.childrenHidden : !t, e && s.toggleChildren(t, e);
  }
  render() {
    return this._groups = [], m`
      <slot></slot>
      ${this.data.map((t) => {
      const e = document.createElement(
        "bim-table-group"
      );
      return this._groups.push(e), e.table = this.table, e.data = t, e;
    })}
    `;
  }
};
Fi.styles = C`
    :host {
      position: relative;
      grid-area: Children;
    }

    :host([hidden]) {
      display: none;
    }

    ::slotted(.branch.branch-vertical) {
      top: 0;
      bottom: 1.125rem;
    }
  `;
var Ie = Fi;
vl([
  d({ type: Array, attribute: false })
], Ie.prototype, "data");
var yl = Object.defineProperty;
var _l = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && yl(t, e, n), n;
};
var Vi = class Vi2 extends x {
  constructor() {
    super(...arguments), this.data = { data: {} }, this.childrenHidden = true, this.table = this.closest("bim-table");
  }
  connectedCallback() {
    super.connectedCallback(), this.table && this.table.expanded ? this.childrenHidden = false : this.childrenHidden = true;
  }
  toggleChildren(t, e = false) {
    this._children && (this.childrenHidden = typeof t > "u" ? !this.childrenHidden : !t, e && this._children.toggleGroups(t, e));
  }
  render() {
    var f, p;
    const t = ((f = this.table) == null ? void 0 : f.getGroupIndentation(this.data)) ?? 0, e = m`
      <style>
        .branch-vertical {
          left: ${t + 0.5625}rem;
        }
      </style>
      <div class="branch branch-vertical"></div>
    `, s = document.createDocumentFragment();
    jt(e, s);
    const n = document.createElement("div");
    n.classList.add("branch", "branch-horizontal"), n.style.left = `${t - 1 + 0.5625}rem`;
    const r = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "svg"
    );
    r.setAttribute("height", "9.5"), r.setAttribute("width", "7.5"), r.setAttribute("viewBox", "0 0 4.6666672 7.3333333");
    const o = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "path"
    );
    o.setAttribute(
      "d",
      "m 1.7470835,6.9583848 2.5899999,-2.59 c 0.39,-0.39 0.39,-1.02 0,-1.41 L 1.7470835,0.36838483 c -0.63,-0.62000003 -1.71000005,-0.18 -1.71000005,0.70999997 v 5.17 c 0,0.9 1.08000005,1.34 1.71000005,0.71 z"
    ), r.append(o);
    const a = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "svg"
    );
    a.setAttribute("height", "6.5"), a.setAttribute("width", "9.5"), a.setAttribute("viewBox", "0 0 5.9111118 5.0175439");
    const l = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "path"
    );
    l.setAttribute(
      "d",
      "M -0.33616196,1.922522 2.253838,4.5125219 c 0.39,0.39 1.02,0.39 1.41,0 L 6.2538379,1.922522 c 0.6200001,-0.63 0.18,-1.71000007 -0.7099999,-1.71000007 H 0.37383804 c -0.89999997,0 -1.33999997,1.08000007 -0.71,1.71000007 z"
    ), a.append(l);
    const c = document.createElement("div");
    c.addEventListener("click", (b) => {
      b.stopPropagation(), this.toggleChildren();
    }), c.classList.add("caret"), c.style.left = `${0.125 + t}rem`, this.childrenHidden ? c.append(r) : c.append(a);
    const u = document.createElement("bim-table-row");
    this.data.children && !this.childrenHidden && u.append(s), u.table = this.table, u.data = this.data.data, (p = this.table) == null || p.dispatchEvent(
      new CustomEvent("rowcreated", { detail: { row: u } })
    ), this.data.children && u.append(c), t !== 0 && (!this.data.children || this.childrenHidden) && u.append(n);
    let h;
    if (this.data.children) {
      h = document.createElement("bim-table-children"), this._children = h, h.table = this.table, h.data = this.data.children;
      const b = document.createDocumentFragment();
      jt(e, b), h.append(b);
    }
    return m`
      <div class="parent">${u} ${this.childrenHidden ? null : h}</div>
    `;
  }
};
Vi.styles = C`
    :host {
      position: relative;
    }

    .parent {
      display: grid;
      grid-template-areas: "Data" "Children";
    }

    .branch {
      position: absolute;
      z-index: 1;
    }

    .branch-vertical {
      border-left: 1px dotted var(--bim-ui_bg-contrast-40);
    }

    .branch-horizontal {
      top: 50%;
      width: 1rem;
      border-bottom: 1px dotted var(--bim-ui_bg-contrast-40);
    }

    .caret {
      position: absolute;
      z-index: 2;
      transform: translateY(-50%) rotate(0deg);
      top: 50%;
      display: flex;
      width: 0.95rem;
      height: 0.95rem;
      justify-content: center;
      align-items: center;
      cursor: pointer;
    }

    .caret svg {
      fill: var(--bim-ui_bg-contrast-60);
    }
  `;
var ze = Vi;
_l([
  d({ type: Boolean, attribute: "children-hidden", reflect: true })
], ze.prototype, "childrenHidden");
var wl = Object.defineProperty;
var ge = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && wl(t, e, n), n;
};
var Ui = class Ui2 extends x {
  constructor() {
    super(...arguments), this.columns = [], this.hiddenColumns = [], this.data = {}, this.isHeader = false, this.table = this.closest("bim-table"), this.onTableColumnsChange = () => {
      this.table && (this.columns = this.table.columns);
    }, this.onTableColumnsHidden = () => {
      this.table && (this.hiddenColumns = this.table.hiddenColumns);
    }, this._observer = new IntersectionObserver(
      (t) => {
        this._intersecting = t[0].isIntersecting;
      },
      { rootMargin: "36px" }
    );
  }
  get _columnNames() {
    return this.columns.filter(
      (s) => !this.hiddenColumns.includes(s.name)
    ).map((s) => s.name);
  }
  get _columnWidths() {
    return this.columns.filter(
      (s) => !this.hiddenColumns.includes(s.name)
    ).map((s) => s.width);
  }
  connectedCallback() {
    super.connectedCallback(), this._observer.observe(this), this.table && (this.columns = this.table.columns, this.hiddenColumns = this.table.hiddenColumns, this.table.addEventListener("columnschange", this.onTableColumnsChange), this.table.addEventListener("columnshidden", this.onTableColumnsHidden));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._observer.unobserve(this), this.table && (this.columns = [], this.hiddenColumns = [], this.table.removeEventListener("columnschange", this.onTableColumnsChange), this.table.removeEventListener("columnshidden", this.onTableColumnsHidden));
  }
  compute() {
    var n, r, o;
    const t = ((n = this.table) == null ? void 0 : n.getRowIndentation(this.data)) ?? 0, e = this.isHeader ? this.data : ((r = this.table) == null ? void 0 : r.computeRowDeclaration(this.data)) ?? this.data, s = [];
    for (const a in e) {
      if (this.hiddenColumns.includes(a))
        continue;
      const l = e[a];
      let c;
      if (typeof l == "string" || typeof l == "boolean" || typeof l == "number" ? (c = document.createElement("bim-label"), c.textContent = String(l)) : l instanceof HTMLElement ? c = l : (c = document.createDocumentFragment(), jt(l, c)), !c)
        continue;
      const u = document.createElement("bim-table-cell");
      u.append(c), u.column = a, this._columnNames.indexOf(a) === 0 && !this.isHeader && (u.style.marginLeft = `${t + 0.125}rem`);
      const h = this._columnNames.indexOf(a);
      u.setAttribute("data-column-index", String(h)), u.toggleAttribute("data-cell-header", this.isHeader), u.rowData = this.data, (o = this.table) == null || o.dispatchEvent(
        new CustomEvent("cellcreated", {
          detail: { cell: u }
        })
      ), s.push(u);
    }
    return this.style.gridTemplateAreas = `"${this._columnNames.join(" ")}"`, this.style.gridTemplateColumns = `${this._columnWidths.join(" ")}`, m`
      ${s}
      <slot></slot>
    `;
  }
  render() {
    return m`${this._intersecting ? this.compute() : m``}`;
  }
};
Ui.styles = C`
    :host {
      position: relative;
      grid-area: Data;
      display: grid;
      min-height: 2.25rem;
    }

    ::slotted(.branch.branch-vertical) {
      top: 50%;
      bottom: 0;
    }
  `;
var dt = Ui;
ge([
  d({ attribute: false })
], dt.prototype, "columns");
ge([
  d({ attribute: false })
], dt.prototype, "hiddenColumns");
ge([
  d({ attribute: false })
], dt.prototype, "data");
ge([
  d({ type: Boolean, attribute: "is-header", reflect: true })
], dt.prototype, "isHeader");
ge([
  ce()
], dt.prototype, "_intersecting");
var xl = Object.defineProperty;
var $l = Object.getOwnPropertyDescriptor;
var Ft = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? $l(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && xl(t, e, n), n;
};
var qi = class qi2 extends x {
  constructor() {
    super(...arguments), this._columnsChange = new Event("columnschange"), this._filteredData = [], this.headersHidden = false, this.minColWidth = "4rem", this._columns = [], this._textDelimiters = {
      comma: ",",
      tab: "	"
    }, this._queryString = null, this._data = [], this.expanded = false, this.preserveStructureOnFilter = false, this.indentationInText = false, this.dataTransform = {}, this._onColumnsHidden = new Event("columnshidden"), this._hiddenColumns = [], this._stringFilterFunction = (t, e) => Object.values(e.data).some((n) => String(n).toLowerCase().includes(t.toLowerCase())), this._queryFilterFunction = (t, e) => {
      let s = false;
      const n = fi(t) ?? [];
      for (const r of n) {
        if ("queries" in r) {
          s = false;
          break;
        }
        const { condition: o, value: a } = r;
        let { key: l } = r;
        if (l.startsWith("[") && l.endsWith("]")) {
          const c = l.replace("[", "").replace("]", "");
          l = c, s = Object.keys(e.data).filter((f) => f.includes(c)).map(
            (f) => zn(e.data[f], o, a)
          ).some((f) => f);
        } else
          s = zn(e.data[l], o, a);
        if (!s)
          break;
      }
      return s;
    };
  }
  set columns(t) {
    const e = [];
    for (const s of t) {
      const n = typeof s == "string" ? { name: s, width: `minmax(${this.minColWidth}, 1fr)` } : s;
      e.push(n);
    }
    this._columns = e, this.computeMissingColumns(this.data), this.dispatchEvent(this._columnsChange);
  }
  get columns() {
    return this._columns;
  }
  get _headerRowData() {
    const t = {};
    for (const e of this.columns)
      if (typeof e == "string")
        t[e] = e;
      else {
        const { name: s } = e;
        t[s] = s;
      }
    return t;
  }
  /**
   * Getter for the `value` property.
   * Returns the filtered data if a search string is provided, otherwise returns the original data.
   *
   * @example
   * ```typescript
   * const tableValue = table.value;
   * console.log(tableValue); // Output: The filtered or original data.
   * ```
   */
  get value() {
    return this._filteredData;
  }
  /**
   * Sets the search string for filtering the table data.
   * This property allows you to filter the table data based on a search string.
   * If a search string is provided, the table will only display rows that match the search criteria.
   * The search criteria can be a simple string or a complex query.
   * If a simple string is provided, the table will filter rows based on the string's presence in any column.
   * If a complex query is provided, the table will filter rows based on the query's conditions and values.
   *
   * @example
   * ```typescript
   * table.queryString = "example";
   * ```
   *
   * @example
   * ```typescript
   * table.queryString = "column1="Jhon Doe" & column2=20";
   * ```
   */
  set queryString(t) {
    this._queryString = t && t.trim() !== "" ? t.trim() : null, this.updateFilteredData();
  }
  get queryString() {
    return this._queryString;
  }
  set data(t) {
    this._data = t, this.updateFilteredData(), this.computeMissingColumns(t) && (this.columns = this._columns);
  }
  get data() {
    return this._data;
  }
  get dataAsync() {
    return new Promise((t) => {
      setTimeout(() => {
        t(this.data);
      });
    });
  }
  set hiddenColumns(t) {
    this._hiddenColumns = t, setTimeout(() => {
      this.dispatchEvent(this._onColumnsHidden);
    });
  }
  get hiddenColumns() {
    return this._hiddenColumns;
  }
  updateFilteredData() {
    this.queryString ? (fi(this.queryString) ? (this.filterFunction = this._queryFilterFunction, this._filteredData = this.filter(this.queryString)) : (this.filterFunction = this._stringFilterFunction, this._filteredData = this.filter(this.queryString)), this.preserveStructureOnFilter && (this._expandedBeforeFilter === void 0 && (this._expandedBeforeFilter = this.expanded), this.expanded = true)) : (this.preserveStructureOnFilter && this._expandedBeforeFilter !== void 0 && (this.expanded = this._expandedBeforeFilter, this._expandedBeforeFilter = void 0), this._filteredData = this.data);
  }
  computeMissingColumns(t) {
    let e = false;
    for (const s of t) {
      const { children: n, data: r } = s;
      for (const o in r)
        this._columns.map((l) => typeof l == "string" ? l : l.name).includes(o) || (this._columns.push({
          name: o,
          width: `minmax(${this.minColWidth}, 1fr)`
        }), e = true);
      if (n) {
        const o = this.computeMissingColumns(n);
        o && !e && (e = o);
      }
    }
    return e;
  }
  generateText(t = "comma", e = this.value, s = "", n = true) {
    const r = this._textDelimiters[t];
    let o = "";
    const a = this.columns.map((l) => l.name);
    if (n) {
      this.indentationInText && (o += `Indentation${r}`);
      const l = `${a.join(r)}
`;
      o += l;
    }
    for (const [l, c] of e.entries()) {
      const { data: u, children: h } = c, f = this.indentationInText ? `${s}${l + 1}${r}` : "", p = a.map((v) => u[v] ?? ""), b = `${f}${p.join(r)}
`;
      o += b, h && (o += this.generateText(
        t,
        c.children,
        `${s}${l + 1}.`,
        false
      ));
    }
    return o;
  }
  /**
   * A getter function that generates a CSV (Comma Separated Values) representation of the table data.
   *
   * @returns A string containing the CSV representation of the table data.
   *
   * @example
   * ```typescript
   * const csvData = table.csv;
   * console.log(csvData); // Output: "Column 1,Column 2\nValue 1,Value 2\nValue 3,Value 4"
   * ```
   */
  get csv() {
    return this.generateText("comma");
  }
  /**
   * A getter function that generates a Tab Separated Values (TSV) representation of the table data.
   *
   * @returns A string containing the TSV representation of the table data.
   *
   * @example
   * ```typescript
   * const tsvData = table.tsv;
   * console.log(tsvData); // Output: "Column 1\tColumn 2\nValue 1\tValue 2\nValue 3\tValue 4"
   * ```
   */
  get tsv() {
    return this.generateText("tab");
  }
  computeRowDeclaration(t) {
    const e = {};
    for (const s in t) {
      const n = this.dataTransform[s];
      n ? e[s] = n(t[s], t) : e[s] = t[s];
    }
    return e;
  }
  /**
   * The `downloadData` method is used to download the table data in different formats.
   *
   * @param fileName - The name of the downloaded file. Default is "BIM Table Data".
   * @param format - The format of the downloaded file. Can be "json", "tsv", or "csv". Default is "json".
   *
   * @returns - This method does not return any value.
   *
   * @example
   * ```typescript
   * table.downloadData("MyTableData", "tsv");
   * ```
   */
  downloadData(t = "BIM Table Data", e = "json") {
    let s = null;
    if (e === "json" && (s = new File(
      [JSON.stringify(this.value, void 0, 2)],
      `${t}.json`
    )), e === "csv" && (s = new File([this.csv], `${t}.csv`)), e === "tsv" && (s = new File([this.tsv], `${t}.tsv`)), !s)
      return;
    const n = document.createElement("a");
    n.href = URL.createObjectURL(s), n.download = s.name, n.click(), URL.revokeObjectURL(n.href);
  }
  getRowIndentation(t, e = this.value, s = 0) {
    for (const n of e) {
      if (n.data === t)
        return s;
      if (n.children) {
        const r = this.getRowIndentation(
          t,
          n.children,
          s + 1
        );
        if (r !== null)
          return r;
      }
    }
    return null;
  }
  getGroupIndentation(t, e = this.value, s = 0) {
    for (const n of e) {
      if (n === t)
        return s;
      if (n.children) {
        const r = this.getGroupIndentation(
          t,
          n.children,
          s + 1
        );
        if (r !== null)
          return r;
      }
    }
    return null;
  }
  connectedCallback() {
    super.connectedCallback(), this.dispatchEvent(new Event("connected"));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.dispatchEvent(new Event("disconnected"));
  }
  filter(t, e = this.filterFunction ?? this._stringFilterFunction, s = this.data) {
    const n = [];
    for (const r of s)
      if (e(t, r)) {
        if (this.preserveStructureOnFilter) {
          const a = { data: r.data };
          if (r.children) {
            const l = this.filter(
              t,
              e,
              r.children
            );
            l.length && (a.children = l);
          }
          n.push(a);
        } else if (n.push({ data: r.data }), r.children) {
          const a = this.filter(
            t,
            e,
            r.children
          );
          n.push(...a);
        }
      } else if (r.children) {
        const a = this.filter(
          t,
          e,
          r.children
        );
        this.preserveStructureOnFilter && a.length ? n.push({
          data: r.data,
          children: a
        }) : n.push(...a);
      }
    return n;
  }
  render() {
    const t = document.createElement("bim-table-row");
    t.table = this, t.isHeader = true, t.data = this._headerRowData, t.style.gridArea = "Header", t.style.position = "sticky", t.style.top = "0", t.style.zIndex = "5";
    const e = document.createElement("bim-table-children");
    return e.table = this, e.data = this.value, e.style.gridArea = "Body", e.style.backgroundColor = "transparent", m`
      <div class="parent">
        ${this.headersHidden ? null : t}
        <div style="overflow-x: hidden; grid-area: Body">${e}</div>
      </div>
    `;
  }
};
qi.styles = [
  Et.scrollbar,
  C`
      :host {
        --bim-button--bgc: transparent;
        position: relative;
        overflow: auto;
        display: block;
        pointer-events: auto;
      }

      .parent {
        display: grid;
        grid-template:
          "Header" auto
          "Body" 1fr
          "Footer" auto;
        overflow: auto;
        height: 100%;
      }

      .parent > bim-table-row[is-header] {
        color: var(--bim-table_header--c, var(--bim-ui_bg-contrast-100));
        background-color: var(
          --bim-table_header--bgc,
          var(--bim-ui_bg-contrast-20)
        );
      }

      .controls {
        display: flex;
        gap: 0.375rem;
        flex-wrap: wrap;
        margin-bottom: 0.5rem;
      }
    `
];
var X = qi;
Ft([
  ce()
], X.prototype, "_filteredData", 2);
Ft([
  d({
    type: Boolean,
    attribute: "headers-hidden",
    reflect: true
  })
], X.prototype, "headersHidden", 2);
Ft([
  d({ type: String, attribute: "min-col-width", reflect: true })
], X.prototype, "minColWidth", 2);
Ft([
  d({ type: Array, attribute: false })
], X.prototype, "columns", 1);
Ft([
  d({ type: Array, attribute: false })
], X.prototype, "data", 1);
Ft([
  d({ type: Boolean, reflect: true })
], X.prototype, "expanded", 2);
var Cl = Object.defineProperty;
var El = Object.getOwnPropertyDescriptor;
var qe = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? El(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Cl(t, e, n), n;
};
var Wi = class Wi2 extends x {
  constructor() {
    super(...arguments), this._defaultName = "__unnamed__", this.name = this._defaultName, this._hidden = false;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  connectedCallback() {
    super.connectedCallback();
    const { parentElement: t } = this;
    if (t && this.name === this._defaultName) {
      const e = [...t.children].indexOf(this);
      this.name = `${this._defaultName}${e}`;
    }
  }
  render() {
    return m` <slot></slot> `;
  }
};
Wi.styles = C`
    :host {
      display: block;
      height: 100%;
    }

    :host([hidden]) {
      display: none;
    }
  `;
var I = Wi;
qe([
  d({ type: String, reflect: true })
], I.prototype, "name", 2);
qe([
  d({ type: String, reflect: true })
], I.prototype, "label", 2);
qe([
  d({ type: String, reflect: true })
], I.prototype, "icon", 2);
qe([
  d({ type: Boolean, reflect: true })
], I.prototype, "hidden", 1);
var Sl = Object.defineProperty;
var Al = Object.getOwnPropertyDescriptor;
var Vt = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Al(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Sl(t, e, n), n;
};
var Qi = class Qi2 extends x {
  constructor() {
    super(...arguments), this._switchers = [], this.bottom = false, this.switchersHidden = false, this.floating = false, this.switchersFull = false, this.onTabHiddenChange = (t) => {
      const e = t.target;
      e instanceof I && !e.hidden && (e.removeEventListener("hiddenchange", this.onTabHiddenChange), this.tab = e.name, e.addEventListener("hiddenchange", this.onTabHiddenChange));
    };
  }
  set tab(t) {
    this._tab = t;
    const e = [...this.children], s = e.find(
      (n) => n instanceof I && n.name === t
    );
    for (const n of e) {
      if (!(n instanceof I))
        continue;
      n.hidden = s !== n;
      const r = this.getTabSwitcher(n.name);
      r && r.toggleAttribute("data-active", !n.hidden);
    }
  }
  get tab() {
    return this._tab;
  }
  getTabSwitcher(t) {
    return this._switchers.find(
      (s) => s.getAttribute("data-name") === t
    );
  }
  createSwitchers() {
    this._switchers = [];
    for (const t of this.children) {
      if (!(t instanceof I))
        continue;
      const e = document.createElement("div");
      e.addEventListener("click", () => {
        this.tab === t.name ? this.toggleAttribute("tab", false) : this.tab = t.name;
      }), e.setAttribute("data-name", t.name), e.className = "switcher";
      const s = document.createElement("bim-label");
      s.textContent = t.label ?? "", s.icon = t.icon, e.append(s), this._switchers.push(e);
    }
  }
  onSlotChange(t) {
    this.createSwitchers();
    const e = t.target.assignedElements(), s = e.find((n) => n instanceof I ? this.tab ? n.name === this.tab : !n.hidden : false);
    s && s instanceof I && (this.tab = s.name);
    for (const n of e) {
      if (!(n instanceof I)) {
        n.remove();
        continue;
      }
      n.removeEventListener("hiddenchange", this.onTabHiddenChange), s !== n && (n.hidden = true), n.addEventListener("hiddenchange", this.onTabHiddenChange);
    }
  }
  render() {
    return m`
      <div class="parent">
        <div class="switchers">${this._switchers}</div>
        <div class="content">
          <slot @slotchange=${this.onSlotChange}></slot>
        </div>
      </div>
    `;
  }
};
Qi.styles = [
  Et.scrollbar,
  C`
      * {
        box-sizing: border-box;
      }

      :host {
        background-color: var(--bim-ui_bg-base);
        display: block;
        overflow: auto;
      }

      .parent {
        display: grid;
        grid-template: "switchers" auto "content" 1fr;
        height: 100%;
      }

      :host([bottom]) .parent {
        grid-template: "content" 1fr "switchers" auto;
      }

      .switchers {
        display: flex;
        height: 2.25rem;
        font-weight: 600;
        grid-area: switchers;
      }

      .switcher {
        --bim-label--c: var(--bim-ui_bg-contrast-80);
        background-color: var(--bim-ui_bg-base);
        cursor: pointer;
        pointer-events: auto;
        padding: 0rem 0.75rem;
        display: flex;
        justify-content: center;
        transition: all 0.15s;
      }

      :host([switchers-full]) .switcher {
        flex: 1;
      }

      .switcher:hover,
      .switcher[data-active] {
        --bim-label--c: var(--bim-ui_main-contrast);
        background-color: var(--bim-ui_main-base);
      }

      .switchers bim-label {
        pointer-events: none;
      }

      :host([switchers-hidden]) .switchers {
        display: none;
      }

      .content {
        grid-area: content;
        overflow: auto;
      }

      :host(:not([bottom])) .content {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([bottom]) .content {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host(:not([tab])) .content {
        display: none;
      }

      :host([floating]) {
        background-color: transparent;
      }

      :host([floating]) .switchers {
        justify-self: center;
        overflow: auto;
      }

      :host([floating]:not([bottom])) .switchers {
        border-radius: var(--bim-ui_size-2xs) var(--bim-ui_size-2xs) 0 0;
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom]) .switchers {
        border-radius: 0 0 var(--bim-ui_size-2xs) var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]:not([tab])) .switchers {
        border-radius: var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom]:not([tab])) .switchers {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]) .content {
        border: 1px solid var(--bim-ui_bg-contrast-20);
        border-radius: var(--bim-ui_size-2xs);
        background-color: var(--bim-ui_bg-base);
      }
    `
];
var J = Qi;
Vt([
  ce()
], J.prototype, "_switchers", 2);
Vt([
  d({ type: Boolean, reflect: true })
], J.prototype, "bottom", 2);
Vt([
  d({ type: Boolean, attribute: "switchers-hidden", reflect: true })
], J.prototype, "switchersHidden", 2);
Vt([
  d({ type: Boolean, reflect: true })
], J.prototype, "floating", 2);
Vt([
  d({ type: String, reflect: true })
], J.prototype, "tab", 1);
Vt([
  d({ type: Boolean, attribute: "switchers-full", reflect: true })
], J.prototype, "switchersFull", 2);
var Ol = (i) => i ?? k;
var kl = Object.defineProperty;
var Pl = Object.getOwnPropertyDescriptor;
var gt = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Pl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && kl(t, e, n), n;
};
var Yi = class Yi2 extends x {
  constructor() {
    super(...arguments), this._inputTypes = [
      "date",
      "datetime-local",
      "email",
      "month",
      "password",
      "search",
      "tel",
      "text",
      "time",
      "url",
      "week"
    ], this.value = "", this.vertical = false, this._type = "text", this.onValueChange = new Event("input");
  }
  set type(t) {
    this._inputTypes.includes(t) && (this._type = t);
  }
  get type() {
    return this._type;
  }
  /**
   * Gets the query value derived from the current input value.
   * The `getQuery` function is assumed to be a utility function that takes a string as input
   * and returns a processed query value based on the input.
   *
   * @returns The processed query value derived from the current input value.
   *
   * @example
   * ```typescript
   * const textInput = new TextInput();
   * textInput.value = "Key?Value";
   * console.log(textInput.query);
   * ```
   */
  get query() {
    return fi(this.value);
  }
  onInputChange(t) {
    t.stopPropagation();
    const e = t.target;
    clearTimeout(this._debounceTimeoutID), this._debounceTimeoutID = setTimeout(() => {
      this.value = e.value, this.dispatchEvent(this.onValueChange);
    }, this.debounce);
  }
  focus() {
    setTimeout(() => {
      var e;
      const t = (e = this.shadowRoot) == null ? void 0 : e.querySelector("input");
      t == null || t.focus();
    });
  }
  render() {
    return m`
      <bim-input
        .name=${this.name}
        .icon=${this.icon}
        .label=${this.label}
        .vertical=${this.vertical}
      >
        <input
          aria-label=${this.label || this.name || "Text Input"}
          .type=${this.type}
          .value=${this.value}
          placeholder=${Ol(this.placeholder)}
          @input=${this.onInputChange}
        />
      </bim-input>
    `;
  }
};
Yi.styles = C`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      flex: 1;
      display: block;
    }

    input {
      background-color: transparent;
      outline: none;
      border: none;
      width: 100%;
      height: 100%;
      padding: 0 var(--bim-ui_size-3xs);
      border-radius: var(--bim-text-input--bdrs, var(--bim-ui_size-4xs));
      color: var(--bim-text-input--c, var(--bim-ui_bg-contrast-100));
    }

    :host(:focus) {
      --bim-input--olc: var(--bim-ui_accent-base);
    }

    /* :host([disabled]) {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
    } */
  `;
var N = Yi;
gt([
  d({ type: String, reflect: true })
], N.prototype, "icon", 2);
gt([
  d({ type: String, reflect: true })
], N.prototype, "label", 2);
gt([
  d({ type: String, reflect: true })
], N.prototype, "name", 2);
gt([
  d({ type: String, reflect: true })
], N.prototype, "placeholder", 2);
gt([
  d({ type: String, reflect: true })
], N.prototype, "value", 2);
gt([
  d({ type: Boolean, reflect: true })
], N.prototype, "vertical", 2);
gt([
  d({ type: Number, reflect: true })
], N.prototype, "debounce", 2);
gt([
  d({ type: String, reflect: true })
], N.prototype, "type", 1);
var Tl = Object.defineProperty;
var Ll = Object.getOwnPropertyDescriptor;
var zs = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Ll(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Tl(t, e, n), n;
};
var Gi = class Gi2 extends x {
  constructor() {
    super(...arguments), this.rows = 2, this._vertical = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      this.vertical ? e.setAttribute("label-hidden", "") : e.removeAttribute("label-hidden");
  }
  render() {
    return m`
      <style>
        .parent {
          grid-auto-flow: ${this.vertical ? "row" : "column"};
          grid-template-rows: repeat(${this.rows}, 1fr);
        }
      </style>
      <div class="parent">
        <slot @slotchange=${this.updateChildren}></slot>
      </div>
    `;
  }
};
Gi.styles = C`
    .parent {
      display: grid;
      gap: 0.25rem;
    }

    ::slotted(bim-button[label]:not([vertical])) {
      --bim-button--jc: flex-start;
    }

    ::slotted(bim-button) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
    }
  `;
var Bt = Gi;
zs([
  d({ type: Number, reflect: true })
], Bt.prototype, "rows", 2);
zs([
  d({ type: Boolean, reflect: true })
], Bt.prototype, "vertical", 1);
var Il = Object.defineProperty;
var zl = Object.getOwnPropertyDescriptor;
var We = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? zl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Il(t, e, n), n;
};
var Xi = class Xi2 extends x {
  constructor() {
    super(...arguments), this._vertical = false, this._labelHidden = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  set labelHidden(t) {
    this._labelHidden = t, this.updateChildren();
  }
  get labelHidden() {
    return this._labelHidden;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      e instanceof Bt && (e.vertical = this.vertical), e.toggleAttribute("label-hidden", this.vertical);
  }
  render() {
    return m`
      <div class="parent">
        <div class="children">
          <slot @slotchange=${this.updateChildren}></slot>
        </div>
        ${!this.labelHidden && (this.label || this.icon) ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
      </div>
    `;
  }
};
Xi.styles = C`
    :host {
      --bim-label--fz: var(--bim-ui_size-xs);
      --bim-label--c: var(--bim-ui_bg-contrast-60);
      display: block;
      flex: 1;
    }

    :host(:not([vertical])) ::slotted(bim-button[vertical]) {
      --bim-icon--fz: var(--bim-ui_size-5xl);
      min-height: 3.75rem;
    }

    ::slotted(bim-button) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
    }

    .parent {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: center;
      padding: 0.5rem;
      height: 100%;
      box-sizing: border-box;
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: row-reverse;
    }

    :host([vertical]) .parent > bim-label {
      writing-mode: tb;
    }

    .children {
      display: flex;
      gap: 0.25rem;
    }

    :host([vertical]) .children {
      flex-direction: column;
    }
  `;
var ft = Xi;
We([
  d({ type: String, reflect: true })
], ft.prototype, "label", 2);
We([
  d({ type: String, reflect: true })
], ft.prototype, "icon", 2);
We([
  d({ type: Boolean, reflect: true })
], ft.prototype, "vertical", 1);
We([
  d({ type: Boolean, attribute: "label-hidden", reflect: true })
], ft.prototype, "labelHidden", 1);
var y = class y2 {
  static set config(t) {
    this._config = { ...y2._config, ...t };
  }
  static get config() {
    return y2._config;
  }
  static addGlobalStyles() {
    let t = document.querySelector("style[id='bim-ui']");
    if (t)
      return;
    t = document.createElement("style"), t.id = "bim-ui", t.textContent = Et.globalStyles.cssText;
    const e = document.head.firstChild;
    e ? document.head.insertBefore(t, e) : document.head.append(t);
  }
  static defineCustomElement(t, e) {
    customElements.get(t) || customElements.define(t, e);
  }
  /**
   * @deprecated Use `Manager.init()` instead.
   */
  static registerComponents() {
    y2.init();
  }
  /**
   * Initializes the BIM UI library by defining custom elements.
   * It ensures that all necessary styles and custom elements are registered for use in BIM UI components.
   *
   * @example
   * ```typescript
   * import { Manager } from "@thatopen/ui";
   * Manager.init();
   * ```
   */
  static init() {
    y2.addGlobalStyles(), y2.defineCustomElement("bim-button", Wo), y2.defineCustomElement("bim-checkbox", lt), y2.defineCustomElement("bim-color-input", G), y2.defineCustomElement("bim-context-menu", Pe), y2.defineCustomElement("bim-dropdown", H), y2.defineCustomElement("bim-grid", re), y2.defineCustomElement("bim-icon", pi), y2.defineCustomElement("bim-input", Ct), y2.defineCustomElement("bim-label", at), y2.defineCustomElement("bim-number-input", L), y2.defineCustomElement("bim-option", P), y2.defineCustomElement("bim-panel", ct), y2.defineCustomElement("bim-panel-section", ut), y2.defineCustomElement("bim-selector", ht), y2.defineCustomElement("bim-table", X), y2.defineCustomElement("bim-tabs", J), y2.defineCustomElement("bim-tab", I), y2.defineCustomElement("bim-table-cell", Le), y2.defineCustomElement("bim-table-children", Ie), y2.defineCustomElement("bim-table-group", ze), y2.defineCustomElement("bim-table-row", dt), y2.defineCustomElement("bim-text-input", N), y2.defineCustomElement("bim-toolbar", Ht), y2.defineCustomElement("bim-toolbar-group", Bt), y2.defineCustomElement(
      "bim-toolbar-section",
      ft
    ), y2.defineCustomElement("bim-viewport", Re);
  }
  static newRandomId() {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let e = "";
    for (let s = 0; s < 10; s++) {
      const n = Math.floor(Math.random() * t.length);
      e += t.charAt(n);
    }
    return e;
  }
};
y._config = {
  sectionLabelOnVerticalToolbar: false
  // draggableToolbars: true,
  // draggablePanels: true,
};
var mi = y;
var Rl = Object.defineProperty;
var Ml = Object.getOwnPropertyDescriptor;
var Oi = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Ml(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Rl(t, e, n), n;
};
var Ji = class Ji2 extends x {
  constructor() {
    super(...arguments), this.labelsHidden = false, this._vertical = false, this._hidden = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateSections();
  }
  get vertical() {
    return this._vertical;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  // private setActivationButton() {
  //   this.activationButton.draggable = Manager.config.draggableToolbars;
  //   this.activationButton.addEventListener(
  //     "click",
  //     () => (this.hidden = !this.hidden),
  //   );
  //   this.activationButton.setAttribute("data-ui-manager-id", this._managerID);
  //   this.activationButton.addEventListener("dragstart", (e) => {
  //     const id = this.getAttribute("data-ui-manager-id");
  //     if (e.dataTransfer && id) {
  //       e.dataTransfer.setData("id", id);
  //       e.dataTransfer.effectAllowed = "move";
  //     }
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       if (container === this.parentElement) continue;
  //       container.dropping = true;
  //     }
  //   });
  //   this.activationButton.addEventListener("dragend", (e) => {
  //     if (e.dataTransfer) e.dataTransfer.clearData();
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       container.dropping = false;
  //     }
  //   });
  // }
  updateSections() {
    const t = this.children;
    for (const e of t)
      e instanceof ft && (e.labelHidden = this.vertical && !mi.config.sectionLabelOnVerticalToolbar, e.vertical = this.vertical);
  }
  // firstUpdated() {
  //   this.setAttribute("data-ui-manager-id", this._managerID);
  // }
  render() {
    return m`
      <div class="parent">
        <slot @slotchange=${this.updateSections}></slot>
      </div>
    `;
  }
};
Ji.styles = C`
    :host {
      --bim-button--bgc: transparent;
      background-color: var(--bim-ui_bg-base);
      border-radius: var(--bim-ui_size-2xs);
      display: block;
    }

    :host([hidden]) {
      display: none;
    }

    .parent {
      display: flex;
      width: min-content;
      pointer-events: auto;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    :host([vertical]) {
      width: min-content;
      border-radius: var(--bim-ui_size-2xs);
      border: 1px solid var(--bim-ui_bg-contrast-20);
    }

    ::slotted(bim-toolbar-section:not(:last-child)) {
      border-right: 1px solid var(--bim-ui_bg-contrast-20);
      border-bottom: none;
    }

    :host([vertical]) ::slotted(bim-toolbar-section:not(:last-child)) {
      border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      border-right: none;
    }
  `;
var Ht = Ji;
Oi([
  d({ type: String, reflect: true })
], Ht.prototype, "icon", 2);
Oi([
  d({ type: Boolean, attribute: "labels-hidden", reflect: true })
], Ht.prototype, "labelsHidden", 2);
Oi([
  d({ type: Boolean, reflect: true })
], Ht.prototype, "vertical", 1);
var jl = Object.defineProperty;
var Bl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && jl(t, e, n), n;
};
var Ki = class Ki2 extends x {
  constructor() {
    super(), this._onResize = new Event("resize"), new ResizeObserver(() => {
      setTimeout(() => {
        this.dispatchEvent(this._onResize);
      });
    }).observe(this);
  }
  render() {
    return m`
      <div class="parent">
        <slot></slot>
      </div>
    `;
  }
};
Ki.styles = C`
    :host {
      display: grid;
      min-width: 0;
      min-height: 0;
      height: 100%;
    }

    .parent {
      overflow: hidden;
      position: relative;
    }
  `;
var Re = Ki;
Bl([
  d({ type: String, reflect: true })
], Re.prototype, "name");
var Rs = "important";
var Hl = " !" + Rs;
var Ul = as(class extends cs {
  constructor(i) {
    var t;
    if (super(i), i.type !== ls.ATTRIBUTE || i.name !== "style" || ((t = i.strings) == null ? void 0 : t.length) > 2)
      throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(i) {
    return Object.keys(i).reduce((t, e) => {
      const s = i[e];
      return s == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s};`;
    }, "");
  }
  update(i, [t]) {
    const { style: e } = i.element;
    if (this.ft === void 0)
      return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const s of this.ft)
      t[s] == null && (this.ft.delete(s), s.includes("-") ? e.removeProperty(s) : e[s] = null);
    for (const s in t) {
      const n = t[s];
      if (n != null) {
        this.ft.add(s);
        const r = typeof n == "string" && n.endsWith(Hl);
        s.includes("-") || r ? e.setProperty(s, r ? n.slice(0, -11) : n, r ? Rs : "") : e[s] = n;
      }
    }
    return $t;
  }
});
export {
  Wo as Button,
  lt as Checkbox,
  G as ColorInput,
  tl as Component,
  Pe as ContextMenu,
  H as Dropdown,
  re as Grid,
  pi as Icon,
  Ct as Input,
  at as Label,
  mi as Manager,
  L as NumberInput,
  P as Option,
  ct as Panel,
  ut as PanelSection,
  ht as Selector,
  I as Tab,
  X as Table,
  Le as TableCell,
  Ie as TableChildren,
  ze as TableGroup,
  dt as TableRow,
  J as Tabs,
  N as TextInput,
  Ht as Toolbar,
  Bt as ToolbarGroup,
  ft as ToolbarSection,
  Re as Viewport,
  m as html,
  Lt as ref,
  Ul as styleMap
};
/*! Bundled license information:

@thatopen/ui/dist/index.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
  * (c) Iconify
  *
  * For the full copyright and license information, please view the license.txt
  * files at https://github.com/iconify/iconify
  *
  * Licensed under MIT.
  *
  * @license MIT
  * @version 2.0.0
  *)
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@thatopen_ui.js.map
