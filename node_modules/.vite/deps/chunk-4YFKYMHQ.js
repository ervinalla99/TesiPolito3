import {
  Ee,
  FILE_DESCRIPTION,
  FILE_NAME,
  Handle,
  IFCBRIDGE,
  IFCBUILDING,
  IFCBUILDINGSTOREY,
  IFCELEMENTQUANTITY,
  IFCFACILITY,
  IFCFACILITYPART,
  IFCOPENINGELEMENT,
  IFCOWNERHISTORY,
  IFCPROJECT,
  IFCPROPERTYSET,
  IFCRELAGGREGATES,
  IFCRELASSIGNSTOGROUP,
  IFCRELASSOCIATESCLASSIFICATION,
  IFCRELASSOCIATESMATERIAL,
  IFCRELCONTAINEDINSPATIALSTRUCTURE,
  IFCRELDEFINESBYPROPERTIES,
  IFCRELDEFINESBYTEMPLATE,
  IFCRELDEFINESBYTYPE,
  IFCROAD,
  IFCSITE,
  IFCSPACE,
  IFCUNITASSIGNMENT,
  IfcAPI2,
  LogLevel,
  Ms,
  fn,
  ke,
  le,
  ln,
  qe,
  web_ifc_api_exports
} from "./chunk-HIYPURBP.js";
import {
  AmbientLight,
  BackSide,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Clock,
  Color,
  ColorManagement,
  CylinderGeometry,
  DirectionalLight,
  DoubleSide,
  EdgesGeometry,
  Euler,
  Float32BufferAttribute,
  FrontSide,
  InstancedMesh,
  Line,
  Line3,
  LineBasicMaterial,
  MOUSE,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshLambertMaterial,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  Quaternion,
  Ray,
  Raycaster,
  Scene,
  ShaderMaterial,
  Sphere,
  SphereGeometry,
  Spherical,
  TorusGeometry,
  Triangle,
  Vector2,
  Vector3,
  Vector4,
  WebGLRenderTarget,
  WebGLRenderer
} from "./chunk-D5NTCM2J.js";

// node_modules/@thatopen/components/dist/index.mjs
var kn = Object.defineProperty;
var Xn = (l, s, t) => s in l ? kn(l, s, { enumerable: true, configurable: true, writable: true, value: t }) : l[s] = t;
var I = (l, s, t) => (Xn(l, typeof s != "symbol" ? s + "" : s, t), t);
var Mn = 0;
var so = 1;
var io = 2;
var xi = 2;
var Ys = 1.25;
var bi = 1;
var Cs = 6 * 4 + 4 + 4;
var Us = 65535;
var no = Math.pow(2, -24);
var Vs = Symbol("SKIP_GENERATION");
function oo(l) {
  return l.index ? l.index.count : l.attributes.position.count;
}
function Ce(l) {
  return oo(l) / 3;
}
function ro(l, s = ArrayBuffer) {
  return l > 65535 ? new Uint32Array(new s(4 * l)) : new Uint16Array(new s(2 * l));
}
function ao(l, s) {
  if (!l.index) {
    const t = l.attributes.position.count, e = s.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, i = ro(t, e);
    l.setIndex(new BufferAttribute(i, 1));
    for (let o = 0; o < t; o++)
      i[o] = o;
  }
}
function wn(l) {
  const s = Ce(l), t = l.drawRange, e = t.start / 3, i = (t.start + t.count) / 3, o = Math.max(0, e), n = Math.min(s, i) - o;
  return [{
    offset: Math.floor(o),
    count: Math.floor(n)
  }];
}
function Dn(l) {
  if (!l.groups || !l.groups.length)
    return wn(l);
  const s = [], t = /* @__PURE__ */ new Set(), e = l.drawRange, i = e.start / 3, o = (e.start + e.count) / 3;
  for (const r of l.groups) {
    const a = r.start / 3, c = (r.start + r.count) / 3;
    t.add(Math.max(i, a)), t.add(Math.min(o, c));
  }
  const n = Array.from(t.values()).sort((r, a) => r - a);
  for (let r = 0; r < n.length - 1; r++) {
    const a = n[r], c = n[r + 1];
    s.push({
      offset: Math.floor(a),
      count: Math.floor(c - a)
    });
  }
  return s;
}
function co(l) {
  if (l.groups.length === 0)
    return false;
  const s = Ce(l), t = Dn(l).sort((o, n) => o.offset - n.offset), e = t[t.length - 1];
  e.count = Math.min(s - e.offset, e.count);
  let i = 0;
  return t.forEach(({ count: o }) => i += o), s !== i;
}
function K(l, s, t) {
  return t.min.x = s[l], t.min.y = s[l + 1], t.min.z = s[l + 2], t.max.x = s[l + 3], t.max.y = s[l + 4], t.max.z = s[l + 5], t;
}
function lo(l) {
  l[0] = l[1] = l[2] = 1 / 0, l[3] = l[4] = l[5] = -1 / 0;
}
function vi(l) {
  let s = -1, t = -1 / 0;
  for (let e = 0; e < 3; e++) {
    const i = l[e + 3] - l[e];
    i > t && (t = i, s = e);
  }
  return s;
}
function Bi(l, s) {
  s.set(l);
}
function Yi(l, s, t) {
  let e, i;
  for (let o = 0; o < 3; o++) {
    const n = o + 3;
    e = l[o], i = s[o], t[o] = e < i ? e : i, e = l[n], i = s[n], t[n] = e > i ? e : i;
  }
}
function Qe(l, s, t) {
  for (let e = 0; e < 3; e++) {
    const i = s[l + 2 * e], o = s[l + 2 * e + 1], n = i - o, r = i + o;
    n < t[e] && (t[e] = n), r > t[e + 3] && (t[e + 3] = r);
  }
}
function Ae(l) {
  const s = l[3] - l[0], t = l[4] - l[1], e = l[5] - l[2];
  return 2 * (s * t + t * e + e * s);
}
function Gs(l, s, t, e, i = null) {
  let o = 1 / 0, n = 1 / 0, r = 1 / 0, a = -1 / 0, c = -1 / 0, h = -1 / 0, d = 1 / 0, E = 1 / 0, u = 1 / 0, f = -1 / 0, T = -1 / 0, R = -1 / 0;
  const C = i !== null;
  for (let A = s * 6, F = (s + t) * 6; A < F; A += 6) {
    const p = l[A + 0], m = l[A + 1], g = p - m, S = p + m;
    g < o && (o = g), S > a && (a = S), C && p < d && (d = p), C && p > f && (f = p);
    const _ = l[A + 2], N = l[A + 3], y = _ - N, w = _ + N;
    y < n && (n = y), w > c && (c = w), C && _ < E && (E = _), C && _ > T && (T = _);
    const L = l[A + 4], U = l[A + 5], b = L - U, B = L + U;
    b < r && (r = b), B > h && (h = B), C && L < u && (u = L), C && L > R && (R = L);
  }
  e[0] = o, e[1] = n, e[2] = r, e[3] = a, e[4] = c, e[5] = h, C && (i[0] = d, i[1] = E, i[2] = u, i[3] = f, i[4] = T, i[5] = R);
}
function ho(l, s, t, e) {
  let i = 1 / 0, o = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, c = -1 / 0;
  for (let h = s * 6, d = (s + t) * 6; h < d; h += 6) {
    const E = l[h + 0];
    E < i && (i = E), E > r && (r = E);
    const u = l[h + 2];
    u < o && (o = u), u > a && (a = u);
    const f = l[h + 4];
    f < n && (n = f), f > c && (c = f);
  }
  e[0] = i, e[1] = o, e[2] = n, e[3] = r, e[4] = a, e[5] = c;
}
function Eo(l, s) {
  lo(s);
  const t = l.attributes.position, e = l.index ? l.index.array : null, i = Ce(l), o = new Float32Array(i * 6), n = t.normalized, r = t.array, a = t.offset || 0;
  let c = 3;
  t.isInterleavedBufferAttribute && (c = t.data.stride);
  const h = ["getX", "getY", "getZ"];
  for (let d = 0; d < i; d++) {
    const E = d * 3, u = d * 6;
    let f = E + 0, T = E + 1, R = E + 2;
    e && (f = e[f], T = e[T], R = e[R]), n || (f = f * c + a, T = T * c + a, R = R * c + a);
    for (let C = 0; C < 3; C++) {
      let A, F, p;
      n ? (A = t[h[C]](f), F = t[h[C]](T), p = t[h[C]](R)) : (A = r[f + C], F = r[T + C], p = r[R + C]);
      let m = A;
      F < m && (m = F), p < m && (m = p);
      let g = A;
      F > g && (g = F), p > g && (g = p);
      const S = (g - m) / 2, _ = C * 2;
      o[u + _ + 0] = m + S, o[u + _ + 1] = S + (Math.abs(m) + S) * no, m < s[C] && (s[C] = m), g > s[C + 3] && (s[C + 3] = g);
    }
  }
  return o;
}
var Mt = 32;
var uo = (l, s) => l.candidate - s.candidate;
var Ut = new Array(Mt).fill().map(() => ({
  count: 0,
  bounds: new Float32Array(6),
  rightCacheBounds: new Float32Array(6),
  leftCacheBounds: new Float32Array(6),
  candidate: 0
}));
var je = new Float32Array(6);
function Io(l, s, t, e, i, o) {
  let n = -1, r = 0;
  if (o === Mn)
    n = vi(s), n !== -1 && (r = (s[n] + s[n + 3]) / 2);
  else if (o === so)
    n = vi(l), n !== -1 && (r = fo(t, e, i, n));
  else if (o === io) {
    const a = Ae(l);
    let c = Ys * i;
    const h = e * 6, d = (e + i) * 6;
    for (let E = 0; E < 3; E++) {
      const u = s[E], R = (s[E + 3] - u) / Mt;
      if (i < Mt / 4) {
        const C = [...Ut];
        C.length = i;
        let A = 0;
        for (let p = h; p < d; p += 6, A++) {
          const m = C[A];
          m.candidate = t[p + 2 * E], m.count = 0;
          const {
            bounds: g,
            leftCacheBounds: S,
            rightCacheBounds: _
          } = m;
          for (let N = 0; N < 3; N++)
            _[N] = 1 / 0, _[N + 3] = -1 / 0, S[N] = 1 / 0, S[N + 3] = -1 / 0, g[N] = 1 / 0, g[N + 3] = -1 / 0;
          Qe(p, t, g);
        }
        C.sort(uo);
        let F = i;
        for (let p = 0; p < F; p++) {
          const m = C[p];
          for (; p + 1 < F && C[p + 1].candidate === m.candidate; )
            C.splice(p + 1, 1), F--;
        }
        for (let p = h; p < d; p += 6) {
          const m = t[p + 2 * E];
          for (let g = 0; g < F; g++) {
            const S = C[g];
            m >= S.candidate ? Qe(p, t, S.rightCacheBounds) : (Qe(p, t, S.leftCacheBounds), S.count++);
          }
        }
        for (let p = 0; p < F; p++) {
          const m = C[p], g = m.count, S = i - m.count, _ = m.leftCacheBounds, N = m.rightCacheBounds;
          let y = 0;
          g !== 0 && (y = Ae(_) / a);
          let w = 0;
          S !== 0 && (w = Ae(N) / a);
          const L = bi + Ys * (y * g + w * S);
          L < c && (n = E, c = L, r = m.candidate);
        }
      } else {
        for (let F = 0; F < Mt; F++) {
          const p = Ut[F];
          p.count = 0, p.candidate = u + R + F * R;
          const m = p.bounds;
          for (let g = 0; g < 3; g++)
            m[g] = 1 / 0, m[g + 3] = -1 / 0;
        }
        for (let F = h; F < d; F += 6) {
          let g = ~~((t[F + 2 * E] - u) / R);
          g >= Mt && (g = Mt - 1);
          const S = Ut[g];
          S.count++, Qe(F, t, S.bounds);
        }
        const C = Ut[Mt - 1];
        Bi(C.bounds, C.rightCacheBounds);
        for (let F = Mt - 2; F >= 0; F--) {
          const p = Ut[F], m = Ut[F + 1];
          Yi(p.bounds, m.rightCacheBounds, p.rightCacheBounds);
        }
        let A = 0;
        for (let F = 0; F < Mt - 1; F++) {
          const p = Ut[F], m = p.count, g = p.bounds, _ = Ut[F + 1].rightCacheBounds;
          m !== 0 && (A === 0 ? Bi(g, je) : Yi(g, je, je)), A += m;
          let N = 0, y = 0;
          A !== 0 && (N = Ae(je) / a);
          const w = i - A;
          w !== 0 && (y = Ae(_) / a);
          const L = bi + Ys * (N * A + y * w);
          L < c && (n = E, c = L, r = p.candidate);
        }
      }
    }
  } else
    console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);
  return { axis: n, pos: r };
}
function fo(l, s, t, e) {
  let i = 0;
  for (let o = s, n = s + t; o < n; o++)
    i += l[o * 6 + e * 2];
  return i / t;
}
var qe2 = class {
  constructor() {
  }
};
function po(l, s, t, e, i, o) {
  let n = e, r = e + i - 1;
  const a = o.pos, c = o.axis * 2;
  for (; ; ) {
    for (; n <= r && t[n * 6 + c] < a; )
      n++;
    for (; n <= r && t[r * 6 + c] >= a; )
      r--;
    if (n < r) {
      for (let h = 0; h < 3; h++) {
        let d = s[n * 3 + h];
        s[n * 3 + h] = s[r * 3 + h], s[r * 3 + h] = d;
      }
      for (let h = 0; h < 6; h++) {
        let d = t[n * 6 + h];
        t[n * 6 + h] = t[r * 6 + h], t[r * 6 + h] = d;
      }
      n++, r--;
    } else
      return n;
  }
}
function Co(l, s, t, e, i, o) {
  let n = e, r = e + i - 1;
  const a = o.pos, c = o.axis * 2;
  for (; ; ) {
    for (; n <= r && t[n * 6 + c] < a; )
      n++;
    for (; n <= r && t[r * 6 + c] >= a; )
      r--;
    if (n < r) {
      let h = l[n];
      l[n] = l[r], l[r] = h;
      for (let d = 0; d < 6; d++) {
        let E = t[n * 6 + d];
        t[n * 6 + d] = t[r * 6 + d], t[r * 6 + d] = E;
      }
      n++, r--;
    } else
      return n;
  }
}
function To(l, s) {
  const t = (l.index ? l.index.count : l.attributes.position.count) / 3, e = t > 2 ** 16, i = e ? 4 : 2, o = s ? new SharedArrayBuffer(t * i) : new ArrayBuffer(t * i), n = e ? new Uint32Array(o) : new Uint16Array(o);
  for (let r = 0, a = n.length; r < a; r++)
    n[r] = r;
  return n;
}
function mo(l, s) {
  const t = l.geometry, e = t.index ? t.index.array : null, i = s.maxDepth, o = s.verbose, n = s.maxLeafTris, r = s.strategy, a = s.onProgress, c = Ce(t), h = l._indirectBuffer;
  let d = false;
  const E = new Float32Array(6), u = new Float32Array(6), f = Eo(t, E), T = s.indirect ? Co : po, R = [], C = s.indirect ? wn(t) : Dn(t);
  if (C.length === 1) {
    const p = C[0], m = new qe2();
    m.boundingData = E, ho(f, p.offset, p.count, u), F(m, p.offset, p.count, u), R.push(m);
  } else
    for (let p of C) {
      const m = new qe2();
      m.boundingData = new Float32Array(6), Gs(f, p.offset, p.count, m.boundingData, u), F(m, p.offset, p.count, u), R.push(m);
    }
  return R;
  function A(p) {
    a && a(p / c);
  }
  function F(p, m, g, S = null, _ = 0) {
    if (!d && _ >= i && (d = true, o && (console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`), console.warn(t))), g <= n || _ >= i)
      return A(m + g), p.offset = m, p.count = g, p;
    const N = Io(p.boundingData, S, f, m, g, r);
    if (N.axis === -1)
      return A(m + g), p.offset = m, p.count = g, p;
    const y = T(h, e, f, m, g, N);
    if (y === m || y === m + g)
      A(m + g), p.offset = m, p.count = g;
    else {
      p.splitAxis = N.axis;
      const w = new qe2(), L = m, U = y - m;
      p.left = w, w.boundingData = new Float32Array(6), Gs(f, L, U, w.boundingData, u), F(w, L, U, u, _ + 1);
      const b = new qe2(), B = y, H = g - U;
      p.right = b, b.boundingData = new Float32Array(6), Gs(f, B, H, b.boundingData, u), F(b, B, H, u, _ + 1);
    }
    return p;
  }
}
function Ro(l, s) {
  const t = l.geometry;
  s.indirect && (l._indirectBuffer = To(t, s.useSharedArrayBuffer), co(t) && !s.verbose && console.warn(
    'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
  )), l._indirectBuffer || ao(t, s);
  const e = mo(l, s);
  let i, o, n;
  const r = [], a = s.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let d = 0; d < e.length; d++) {
    const E = e[d];
    let u = c(E);
    const f = new a(Cs * u);
    i = new Float32Array(f), o = new Uint32Array(f), n = new Uint16Array(f), h(0, E), r.push(f);
  }
  l._roots = r;
  return;
  function c(d) {
    return d.count ? 1 : 1 + c(d.left) + c(d.right);
  }
  function h(d, E) {
    const u = d / 4, f = d / 2, T = !!E.count, R = E.boundingData;
    for (let C = 0; C < 6; C++)
      i[u + C] = R[C];
    if (T) {
      const C = E.offset, A = E.count;
      return o[u + 6] = C, n[f + 14] = A, n[f + 15] = Us, d + Cs;
    } else {
      const C = E.left, A = E.right, F = E.splitAxis;
      let p;
      if (p = h(d + Cs, C), p / 4 > Math.pow(2, 32))
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      return o[u + 6] = p / 4, p = h(p, A), o[u + 7] = F, p;
    }
  }
}
var wt = class {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(s, t) {
    let e = 1 / 0, i = -1 / 0;
    for (let o = 0, n = s.length; o < n; o++) {
      const a = s[o][t];
      e = a < e ? a : e, i = a > i ? a : i;
    }
    this.min = e, this.max = i;
  }
  setFromPoints(s, t) {
    let e = 1 / 0, i = -1 / 0;
    for (let o = 0, n = t.length; o < n; o++) {
      const r = t[o], a = s.dot(r);
      e = a < e ? a : e, i = a > i ? a : i;
    }
    this.min = e, this.max = i;
  }
  isSeparated(s) {
    return this.min > s.max || s.min > this.max;
  }
};
wt.prototype.setFromBox = function() {
  const l = new Vector3();
  return function(t, e) {
    const i = e.min, o = e.max;
    let n = 1 / 0, r = -1 / 0;
    for (let a = 0; a <= 1; a++)
      for (let c = 0; c <= 1; c++)
        for (let h = 0; h <= 1; h++) {
          l.x = i.x * a + o.x * (1 - a), l.y = i.y * c + o.y * (1 - c), l.z = i.z * h + o.z * (1 - h);
          const d = t.dot(l);
          n = Math.min(d, n), r = Math.max(d, r);
        }
    this.min = n, this.max = r;
  };
}();
var Ao = function() {
  const l = new Vector3(), s = new Vector3(), t = new Vector3();
  return function(i, o, n) {
    const r = i.start, a = l, c = o.start, h = s;
    t.subVectors(r, c), l.subVectors(i.end, i.start), s.subVectors(o.end, o.start);
    const d = t.dot(h), E = h.dot(a), u = h.dot(h), f = t.dot(a), R = a.dot(a) * u - E * E;
    let C, A;
    R !== 0 ? C = (d * E - f * u) / R : C = 0, A = (d + C * E) / u, n.x = C, n.y = A;
  };
}();
var gi = function() {
  const l = new Vector2(), s = new Vector3(), t = new Vector3();
  return function(i, o, n, r) {
    Ao(i, o, l);
    let a = l.x, c = l.y;
    if (a >= 0 && a <= 1 && c >= 0 && c <= 1) {
      i.at(a, n), o.at(c, r);
      return;
    } else if (a >= 0 && a <= 1) {
      c < 0 ? o.at(0, r) : o.at(1, r), i.closestPointToPoint(r, true, n);
      return;
    } else if (c >= 0 && c <= 1) {
      a < 0 ? i.at(0, n) : i.at(1, n), o.closestPointToPoint(n, true, r);
      return;
    } else {
      let h;
      a < 0 ? h = i.start : h = i.end;
      let d;
      c < 0 ? d = o.start : d = o.end;
      const E = s, u = t;
      if (i.closestPointToPoint(d, true, s), o.closestPointToPoint(h, true, t), E.distanceToSquared(d) <= u.distanceToSquared(h)) {
        n.copy(E), r.copy(d);
        return;
      } else {
        n.copy(h), r.copy(u);
        return;
      }
    }
  };
}();
var Fo = function() {
  const l = new Vector3(), s = new Vector3(), t = new Plane(), e = new Line3();
  return function(o, n) {
    const { radius: r, center: a } = o, { a: c, b: h, c: d } = n;
    if (e.start = c, e.end = h, e.closestPointToPoint(a, true, l).distanceTo(a) <= r || (e.start = c, e.end = d, e.closestPointToPoint(a, true, l).distanceTo(a) <= r) || (e.start = h, e.end = d, e.closestPointToPoint(a, true, l).distanceTo(a) <= r))
      return true;
    const T = n.getPlane(t);
    if (Math.abs(T.distanceToPoint(a)) <= r) {
      const C = T.projectPoint(a, s);
      if (n.containsPoint(C))
        return true;
    }
    return false;
  };
}();
var go = 1e-15;
function zs(l) {
  return Math.abs(l) < go;
}
var Ft = class extends Triangle {
  constructor(...s) {
    super(...s), this.isExtendedTriangle = true, this.satAxes = new Array(4).fill().map(() => new Vector3()), this.satBounds = new Array(4).fill().map(() => new wt()), this.points = [this.a, this.b, this.c], this.sphere = new Sphere(), this.plane = new Plane(), this.needsUpdate = true;
  }
  intersectsSphere(s) {
    return Fo(s, this);
  }
  update() {
    const s = this.a, t = this.b, e = this.c, i = this.points, o = this.satAxes, n = this.satBounds, r = o[0], a = n[0];
    this.getNormal(r), a.setFromPoints(r, i);
    const c = o[1], h = n[1];
    c.subVectors(s, t), h.setFromPoints(c, i);
    const d = o[2], E = n[2];
    d.subVectors(t, e), E.setFromPoints(d, i);
    const u = o[3], f = n[3];
    u.subVectors(e, s), f.setFromPoints(u, i), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(r, s), this.needsUpdate = false;
  }
};
Ft.prototype.closestPointToSegment = function() {
  const l = new Vector3(), s = new Vector3(), t = new Line3();
  return function(i, o = null, n = null) {
    const { start: r, end: a } = i, c = this.points;
    let h, d = 1 / 0;
    for (let E = 0; E < 3; E++) {
      const u = (E + 1) % 3;
      t.start.copy(c[E]), t.end.copy(c[u]), gi(t, i, l, s), h = l.distanceToSquared(s), h < d && (d = h, o && o.copy(l), n && n.copy(s));
    }
    return this.closestPointToPoint(r, l), h = r.distanceToSquared(l), h < d && (d = h, o && o.copy(l), n && n.copy(r)), this.closestPointToPoint(a, l), h = a.distanceToSquared(l), h < d && (d = h, o && o.copy(l), n && n.copy(a)), Math.sqrt(d);
  };
}();
Ft.prototype.intersectsTriangle = function() {
  const l = new Ft(), s = new Array(3), t = new Array(3), e = new wt(), i = new wt(), o = new Vector3(), n = new Vector3(), r = new Vector3(), a = new Vector3(), c = new Vector3(), h = new Line3(), d = new Line3(), E = new Line3(), u = new Vector3();
  function f(T, R, C) {
    const A = T.points;
    let F = 0, p = -1;
    for (let m = 0; m < 3; m++) {
      const { start: g, end: S } = h;
      g.copy(A[m]), S.copy(A[(m + 1) % 3]), h.delta(n);
      const _ = zs(R.distanceToPoint(g));
      if (zs(R.normal.dot(n)) && _) {
        C.copy(h), F = 2;
        break;
      }
      const N = R.intersectLine(h, u);
      if (!N && _ && u.copy(g), (N || _) && !zs(u.distanceTo(S))) {
        if (F <= 1)
          (F === 1 ? C.start : C.end).copy(u), _ && (p = F);
        else if (F >= 2) {
          (p === 1 ? C.start : C.end).copy(u), F = 2;
          break;
        }
        if (F++, F === 2 && p === -1)
          break;
      }
    }
    return F;
  }
  return function(R, C = null, A = false) {
    this.needsUpdate && this.update(), R.isExtendedTriangle ? R.needsUpdate && R.update() : (l.copy(R), l.update(), R = l);
    const F = this.plane, p = R.plane;
    if (Math.abs(F.normal.dot(p.normal)) > 1 - 1e-10) {
      const m = this.satBounds, g = this.satAxes;
      t[0] = R.a, t[1] = R.b, t[2] = R.c;
      for (let N = 0; N < 4; N++) {
        const y = m[N], w = g[N];
        if (e.setFromPoints(w, t), y.isSeparated(e))
          return false;
      }
      const S = R.satBounds, _ = R.satAxes;
      s[0] = this.a, s[1] = this.b, s[2] = this.c;
      for (let N = 0; N < 4; N++) {
        const y = S[N], w = _[N];
        if (e.setFromPoints(w, s), y.isSeparated(e))
          return false;
      }
      for (let N = 0; N < 4; N++) {
        const y = g[N];
        for (let w = 0; w < 4; w++) {
          const L = _[w];
          if (o.crossVectors(y, L), e.setFromPoints(o, s), i.setFromPoints(o, t), e.isSeparated(i))
            return false;
        }
      }
      return C && (A || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), C.start.set(0, 0, 0), C.end.set(0, 0, 0)), true;
    } else {
      const m = f(this, p, d);
      if (m === 1 && R.containsPoint(d.end))
        return C && (C.start.copy(d.end), C.end.copy(d.end)), true;
      if (m !== 2)
        return false;
      const g = f(R, F, E);
      if (g === 1 && this.containsPoint(E.end))
        return C && (C.start.copy(E.end), C.end.copy(E.end)), true;
      if (g !== 2)
        return false;
      if (d.delta(r), E.delta(a), r.dot(a) < 0) {
        let U = E.start;
        E.start = E.end, E.end = U;
      }
      const S = d.start.dot(r), _ = d.end.dot(r), N = E.start.dot(r), y = E.end.dot(r), w = _ < N, L = S < y;
      return S !== y && N !== _ && w === L ? false : (C && (c.subVectors(d.start, E.start), c.dot(r) > 0 ? C.start.copy(d.start) : C.start.copy(E.start), c.subVectors(d.end, E.end), c.dot(r) < 0 ? C.end.copy(d.end) : C.end.copy(E.end)), true);
    }
  };
}();
Ft.prototype.distanceToPoint = function() {
  const l = new Vector3();
  return function(t) {
    return this.closestPointToPoint(t, l), t.distanceTo(l);
  };
}();
Ft.prototype.distanceToTriangle = function() {
  const l = new Vector3(), s = new Vector3(), t = ["a", "b", "c"], e = new Line3(), i = new Line3();
  return function(n, r = null, a = null) {
    const c = r || a ? e : null;
    if (this.intersectsTriangle(n, c))
      return (r || a) && (r && c.getCenter(r), a && c.getCenter(a)), 0;
    let h = 1 / 0;
    for (let d = 0; d < 3; d++) {
      let E;
      const u = t[d], f = n[u];
      this.closestPointToPoint(f, l), E = f.distanceToSquared(l), E < h && (h = E, r && r.copy(l), a && a.copy(f));
      const T = this[u];
      n.closestPointToPoint(T, l), E = T.distanceToSquared(l), E < h && (h = E, r && r.copy(T), a && a.copy(l));
    }
    for (let d = 0; d < 3; d++) {
      const E = t[d], u = t[(d + 1) % 3];
      e.set(this[E], this[u]);
      for (let f = 0; f < 3; f++) {
        const T = t[f], R = t[(f + 1) % 3];
        i.set(n[T], n[R]), gi(e, i, l, s);
        const C = l.distanceToSquared(s);
        C < h && (h = C, r && r.copy(l), a && a.copy(s));
      }
    }
    return Math.sqrt(h);
  };
}();
var at = class {
  constructor(s, t, e) {
    this.isOrientedBox = true, this.min = new Vector3(), this.max = new Vector3(), this.matrix = new Matrix4(), this.invMatrix = new Matrix4(), this.points = new Array(8).fill().map(() => new Vector3()), this.satAxes = new Array(3).fill().map(() => new Vector3()), this.satBounds = new Array(3).fill().map(() => new wt()), this.alignedSatBounds = new Array(3).fill().map(() => new wt()), this.needsUpdate = false, s && this.min.copy(s), t && this.max.copy(t), e && this.matrix.copy(e);
  }
  set(s, t, e) {
    this.min.copy(s), this.max.copy(t), this.matrix.copy(e), this.needsUpdate = true;
  }
  copy(s) {
    this.min.copy(s.min), this.max.copy(s.max), this.matrix.copy(s.matrix), this.needsUpdate = true;
  }
};
at.prototype.update = /* @__PURE__ */ function() {
  return function() {
    const s = this.matrix, t = this.min, e = this.max, i = this.points;
    for (let c = 0; c <= 1; c++)
      for (let h = 0; h <= 1; h++)
        for (let d = 0; d <= 1; d++) {
          const E = 1 * c | 2 * h | 4 * d, u = i[E];
          u.x = c ? e.x : t.x, u.y = h ? e.y : t.y, u.z = d ? e.z : t.z, u.applyMatrix4(s);
        }
    const o = this.satBounds, n = this.satAxes, r = i[0];
    for (let c = 0; c < 3; c++) {
      const h = n[c], d = o[c], E = 1 << c, u = i[E];
      h.subVectors(r, u), d.setFromPoints(h, i);
    }
    const a = this.alignedSatBounds;
    a[0].setFromPointsField(i, "x"), a[1].setFromPointsField(i, "y"), a[2].setFromPointsField(i, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = false;
  };
}();
at.prototype.intersectsBox = function() {
  const l = new wt();
  return function(t) {
    this.needsUpdate && this.update();
    const e = t.min, i = t.max, o = this.satBounds, n = this.satAxes, r = this.alignedSatBounds;
    if (l.min = e.x, l.max = i.x, r[0].isSeparated(l) || (l.min = e.y, l.max = i.y, r[1].isSeparated(l)) || (l.min = e.z, l.max = i.z, r[2].isSeparated(l)))
      return false;
    for (let a = 0; a < 3; a++) {
      const c = n[a], h = o[a];
      if (l.setFromBox(c, t), h.isSeparated(l))
        return false;
    }
    return true;
  };
}();
at.prototype.intersectsTriangle = function() {
  const l = new Ft(), s = new Array(3), t = new wt(), e = new wt(), i = new Vector3();
  return function(n) {
    this.needsUpdate && this.update(), n.isExtendedTriangle ? n.needsUpdate && n.update() : (l.copy(n), l.update(), n = l);
    const r = this.satBounds, a = this.satAxes;
    s[0] = n.a, s[1] = n.b, s[2] = n.c;
    for (let E = 0; E < 3; E++) {
      const u = r[E], f = a[E];
      if (t.setFromPoints(f, s), u.isSeparated(t))
        return false;
    }
    const c = n.satBounds, h = n.satAxes, d = this.points;
    for (let E = 0; E < 3; E++) {
      const u = c[E], f = h[E];
      if (t.setFromPoints(f, d), u.isSeparated(t))
        return false;
    }
    for (let E = 0; E < 3; E++) {
      const u = a[E];
      for (let f = 0; f < 4; f++) {
        const T = h[f];
        if (i.crossVectors(u, T), t.setFromPoints(i, s), e.setFromPoints(i, d), t.isSeparated(e))
          return false;
      }
    }
    return true;
  };
}();
at.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function(s, t) {
    return this.needsUpdate && this.update(), t.copy(s).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t;
  };
}();
at.prototype.distanceToPoint = function() {
  const l = new Vector3();
  return function(t) {
    return this.closestPointToPoint(t, l), t.distanceTo(l);
  };
}();
at.prototype.distanceToBox = function() {
  const l = ["x", "y", "z"], s = new Array(12).fill().map(() => new Line3()), t = new Array(12).fill().map(() => new Line3()), e = new Vector3(), i = new Vector3();
  return function(n, r = 0, a = null, c = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(n))
      return (a || c) && (n.getCenter(i), this.closestPointToPoint(i, e), n.closestPointToPoint(e, i), a && a.copy(e), c && c.copy(i)), 0;
    const h = r * r, d = n.min, E = n.max, u = this.points;
    let f = 1 / 0;
    for (let R = 0; R < 8; R++) {
      const C = u[R];
      i.copy(C).clamp(d, E);
      const A = C.distanceToSquared(i);
      if (A < f && (f = A, a && a.copy(C), c && c.copy(i), A < h))
        return Math.sqrt(A);
    }
    let T = 0;
    for (let R = 0; R < 3; R++)
      for (let C = 0; C <= 1; C++)
        for (let A = 0; A <= 1; A++) {
          const F = (R + 1) % 3, p = (R + 2) % 3, m = C << F | A << p, g = 1 << R | C << F | A << p, S = u[m], _ = u[g];
          s[T].set(S, _);
          const y = l[R], w = l[F], L = l[p], U = t[T], b = U.start, B = U.end;
          b[y] = d[y], b[w] = C ? d[w] : E[w], b[L] = A ? d[L] : E[w], B[y] = E[y], B[w] = C ? d[w] : E[w], B[L] = A ? d[L] : E[w], T++;
        }
    for (let R = 0; R <= 1; R++)
      for (let C = 0; C <= 1; C++)
        for (let A = 0; A <= 1; A++) {
          i.x = R ? E.x : d.x, i.y = C ? E.y : d.y, i.z = A ? E.z : d.z, this.closestPointToPoint(i, e);
          const F = i.distanceToSquared(e);
          if (F < f && (f = F, a && a.copy(e), c && c.copy(i), F < h))
            return Math.sqrt(F);
        }
    for (let R = 0; R < 12; R++) {
      const C = s[R];
      for (let A = 0; A < 12; A++) {
        const F = t[A];
        gi(C, F, e, i);
        const p = e.distanceToSquared(i);
        if (p < f && (f = p, a && a.copy(e), c && c.copy(i), p < h))
          return Math.sqrt(p);
      }
    }
    return Math.sqrt(f);
  };
}();
var Oi = class {
  constructor(s) {
    this._getNewPrimitive = s, this._primitives = [];
  }
  getPrimitive() {
    const s = this._primitives;
    return s.length === 0 ? this._getNewPrimitive() : s.pop();
  }
  releasePrimitive(s) {
    this._primitives.push(s);
  }
};
var Oo = class extends Oi {
  constructor() {
    super(() => new Ft());
  }
};
var It = new Oo();
function Et(l, s) {
  return s[l + 15] === 65535;
}
function dt(l, s) {
  return s[l + 6];
}
function ft(l, s) {
  return s[l + 14];
}
function pt(l) {
  return l + 8;
}
function Ct(l, s) {
  return s[l + 6];
}
function Un(l, s) {
  return s[l + 7];
}
var So = class {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const s = [];
    let t = null;
    this.setBuffer = (e) => {
      t && s.push(t), t = e, this.float32Array = new Float32Array(e), this.uint16Array = new Uint16Array(e), this.uint32Array = new Uint32Array(e);
    }, this.clearBuffer = () => {
      t = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, s.length !== 0 && this.setBuffer(s.pop());
    };
  }
};
var Z = new So();
var Yt;
var Ie;
var Jt = [];
var Ke = new Oi(() => new Box3());
function _o(l, s, t, e, i, o) {
  Yt = Ke.getPrimitive(), Ie = Ke.getPrimitive(), Jt.push(Yt, Ie), Z.setBuffer(l._roots[s]);
  const n = ai(0, l.geometry, t, e, i, o);
  Z.clearBuffer(), Ke.releasePrimitive(Yt), Ke.releasePrimitive(Ie), Jt.pop(), Jt.pop();
  const r = Jt.length;
  return r > 0 && (Ie = Jt[r - 1], Yt = Jt[r - 2]), n;
}
function ai(l, s, t, e, i = null, o = 0, n = 0) {
  const { float32Array: r, uint16Array: a, uint32Array: c } = Z;
  let h = l * 2;
  if (Et(h, a)) {
    const E = dt(l, c), u = ft(h, a);
    return K(l, r, Yt), e(E, u, false, n, o + l, Yt);
  } else {
    let y = function(L) {
      const { uint16Array: U, uint32Array: b } = Z;
      let B = L * 2;
      for (; !Et(B, U); )
        L = pt(L), B = L * 2;
      return dt(L, b);
    }, w = function(L) {
      const { uint16Array: U, uint32Array: b } = Z;
      let B = L * 2;
      for (; !Et(B, U); )
        L = Ct(L, b), B = L * 2;
      return dt(L, b) + ft(B, U);
    };
    const E = pt(l), u = Ct(l, c);
    let f = E, T = u, R, C, A, F;
    if (i && (A = Yt, F = Ie, K(f, r, A), K(T, r, F), R = i(A), C = i(F), C < R)) {
      f = u, T = E;
      const L = R;
      R = C, C = L, A = F;
    }
    A || (A = Yt, K(f, r, A));
    const p = Et(f * 2, a), m = t(A, p, R, n + 1, o + f);
    let g;
    if (m === xi) {
      const L = y(f), b = w(f) - L;
      g = e(L, b, true, n + 1, o + f, A);
    } else
      g = m && ai(
        f,
        s,
        t,
        e,
        i,
        o,
        n + 1
      );
    if (g)
      return true;
    F = Ie, K(T, r, F);
    const S = Et(T * 2, a), _ = t(F, S, C, n + 1, o + T);
    let N;
    if (_ === xi) {
      const L = y(T), b = w(T) - L;
      N = e(L, b, true, n + 1, o + T, F);
    } else
      N = _ && ai(
        T,
        s,
        t,
        e,
        i,
        o,
        n + 1
      );
    return !!N;
  }
}
var Fe = new Vector3();
var Hs = new Vector3();
function No(l, s, t = {}, e = 0, i = 1 / 0) {
  const o = e * e, n = i * i;
  let r = 1 / 0, a = null;
  if (l.shapecast(
    {
      boundsTraverseOrder: (h) => (Fe.copy(s).clamp(h.min, h.max), Fe.distanceToSquared(s)),
      intersectsBounds: (h, d, E) => E < r && E < n,
      intersectsTriangle: (h, d) => {
        h.closestPointToPoint(s, Fe);
        const E = s.distanceToSquared(Fe);
        return E < r && (Hs.copy(Fe), r = E, a = d), E < o;
      }
    }
  ), r === 1 / 0)
    return null;
  const c = Math.sqrt(r);
  return t.point ? t.point.copy(Hs) : t.point = Hs.clone(), t.distance = c, t.faceIndex = a, t;
}
var te = new Vector3();
var ee = new Vector3();
var se = new Vector3();
var $e = new Vector2();
var Je = new Vector2();
var ts = new Vector2();
var Vi = new Vector3();
var Gi = new Vector3();
var zi = new Vector3();
var es = new Vector3();
function Po(l, s, t, e, i, o) {
  let n;
  return o === BackSide ? n = l.intersectTriangle(e, t, s, true, i) : n = l.intersectTriangle(s, t, e, o !== DoubleSide, i), n === null ? null : {
    distance: l.origin.distanceTo(i),
    point: i.clone()
  };
}
function yo(l, s, t, e, i, o, n, r, a) {
  te.fromBufferAttribute(s, o), ee.fromBufferAttribute(s, n), se.fromBufferAttribute(s, r);
  const c = Po(l, te, ee, se, es, a);
  if (c) {
    e && ($e.fromBufferAttribute(e, o), Je.fromBufferAttribute(e, n), ts.fromBufferAttribute(e, r), c.uv = Triangle.getInterpolation(es, te, ee, se, $e, Je, ts, new Vector2())), i && ($e.fromBufferAttribute(i, o), Je.fromBufferAttribute(i, n), ts.fromBufferAttribute(i, r), c.uv1 = Triangle.getInterpolation(es, te, ee, se, $e, Je, ts, new Vector2())), t && (Vi.fromBufferAttribute(t, o), Gi.fromBufferAttribute(t, n), zi.fromBufferAttribute(t, r), c.normal = Triangle.getInterpolation(es, te, ee, se, Vi, Gi, zi, new Vector3()), c.normal.dot(l.direction) > 0 && c.normal.multiplyScalar(-1));
    const h = {
      a: o,
      b: n,
      c: r,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(te, ee, se, h.normal), c.face = h, c.faceIndex = o;
  }
  return c;
}
function xs(l, s, t, e, i) {
  const o = e * 3;
  let n = o + 0, r = o + 1, a = o + 2;
  const c = l.index;
  l.index && (n = c.getX(n), r = c.getX(r), a = c.getX(a));
  const { position: h, normal: d, uv: E, uv1: u } = l.attributes, f = yo(t, h, d, E, u, n, r, a, s);
  return f ? (f.faceIndex = e, i && i.push(f), f) : null;
}
function tt(l, s, t, e) {
  const i = l.a, o = l.b, n = l.c;
  let r = s, a = s + 1, c = s + 2;
  t && (r = t.getX(r), a = t.getX(a), c = t.getX(c)), i.x = e.getX(r), i.y = e.getY(r), i.z = e.getZ(r), o.x = e.getX(a), o.y = e.getY(a), o.z = e.getZ(a), n.x = e.getX(c), n.y = e.getY(c), n.z = e.getZ(c);
}
function Lo(l, s, t, e, i, o) {
  const { geometry: n, _indirectBuffer: r } = l;
  for (let a = e, c = e + i; a < c; a++)
    xs(n, s, t, a, o);
}
function Mo(l, s, t, e, i) {
  const { geometry: o, _indirectBuffer: n } = l;
  let r = 1 / 0, a = null;
  for (let c = e, h = e + i; c < h; c++) {
    let d;
    d = xs(o, s, t, c), d && d.distance < r && (a = d, r = d.distance);
  }
  return a;
}
function wo(l, s, t, e, i, o, n) {
  const { geometry: r } = t, { index: a } = r, c = r.attributes.position;
  for (let h = l, d = s + l; h < d; h++) {
    let E;
    if (E = h, tt(n, E * 3, a, c), n.needsUpdate = true, e(n, E, i, o))
      return true;
  }
  return false;
}
function Do(l, s = null) {
  s && Array.isArray(s) && (s = new Set(s));
  const t = l.geometry, e = t.index ? t.index.array : null, i = t.attributes.position;
  let o, n, r, a, c = 0;
  const h = l._roots;
  for (let E = 0, u = h.length; E < u; E++)
    o = h[E], n = new Uint32Array(o), r = new Uint16Array(o), a = new Float32Array(o), d(0, c), c += o.byteLength;
  function d(E, u, f = false) {
    const T = E * 2;
    if (r[T + 15] === Us) {
      const C = n[E + 6], A = r[T + 14];
      let F = 1 / 0, p = 1 / 0, m = 1 / 0, g = -1 / 0, S = -1 / 0, _ = -1 / 0;
      for (let N = 3 * C, y = 3 * (C + A); N < y; N++) {
        let w = e[N];
        const L = i.getX(w), U = i.getY(w), b = i.getZ(w);
        L < F && (F = L), L > g && (g = L), U < p && (p = U), U > S && (S = U), b < m && (m = b), b > _ && (_ = b);
      }
      return a[E + 0] !== F || a[E + 1] !== p || a[E + 2] !== m || a[E + 3] !== g || a[E + 4] !== S || a[E + 5] !== _ ? (a[E + 0] = F, a[E + 1] = p, a[E + 2] = m, a[E + 3] = g, a[E + 4] = S, a[E + 5] = _, true) : false;
    } else {
      const C = E + 8, A = n[E + 6], F = C + u, p = A + u;
      let m = f, g = false, S = false;
      s ? m || (g = s.has(F), S = s.has(p), m = !g && !S) : (g = true, S = true);
      const _ = m || g, N = m || S;
      let y = false;
      _ && (y = d(C, u, m));
      let w = false;
      N && (w = d(A, u, m));
      const L = y || w;
      if (L)
        for (let U = 0; U < 3; U++) {
          const b = C + U, B = A + U, H = a[b], q = a[b + 3], st = a[B], Q = a[B + 3];
          a[E + U] = H < st ? H : st, a[E + U + 3] = q > Q ? q : Q;
        }
      return L;
    }
  }
}
var Hi = new Box3();
function Gt(l, s, t, e) {
  return K(l, s, Hi), t.intersectBox(Hi, e);
}
function Uo(l, s, t, e, i, o) {
  const { geometry: n, _indirectBuffer: r } = l;
  for (let a = e, c = e + i; a < c; a++) {
    let h = r ? r[a] : a;
    xs(n, s, t, h, o);
  }
}
function xo(l, s, t, e, i) {
  const { geometry: o, _indirectBuffer: n } = l;
  let r = 1 / 0, a = null;
  for (let c = e, h = e + i; c < h; c++) {
    let d;
    d = xs(o, s, t, n ? n[c] : c), d && d.distance < r && (a = d, r = d.distance);
  }
  return a;
}
function bo(l, s, t, e, i, o, n) {
  const { geometry: r } = t, { index: a } = r, c = r.attributes.position;
  for (let h = l, d = s + l; h < d; h++) {
    let E;
    if (E = t.resolveTriangleIndex(h), tt(n, E * 3, a, c), n.needsUpdate = true, e(n, E, i, o))
      return true;
  }
  return false;
}
var Wi = new Vector3();
function vo(l, s, t, e, i) {
  Z.setBuffer(l._roots[s]), ci(0, l, t, e, i), Z.clearBuffer();
}
function ci(l, s, t, e, i) {
  const { float32Array: o, uint16Array: n, uint32Array: r } = Z, a = l * 2;
  if (Et(a, n)) {
    const h = dt(l, r), d = ft(a, n);
    Lo(s, t, e, h, d, i);
  } else {
    const h = pt(l);
    Gt(h, o, e, Wi) && ci(h, s, t, e, i);
    const d = Ct(l, r);
    Gt(d, o, e, Wi) && ci(d, s, t, e, i);
  }
}
var ki = new Vector3();
var Bo = ["x", "y", "z"];
function Yo(l, s, t, e) {
  Z.setBuffer(l._roots[s]);
  const i = li(0, l, t, e);
  return Z.clearBuffer(), i;
}
function li(l, s, t, e) {
  const { float32Array: i, uint16Array: o, uint32Array: n } = Z;
  let r = l * 2;
  if (Et(r, o)) {
    const c = dt(l, n), h = ft(r, o);
    return Mo(s, t, e, c, h);
  } else {
    const c = Un(l, n), h = Bo[c], E = e.direction[h] >= 0;
    let u, f;
    E ? (u = pt(l), f = Ct(l, n)) : (u = Ct(l, n), f = pt(l));
    const R = Gt(u, i, e, ki) ? li(u, s, t, e) : null;
    if (R) {
      const F = R.point[h];
      if (E ? F <= i[f + c] : (
        // min bounding data
        F >= i[f + c + 3]
      ))
        return R;
    }
    const A = Gt(f, i, e, ki) ? li(f, s, t, e) : null;
    return R && A ? R.distance <= A.distance ? R : A : R || A || null;
  }
}
var ss = new Box3();
var ie = new Ft();
var ne = new Ft();
var ge = new Matrix4();
var Xi = new at();
var is = new at();
function Vo(l, s, t, e) {
  Z.setBuffer(l._roots[s]);
  const i = hi(0, l, t, e);
  return Z.clearBuffer(), i;
}
function hi(l, s, t, e, i = null) {
  const { float32Array: o, uint16Array: n, uint32Array: r } = Z;
  let a = l * 2;
  if (i === null && (t.boundingBox || t.computeBoundingBox(), Xi.set(t.boundingBox.min, t.boundingBox.max, e), i = Xi), Et(a, n)) {
    const h = s.geometry, d = h.index, E = h.attributes.position, u = t.index, f = t.attributes.position, T = dt(l, r), R = ft(a, n);
    if (ge.copy(e).invert(), t.boundsTree)
      return K(l, o, is), is.matrix.copy(ge), is.needsUpdate = true, t.boundsTree.shapecast({
        intersectsBounds: (A) => is.intersectsBox(A),
        intersectsTriangle: (A) => {
          A.a.applyMatrix4(e), A.b.applyMatrix4(e), A.c.applyMatrix4(e), A.needsUpdate = true;
          for (let F = T * 3, p = (R + T) * 3; F < p; F += 3)
            if (tt(ne, F, d, E), ne.needsUpdate = true, A.intersectsTriangle(ne))
              return true;
          return false;
        }
      });
    for (let C = T * 3, A = (R + T) * 3; C < A; C += 3) {
      tt(ie, C, d, E), ie.a.applyMatrix4(ge), ie.b.applyMatrix4(ge), ie.c.applyMatrix4(ge), ie.needsUpdate = true;
      for (let F = 0, p = u.count; F < p; F += 3)
        if (tt(ne, F, u, f), ne.needsUpdate = true, ie.intersectsTriangle(ne))
          return true;
    }
  } else {
    const h = l + 8, d = r[l + 6];
    return K(h, o, ss), !!(i.intersectsBox(ss) && hi(h, s, t, e, i) || (K(d, o, ss), i.intersectsBox(ss) && hi(d, s, t, e, i)));
  }
}
var ns = new Matrix4();
var Ws = new at();
var Oe = new at();
var Go = new Vector3();
var zo = new Vector3();
var Ho = new Vector3();
var Wo = new Vector3();
function ko(l, s, t, e = {}, i = {}, o = 0, n = 1 / 0) {
  s.boundingBox || s.computeBoundingBox(), Ws.set(s.boundingBox.min, s.boundingBox.max, t), Ws.needsUpdate = true;
  const r = l.geometry, a = r.attributes.position, c = r.index, h = s.attributes.position, d = s.index, E = It.getPrimitive(), u = It.getPrimitive();
  let f = Go, T = zo, R = null, C = null;
  i && (R = Ho, C = Wo);
  let A = 1 / 0, F = null, p = null;
  return ns.copy(t).invert(), Oe.matrix.copy(ns), l.shapecast(
    {
      boundsTraverseOrder: (m) => Ws.distanceToBox(m),
      intersectsBounds: (m, g, S) => S < A && S < n ? (g && (Oe.min.copy(m.min), Oe.max.copy(m.max), Oe.needsUpdate = true), true) : false,
      intersectsRange: (m, g) => {
        if (s.boundsTree)
          return s.boundsTree.shapecast({
            boundsTraverseOrder: (_) => Oe.distanceToBox(_),
            intersectsBounds: (_, N, y) => y < A && y < n,
            intersectsRange: (_, N) => {
              for (let y = _, w = _ + N; y < w; y++) {
                tt(u, 3 * y, d, h), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = true;
                for (let L = m, U = m + g; L < U; L++) {
                  tt(E, 3 * L, c, a), E.needsUpdate = true;
                  const b = E.distanceToTriangle(u, f, R);
                  if (b < A && (T.copy(f), C && C.copy(R), A = b, F = L, p = y), b < o)
                    return true;
                }
              }
            }
          });
        {
          const S = Ce(s);
          for (let _ = 0, N = S; _ < N; _++) {
            tt(u, 3 * _, d, h), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = true;
            for (let y = m, w = m + g; y < w; y++) {
              tt(E, 3 * y, c, a), E.needsUpdate = true;
              const L = E.distanceToTriangle(u, f, R);
              if (L < A && (T.copy(f), C && C.copy(R), A = L, F = y, p = _), L < o)
                return true;
            }
          }
        }
      }
    }
  ), It.releasePrimitive(E), It.releasePrimitive(u), A === 1 / 0 ? null : (e.point ? e.point.copy(T) : e.point = T.clone(), e.distance = A, e.faceIndex = F, i && (i.point ? i.point.copy(C) : i.point = C.clone(), i.point.applyMatrix4(ns), T.applyMatrix4(ns), i.distance = T.sub(i.point).length(), i.faceIndex = p), e);
}
function Xo(l, s = null) {
  s && Array.isArray(s) && (s = new Set(s));
  const t = l.geometry, e = t.index ? t.index.array : null, i = t.attributes.position;
  let o, n, r, a, c = 0;
  const h = l._roots;
  for (let E = 0, u = h.length; E < u; E++)
    o = h[E], n = new Uint32Array(o), r = new Uint16Array(o), a = new Float32Array(o), d(0, c), c += o.byteLength;
  function d(E, u, f = false) {
    const T = E * 2;
    if (r[T + 15] === Us) {
      const C = n[E + 6], A = r[T + 14];
      let F = 1 / 0, p = 1 / 0, m = 1 / 0, g = -1 / 0, S = -1 / 0, _ = -1 / 0;
      for (let N = C, y = C + A; N < y; N++) {
        const w = 3 * l.resolveTriangleIndex(N);
        for (let L = 0; L < 3; L++) {
          let U = w + L;
          U = e ? e[U] : U;
          const b = i.getX(U), B = i.getY(U), H = i.getZ(U);
          b < F && (F = b), b > g && (g = b), B < p && (p = B), B > S && (S = B), H < m && (m = H), H > _ && (_ = H);
        }
      }
      return a[E + 0] !== F || a[E + 1] !== p || a[E + 2] !== m || a[E + 3] !== g || a[E + 4] !== S || a[E + 5] !== _ ? (a[E + 0] = F, a[E + 1] = p, a[E + 2] = m, a[E + 3] = g, a[E + 4] = S, a[E + 5] = _, true) : false;
    } else {
      const C = E + 8, A = n[E + 6], F = C + u, p = A + u;
      let m = f, g = false, S = false;
      s ? m || (g = s.has(F), S = s.has(p), m = !g && !S) : (g = true, S = true);
      const _ = m || g, N = m || S;
      let y = false;
      _ && (y = d(C, u, m));
      let w = false;
      N && (w = d(A, u, m));
      const L = y || w;
      if (L)
        for (let U = 0; U < 3; U++) {
          const b = C + U, B = A + U, H = a[b], q = a[b + 3], st = a[B], Q = a[B + 3];
          a[E + U] = H < st ? H : st, a[E + U + 3] = q > Q ? q : Q;
        }
      return L;
    }
  }
}
var Zi = new Vector3();
function Zo(l, s, t, e, i) {
  Z.setBuffer(l._roots[s]), Ei(0, l, t, e, i), Z.clearBuffer();
}
function Ei(l, s, t, e, i) {
  const { float32Array: o, uint16Array: n, uint32Array: r } = Z, a = l * 2;
  if (Et(a, n)) {
    const h = dt(l, r), d = ft(a, n);
    Uo(s, t, e, h, d, i);
  } else {
    const h = pt(l);
    Gt(h, o, e, Zi) && Ei(h, s, t, e, i);
    const d = Ct(l, r);
    Gt(d, o, e, Zi) && Ei(d, s, t, e, i);
  }
}
var Qi = new Vector3();
var Qo = ["x", "y", "z"];
function jo(l, s, t, e) {
  Z.setBuffer(l._roots[s]);
  const i = di(0, l, t, e);
  return Z.clearBuffer(), i;
}
function di(l, s, t, e) {
  const { float32Array: i, uint16Array: o, uint32Array: n } = Z;
  let r = l * 2;
  if (Et(r, o)) {
    const c = dt(l, n), h = ft(r, o);
    return xo(s, t, e, c, h);
  } else {
    const c = Un(l, n), h = Qo[c], E = e.direction[h] >= 0;
    let u, f;
    E ? (u = pt(l), f = Ct(l, n)) : (u = Ct(l, n), f = pt(l));
    const R = Gt(u, i, e, Qi) ? di(u, s, t, e) : null;
    if (R) {
      const F = R.point[h];
      if (E ? F <= i[f + c] : (
        // min bounding data
        F >= i[f + c + 3]
      ))
        return R;
    }
    const A = Gt(f, i, e, Qi) ? di(f, s, t, e) : null;
    return R && A ? R.distance <= A.distance ? R : A : R || A || null;
  }
}
var os = new Box3();
var oe = new Ft();
var re = new Ft();
var Se = new Matrix4();
var ji = new at();
var rs = new at();
function qo(l, s, t, e) {
  Z.setBuffer(l._roots[s]);
  const i = ui(0, l, t, e);
  return Z.clearBuffer(), i;
}
function ui(l, s, t, e, i = null) {
  const { float32Array: o, uint16Array: n, uint32Array: r } = Z;
  let a = l * 2;
  if (i === null && (t.boundingBox || t.computeBoundingBox(), ji.set(t.boundingBox.min, t.boundingBox.max, e), i = ji), Et(a, n)) {
    const h = s.geometry, d = h.index, E = h.attributes.position, u = t.index, f = t.attributes.position, T = dt(l, r), R = ft(a, n);
    if (Se.copy(e).invert(), t.boundsTree)
      return K(l, o, rs), rs.matrix.copy(Se), rs.needsUpdate = true, t.boundsTree.shapecast({
        intersectsBounds: (A) => rs.intersectsBox(A),
        intersectsTriangle: (A) => {
          A.a.applyMatrix4(e), A.b.applyMatrix4(e), A.c.applyMatrix4(e), A.needsUpdate = true;
          for (let F = T, p = R + T; F < p; F++)
            if (tt(re, 3 * s.resolveTriangleIndex(F), d, E), re.needsUpdate = true, A.intersectsTriangle(re))
              return true;
          return false;
        }
      });
    for (let C = T, A = R + T; C < A; C++) {
      const F = s.resolveTriangleIndex(C);
      tt(oe, 3 * F, d, E), oe.a.applyMatrix4(Se), oe.b.applyMatrix4(Se), oe.c.applyMatrix4(Se), oe.needsUpdate = true;
      for (let p = 0, m = u.count; p < m; p += 3)
        if (tt(re, p, u, f), re.needsUpdate = true, oe.intersectsTriangle(re))
          return true;
    }
  } else {
    const h = l + 8, d = r[l + 6];
    return K(h, o, os), !!(i.intersectsBox(os) && ui(h, s, t, e, i) || (K(d, o, os), i.intersectsBox(os) && ui(d, s, t, e, i)));
  }
}
var as = new Matrix4();
var ks = new at();
var _e = new at();
var Ko = new Vector3();
var $o = new Vector3();
var Jo = new Vector3();
var tr = new Vector3();
function er(l, s, t, e = {}, i = {}, o = 0, n = 1 / 0) {
  s.boundingBox || s.computeBoundingBox(), ks.set(s.boundingBox.min, s.boundingBox.max, t), ks.needsUpdate = true;
  const r = l.geometry, a = r.attributes.position, c = r.index, h = s.attributes.position, d = s.index, E = It.getPrimitive(), u = It.getPrimitive();
  let f = Ko, T = $o, R = null, C = null;
  i && (R = Jo, C = tr);
  let A = 1 / 0, F = null, p = null;
  return as.copy(t).invert(), _e.matrix.copy(as), l.shapecast(
    {
      boundsTraverseOrder: (m) => ks.distanceToBox(m),
      intersectsBounds: (m, g, S) => S < A && S < n ? (g && (_e.min.copy(m.min), _e.max.copy(m.max), _e.needsUpdate = true), true) : false,
      intersectsRange: (m, g) => {
        if (s.boundsTree) {
          const S = s.boundsTree;
          return S.shapecast({
            boundsTraverseOrder: (_) => _e.distanceToBox(_),
            intersectsBounds: (_, N, y) => y < A && y < n,
            intersectsRange: (_, N) => {
              for (let y = _, w = _ + N; y < w; y++) {
                const L = S.resolveTriangleIndex(y);
                tt(u, 3 * L, d, h), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = true;
                for (let U = m, b = m + g; U < b; U++) {
                  const B = l.resolveTriangleIndex(U);
                  tt(E, 3 * B, c, a), E.needsUpdate = true;
                  const H = E.distanceToTriangle(u, f, R);
                  if (H < A && (T.copy(f), C && C.copy(R), A = H, F = U, p = y), H < o)
                    return true;
                }
              }
            }
          });
        } else {
          const S = Ce(s);
          for (let _ = 0, N = S; _ < N; _++) {
            tt(u, 3 * _, d, h), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = true;
            for (let y = m, w = m + g; y < w; y++) {
              const L = l.resolveTriangleIndex(y);
              tt(E, 3 * L, c, a), E.needsUpdate = true;
              const U = E.distanceToTriangle(u, f, R);
              if (U < A && (T.copy(f), C && C.copy(R), A = U, F = y, p = _), U < o)
                return true;
            }
          }
        }
      }
    }
  ), It.releasePrimitive(E), It.releasePrimitive(u), A === 1 / 0 ? null : (e.point ? e.point.copy(T) : e.point = T.clone(), e.distance = A, e.faceIndex = F, i && (i.point ? i.point.copy(C) : i.point = C.clone(), i.point.applyMatrix4(as), T.applyMatrix4(as), i.distance = T.sub(i.point).length(), i.faceIndex = p), e);
}
function sr() {
  return typeof SharedArrayBuffer < "u";
}
var be = new Z.constructor();
var As = new Z.constructor();
var vt = new Oi(() => new Box3());
var ae = new Box3();
var ce = new Box3();
var Xs = new Box3();
var Zs = new Box3();
var Qs = false;
function ir(l, s, t, e) {
  if (Qs)
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  Qs = true;
  const i = l._roots, o = s._roots;
  let n, r = 0, a = 0;
  const c = new Matrix4().copy(t).invert();
  for (let h = 0, d = i.length; h < d; h++) {
    be.setBuffer(i[h]), a = 0;
    const E = vt.getPrimitive();
    K(0, be.float32Array, E), E.applyMatrix4(c);
    for (let u = 0, f = o.length; u < f && (As.setBuffer(o[h]), n = Tt(
      0,
      0,
      t,
      c,
      e,
      r,
      a,
      0,
      0,
      E
    ), As.clearBuffer(), a += o[u].length, !n); u++)
      ;
    if (vt.releasePrimitive(E), be.clearBuffer(), r += i[h].length, n)
      break;
  }
  return Qs = false, n;
}
function Tt(l, s, t, e, i, o = 0, n = 0, r = 0, a = 0, c = null, h = false) {
  let d, E;
  h ? (d = As, E = be) : (d = be, E = As);
  const u = d.float32Array, f = d.uint32Array, T = d.uint16Array, R = E.float32Array, C = E.uint32Array, A = E.uint16Array, F = l * 2, p = s * 2, m = Et(F, T), g = Et(p, A);
  let S = false;
  if (g && m)
    h ? S = i(
      dt(s, C),
      ft(s * 2, A),
      dt(l, f),
      ft(l * 2, T),
      a,
      n + s,
      r,
      o + l
    ) : S = i(
      dt(l, f),
      ft(l * 2, T),
      dt(s, C),
      ft(s * 2, A),
      r,
      o + l,
      a,
      n + s
    );
  else if (g) {
    const _ = vt.getPrimitive();
    K(s, R, _), _.applyMatrix4(t);
    const N = pt(l), y = Ct(l, f);
    K(N, u, ae), K(y, u, ce);
    const w = _.intersectsBox(ae), L = _.intersectsBox(ce);
    S = w && Tt(
      s,
      N,
      e,
      t,
      i,
      n,
      o,
      a,
      r + 1,
      _,
      !h
    ) || L && Tt(
      s,
      y,
      e,
      t,
      i,
      n,
      o,
      a,
      r + 1,
      _,
      !h
    ), vt.releasePrimitive(_);
  } else {
    const _ = pt(s), N = Ct(s, C);
    K(_, R, Xs), K(N, R, Zs);
    const y = c.intersectsBox(Xs), w = c.intersectsBox(Zs);
    if (y && w)
      S = Tt(
        l,
        _,
        t,
        e,
        i,
        o,
        n,
        r,
        a + 1,
        c,
        h
      ) || Tt(
        l,
        N,
        t,
        e,
        i,
        o,
        n,
        r,
        a + 1,
        c,
        h
      );
    else if (y)
      if (m)
        S = Tt(
          l,
          _,
          t,
          e,
          i,
          o,
          n,
          r,
          a + 1,
          c,
          h
        );
      else {
        const L = vt.getPrimitive();
        L.copy(Xs).applyMatrix4(t);
        const U = pt(l), b = Ct(l, f);
        K(U, u, ae), K(b, u, ce);
        const B = L.intersectsBox(ae), H = L.intersectsBox(ce);
        S = B && Tt(
          _,
          U,
          e,
          t,
          i,
          n,
          o,
          a,
          r + 1,
          L,
          !h
        ) || H && Tt(
          _,
          b,
          e,
          t,
          i,
          n,
          o,
          a,
          r + 1,
          L,
          !h
        ), vt.releasePrimitive(L);
      }
    else if (w)
      if (m)
        S = Tt(
          l,
          N,
          t,
          e,
          i,
          o,
          n,
          r,
          a + 1,
          c,
          h
        );
      else {
        const L = vt.getPrimitive();
        L.copy(Zs).applyMatrix4(t);
        const U = pt(l), b = Ct(l, f);
        K(U, u, ae), K(b, u, ce);
        const B = L.intersectsBox(ae), H = L.intersectsBox(ce);
        S = B && Tt(
          N,
          U,
          e,
          t,
          i,
          n,
          o,
          a,
          r + 1,
          L,
          !h
        ) || H && Tt(
          N,
          b,
          e,
          t,
          i,
          n,
          o,
          a,
          r + 1,
          L,
          !h
        ), vt.releasePrimitive(L);
      }
  }
  return S;
}
var cs = new at();
var qi = new Box3();
var Si = class _Si {
  static serialize(s, t = {}) {
    t = {
      cloneBuffers: true,
      ...t
    };
    const e = s.geometry, i = s._roots, o = s._indirectBuffer, n = e.getIndex();
    let r;
    return t.cloneBuffers ? r = {
      roots: i.map((a) => a.slice()),
      index: n.array.slice(),
      indirectBuffer: o ? o.slice() : null
    } : r = {
      roots: i,
      index: n.array,
      indirectBuffer: o
    }, r;
  }
  static deserialize(s, t, e = {}) {
    e = {
      setIndex: true,
      indirect: !!s.indirectBuffer,
      ...e
    };
    const { index: i, roots: o, indirectBuffer: n } = s, r = new _Si(t, { ...e, [Vs]: true });
    if (r._roots = o, r._indirectBuffer = n || null, e.setIndex) {
      const a = t.getIndex();
      if (a === null) {
        const c = new BufferAttribute(s.index, 1, false);
        t.setIndex(c);
      } else
        a.array !== i && (a.array.set(i), a.needsUpdate = true);
    }
    return r;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(s, t = {}) {
    if (s.isBufferGeometry) {
      if (s.index && s.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    } else
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (t = Object.assign({
      strategy: Mn,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      indirect: false,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [Vs]: false
    }, t), t.useSharedArrayBuffer && !sr())
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = s, this._roots = null, this._indirectBuffer = null, t[Vs] || (Ro(this, t), !s.boundingBox && t.setBoundingBox && (s.boundingBox = this.getBoundingBox(new Box3())));
    const { _indirectBuffer: e } = this;
    this.resolveTriangleIndex = t.indirect ? (i) => e[i] : (i) => i;
  }
  refit(s = null) {
    return (this.indirect ? Xo : Do)(this, s);
  }
  traverse(s, t = 0) {
    const e = this._roots[t], i = new Uint32Array(e), o = new Uint16Array(e);
    n(0);
    function n(r, a = 0) {
      const c = r * 2, h = o[c + 15] === Us;
      if (h) {
        const d = i[r + 6], E = o[c + 14];
        s(a, h, new Float32Array(e, r * 4, 6), d, E);
      } else {
        const d = r + Cs / 4, E = i[r + 6], u = i[r + 7];
        s(a, h, new Float32Array(e, r * 4, 6), u) || (n(d, a + 1), n(E, a + 1));
      }
    }
  }
  /* Core Cast Functions */
  raycast(s, t = FrontSide) {
    const e = this._roots, i = this.geometry, o = [], n = t.isMaterial, r = Array.isArray(t), a = i.groups, c = n ? t.side : t, h = this.indirect ? Zo : vo;
    for (let d = 0, E = e.length; d < E; d++) {
      const u = r ? t[a[d].materialIndex].side : c, f = o.length;
      if (h(this, d, u, s, o), r) {
        const T = a[d].materialIndex;
        for (let R = f, C = o.length; R < C; R++)
          o[R].face.materialIndex = T;
      }
    }
    return o;
  }
  raycastFirst(s, t = FrontSide) {
    const e = this._roots, i = this.geometry, o = t.isMaterial, n = Array.isArray(t);
    let r = null;
    const a = i.groups, c = o ? t.side : t, h = this.indirect ? jo : Yo;
    for (let d = 0, E = e.length; d < E; d++) {
      const u = n ? t[a[d].materialIndex].side : c, f = h(this, d, u, s);
      f != null && (r == null || f.distance < r.distance) && (r = f, n && (f.face.materialIndex = a[d].materialIndex));
    }
    return r;
  }
  intersectsGeometry(s, t) {
    let e = false;
    const i = this._roots, o = this.indirect ? qo : Vo;
    for (let n = 0, r = i.length; n < r && (e = o(this, n, s, t), !e); n++)
      ;
    return e;
  }
  shapecast(s) {
    const t = It.getPrimitive(), e = this.indirect ? bo : wo;
    let {
      boundsTraverseOrder: i,
      intersectsBounds: o,
      intersectsRange: n,
      intersectsTriangle: r
    } = s;
    if (n && r) {
      const d = n;
      n = (E, u, f, T, R) => d(E, u, f, T, R) ? true : e(E, u, this, r, f, T, t);
    } else
      n || (r ? n = (d, E, u, f) => e(d, E, this, r, u, f, t) : n = (d, E, u) => u);
    let a = false, c = 0;
    const h = this._roots;
    for (let d = 0, E = h.length; d < E; d++) {
      const u = h[d];
      if (a = _o(this, d, o, n, i, c), a)
        break;
      c += u.byteLength;
    }
    return It.releasePrimitive(t), a;
  }
  bvhcast(s, t, e) {
    let {
      intersectsRanges: i,
      intersectsTriangles: o
    } = e;
    const n = It.getPrimitive(), r = this.geometry.index, a = this.geometry.attributes.position, c = this.indirect ? (f) => {
      const T = this.resolveTriangleIndex(f);
      tt(n, T * 3, r, a);
    } : (f) => {
      tt(n, f * 3, r, a);
    }, h = It.getPrimitive(), d = s.geometry.index, E = s.geometry.attributes.position, u = s.indirect ? (f) => {
      const T = s.resolveTriangleIndex(f);
      tt(h, T * 3, d, E);
    } : (f) => {
      tt(h, f * 3, d, E);
    };
    if (o) {
      const f = (T, R, C, A, F, p, m, g) => {
        for (let S = C, _ = C + A; S < _; S++) {
          u(S), h.a.applyMatrix4(t), h.b.applyMatrix4(t), h.c.applyMatrix4(t), h.needsUpdate = true;
          for (let N = T, y = T + R; N < y; N++)
            if (c(N), n.needsUpdate = true, o(n, h, N, S, F, p, m, g))
              return true;
        }
        return false;
      };
      if (i) {
        const T = i;
        i = function(R, C, A, F, p, m, g, S) {
          return T(R, C, A, F, p, m, g, S) ? true : f(R, C, A, F, p, m, g, S);
        };
      } else
        i = f;
    }
    return ir(this, s, t, i);
  }
  /* Derived Cast Functions */
  intersectsBox(s, t) {
    return cs.set(s.min, s.max, t), cs.needsUpdate = true, this.shapecast(
      {
        intersectsBounds: (e) => cs.intersectsBox(e),
        intersectsTriangle: (e) => cs.intersectsTriangle(e)
      }
    );
  }
  intersectsSphere(s) {
    return this.shapecast(
      {
        intersectsBounds: (t) => s.intersectsBox(t),
        intersectsTriangle: (t) => t.intersectsSphere(s)
      }
    );
  }
  closestPointToGeometry(s, t, e = {}, i = {}, o = 0, n = 1 / 0) {
    return (this.indirect ? er : ko)(
      this,
      s,
      t,
      e,
      i,
      o,
      n
    );
  }
  closestPointToPoint(s, t = {}, e = 0, i = 1 / 0) {
    return No(
      this,
      s,
      t,
      e,
      i
    );
  }
  getBoundingBox(s) {
    return s.makeEmpty(), this._roots.forEach((e) => {
      K(0, new Float32Array(e), qi), s.union(qi);
    }), s;
  }
};
function Ki(l, s, t) {
  return l === null || (l.point.applyMatrix4(s.matrixWorld), l.distance = l.point.distanceTo(t.ray.origin), l.object = s, l.distance < t.near || l.distance > t.far) ? null : l;
}
var js = new Ray();
var $i = new Matrix4();
var nr = Mesh.prototype.raycast;
function or(l, s) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    $i.copy(this.matrixWorld).invert(), js.copy(l.ray).applyMatrix4($i);
    const t = this.geometry.boundsTree;
    if (l.firstHitOnly === true) {
      const e = Ki(t.raycastFirst(js, this.material), this, l);
      e && s.push(e);
    } else {
      const e = t.raycast(js, this.material);
      for (let i = 0, o = e.length; i < o; i++) {
        const n = Ki(e[i], this, l);
        n && s.push(n);
      }
    }
  } else
    nr.call(this, l, s);
}
function rr(l) {
  return this.boundsTree = new Si(this, l), this.boundsTree;
}
function ar() {
  this.boundsTree = null;
}
var D = class {
  constructor() {
    I(this, "trigger", (s) => {
      const t = this.handlers.slice(0);
      for (const e of t)
        e(s);
    });
    I(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(s) {
    this.handlers.push(s);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(s) {
    this.handlers = this.handlers.filter((t) => t !== s);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var Ts = class {
  constructor() {
    I(this, "trigger", async (s) => {
      const t = this.handlers.slice(0);
      for (const e of t)
        await e(s);
    });
    I(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(s) {
    this.handlers.push(s);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(s) {
    this.handlers = this.handlers.filter((t) => t !== s);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var _i = class {
  constructor(s) {
    I(this, "isDisposeable", () => "dispose" in this && "onDisposed" in this);
    I(this, "isResizeable", () => "resize" in this && "getSize" in this);
    I(this, "isUpdateable", () => "onAfterUpdate" in this && "onBeforeUpdate" in this && "update" in this);
    I(this, "isHideable", () => "visible" in this);
    I(this, "isConfigurable", () => "setup" in this && "config" in this && "onSetup" in this);
    this.components = s;
  }
};
var et = class extends _i {
};
var Ni = class extends _i {
  constructor(t) {
    super(t);
    I(this, "worlds", /* @__PURE__ */ new Map());
    I(this, "onWorldChanged", new D());
    I(this, "currentWorld", null);
    this.onWorldChanged.add(({ world: e, action: i }) => {
      i === "removed" && this.worlds.delete(e.uuid);
    });
  }
};
var cr = class extends Ni {
  constructor() {
    super(...arguments);
    I(this, "hasCameraControls", () => "controls" in this);
  }
};
var lr = class extends Ni {
  constructor() {
    super(...arguments);
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "onDisposed", new D());
    I(this, "onResize", new D());
    I(this, "onClippingPlanesUpdated", new D());
    I(this, "clippingPlanes", []);
  }
  /**
   * Updates the clipping planes and triggers the `onClippingPlanesUpdated` event.
   *
   * @remarks
   * This method is typically called when there is a change to the list of clipping planes
   * used by the active renderer.
   */
  updateClippingPlanes() {
    this.onClippingPlanesUpdated.trigger();
  }
  /**
   * Sets or removes a clipping plane from the renderer.
   *
   * @param active - A boolean indicating whether the clipping plane should be active or not.
   * @param plane - The clipping plane to be added or removed.
   * @param isLocal - An optional boolean indicating whether the clipping plane is local to the object. If not provided, it defaults to `false`.
   *
   * @remarks
   * This method adds or removes a clipping plane from the `clippingPlanes` array.
   * If `active` is `true` and the plane is not already in the array, it is added.
   * If `active` is `false` and the plane is in the array, it is removed.
   * The `three.clippingPlanes` property is then updated to reflect the current state of the `clippingPlanes` array,
   * excluding any planes marked as local.
   */
  setPlane(t, e, i) {
    e.isLocal = i;
    const o = this.clippingPlanes.indexOf(e);
    t && o === -1 ? this.clippingPlanes.push(e) : !t && o > -1 && this.clippingPlanes.splice(o, 1), this.three.clippingPlanes = this.clippingPlanes.filter(
      (n) => !n.isLocal
    );
  }
};
var ve = class ve2 extends et {
  constructor(t) {
    super(t);
    I(this, "_disposedComponents", /* @__PURE__ */ new Set());
    I(this, "enabled", true);
    t.add(ve2.uuid, this);
  }
  // TODO: Remove this?
  /**
   * Return the UUIDs of all disposed components.
   */
  get() {
    return this._disposedComponents;
  }
  /**
   * Removes a mesh, its geometry and its materials from memory. If you are
   * using any of these in other parts of the application, make sure that you
   * remove them from the mesh before disposing it.
   *
   * @param object - the [object](https://threejs.org/docs/#api/en/core/Object3D)
   * to remove.
   *
   * @param materials - whether to dispose the materials of the mesh.
   *
   * @param recursive - whether to recursively dispose the children of the mesh.
   */
  destroy(t, e = true, i = true) {
    t.removeFromParent();
    const o = t;
    o.dispose && o.dispose(), this.disposeGeometryAndMaterials(t, e), i && o.children && o.children.length && this.disposeChildren(o), t.children.length = 0;
  }
  /**
   * Disposes a geometry from memory.
   *
   * @param geometry - the
   * [geometry](https://threejs.org/docs/#api/en/core/BufferGeometry)
   * to remove.
   */
  disposeGeometry(t) {
    t.boundsTree && t.disposeBoundsTree && t.disposeBoundsTree(), t.dispose();
  }
  disposeGeometryAndMaterials(t, e) {
    const i = t;
    i.geometry && this.disposeGeometry(i.geometry), e && i.material && ve2.disposeMaterial(i), i.material = [], i.geometry = null;
  }
  disposeChildren(t) {
    for (const e of t.children)
      this.destroy(e);
  }
  static disposeMaterial(t) {
    if (t.material)
      if (Array.isArray(t.material))
        for (const e of t.material)
          e.dispose();
      else
        t.material.dispose();
  }
};
I(ve, "uuid", "76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");
var zt = ve;
var hr = class extends Ni {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const t = this.components.get(zt);
    for (const e of this.three.children) {
      const i = e;
      i.geometry && t.destroy(i);
    }
    this.three.children = [], this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
var ms = 0;
var Er = 1;
var dr = new Vector3();
var Ji = new Line3();
var qs = new Plane();
var tn = new Vector3();
var ls = new Triangle();
var ur = class {
  constructor() {
    this.tolerance = -1, this.faces = [], this.newFaces = [], this.assigned = new en(), this.unassigned = new en(), this.vertices = [];
  }
  setFromPoints(s) {
    if (s.length >= 4) {
      this.makeEmpty();
      for (let t = 0, e = s.length; t < e; t++)
        this.vertices.push(new Ir(s[t]));
      this.compute();
    }
    return this;
  }
  setFromObject(s) {
    const t = [];
    return s.updateMatrixWorld(true), s.traverse(function(e) {
      const i = e.geometry;
      if (i !== void 0) {
        const o = i.attributes.position;
        if (o !== void 0)
          for (let n = 0, r = o.count; n < r; n++) {
            const a = new Vector3();
            a.fromBufferAttribute(o, n).applyMatrix4(e.matrixWorld), t.push(a);
          }
      }
    }), this.setFromPoints(t);
  }
  containsPoint(s) {
    const t = this.faces;
    for (let e = 0, i = t.length; e < i; e++)
      if (t[e].distanceToPoint(s) > this.tolerance)
        return false;
    return true;
  }
  intersectRay(s, t) {
    const e = this.faces;
    let i = -1 / 0, o = 1 / 0;
    for (let n = 0, r = e.length; n < r; n++) {
      const a = e[n], c = a.distanceToPoint(s.origin), h = a.normal.dot(s.direction);
      if (c > 0 && h >= 0)
        return null;
      const d = h !== 0 ? -c / h : 0;
      if (!(d <= 0) && (h > 0 ? o = Math.min(d, o) : i = Math.max(d, i), i > o))
        return null;
    }
    return i !== -1 / 0 ? s.at(i, t) : s.at(o, t), t;
  }
  intersectsRay(s) {
    return this.intersectRay(s, dr) !== null;
  }
  makeEmpty() {
    return this.faces = [], this.vertices = [], this;
  }
  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face
  addVertexToFace(s, t) {
    return s.face = t, t.outside === null ? this.assigned.append(s) : this.assigned.insertBefore(t.outside, s), t.outside = s, this;
  }
  // Removes a vertex from the 'assigned' list of vertices and from the given face
  removeVertexFromFace(s, t) {
    return s === t.outside && (s.next !== null && s.next.face === t ? t.outside = s.next : t.outside = null), this.assigned.remove(s), this;
  }
  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list
  removeAllVerticesFromFace(s) {
    if (s.outside !== null) {
      const t = s.outside;
      let e = s.outside;
      for (; e.next !== null && e.next.face === s; )
        e = e.next;
      return this.assigned.removeSubList(t, e), t.prev = e.next = null, s.outside = null, t;
    }
  }
  // Removes all the visible vertices that 'face' is able to see
  deleteFaceVertices(s, t) {
    const e = this.removeAllVerticesFromFace(s);
    if (e !== void 0)
      if (t === void 0)
        this.unassigned.appendChain(e);
      else {
        let i = e;
        do {
          const o = i.next;
          t.distanceToPoint(i.point) > this.tolerance ? this.addVertexToFace(i, t) : this.unassigned.append(i), i = o;
        } while (i !== null);
      }
    return this;
  }
  // Reassigns as many vertices as possible from the unassigned list to the new faces
  resolveUnassignedPoints(s) {
    if (this.unassigned.isEmpty() === false) {
      let t = this.unassigned.first();
      do {
        const e = t.next;
        let i = this.tolerance, o = null;
        for (let n = 0; n < s.length; n++) {
          const r = s[n];
          if (r.mark === ms) {
            const a = r.distanceToPoint(t.point);
            if (a > i && (i = a, o = r), i > 1e3 * this.tolerance)
              break;
          }
        }
        o !== null && this.addVertexToFace(t, o), t = e;
      } while (t !== null);
    }
    return this;
  }
  // Computes the extremes of a simplex which will be the initial hull
  computeExtremes() {
    const s = new Vector3(), t = new Vector3(), e = [], i = [];
    for (let o = 0; o < 3; o++)
      e[o] = i[o] = this.vertices[0];
    s.copy(this.vertices[0].point), t.copy(this.vertices[0].point);
    for (let o = 0, n = this.vertices.length; o < n; o++) {
      const r = this.vertices[o], a = r.point;
      for (let c = 0; c < 3; c++)
        a.getComponent(c) < s.getComponent(c) && (s.setComponent(c, a.getComponent(c)), e[c] = r);
      for (let c = 0; c < 3; c++)
        a.getComponent(c) > t.getComponent(c) && (t.setComponent(c, a.getComponent(c)), i[c] = r);
    }
    return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(s.x), Math.abs(t.x)) + Math.max(Math.abs(s.y), Math.abs(t.y)) + Math.max(Math.abs(s.z), Math.abs(t.z))), { min: e, max: i };
  }
  // Computes the initial simplex assigning to its faces all the points
  // that are candidates to form part of the hull
  computeInitialHull() {
    const s = this.vertices, t = this.computeExtremes(), e = t.min, i = t.max;
    let o = 0, n = 0;
    for (let E = 0; E < 3; E++) {
      const u = i[E].point.getComponent(E) - e[E].point.getComponent(E);
      u > o && (o = u, n = E);
    }
    const r = e[n], a = i[n];
    let c, h;
    o = 0, Ji.set(r.point, a.point);
    for (let E = 0, u = this.vertices.length; E < u; E++) {
      const f = s[E];
      if (f !== r && f !== a) {
        Ji.closestPointToPoint(f.point, true, tn);
        const T = tn.distanceToSquared(f.point);
        T > o && (o = T, c = f);
      }
    }
    o = -1, qs.setFromCoplanarPoints(r.point, a.point, c.point);
    for (let E = 0, u = this.vertices.length; E < u; E++) {
      const f = s[E];
      if (f !== r && f !== a && f !== c) {
        const T = Math.abs(qs.distanceToPoint(f.point));
        T > o && (o = T, h = f);
      }
    }
    const d = [];
    if (qs.distanceToPoint(h.point) < 0) {
      d.push(
        Rt.create(r, a, c),
        Rt.create(h, a, r),
        Rt.create(h, c, a),
        Rt.create(h, r, c)
      );
      for (let E = 0; E < 3; E++) {
        const u = (E + 1) % 3;
        d[E + 1].getEdge(2).setTwin(d[0].getEdge(u)), d[E + 1].getEdge(1).setTwin(d[u + 1].getEdge(0));
      }
    } else {
      d.push(
        Rt.create(r, c, a),
        Rt.create(h, r, a),
        Rt.create(h, a, c),
        Rt.create(h, c, r)
      );
      for (let E = 0; E < 3; E++) {
        const u = (E + 1) % 3;
        d[E + 1].getEdge(2).setTwin(d[0].getEdge((3 - E) % 3)), d[E + 1].getEdge(0).setTwin(d[u + 1].getEdge(1));
      }
    }
    for (let E = 0; E < 4; E++)
      this.faces.push(d[E]);
    for (let E = 0, u = s.length; E < u; E++) {
      const f = s[E];
      if (f !== r && f !== a && f !== c && f !== h) {
        o = this.tolerance;
        let T = null;
        for (let R = 0; R < 4; R++) {
          const C = this.faces[R].distanceToPoint(f.point);
          C > o && (o = C, T = this.faces[R]);
        }
        T !== null && this.addVertexToFace(f, T);
      }
    }
    return this;
  }
  // Removes inactive faces
  reindexFaces() {
    const s = [];
    for (let t = 0; t < this.faces.length; t++) {
      const e = this.faces[t];
      e.mark === ms && s.push(e);
    }
    return this.faces = s, this;
  }
  // Finds the next vertex to create faces with the current hull
  nextVertexToAdd() {
    if (this.assigned.isEmpty() === false) {
      let s, t = 0;
      const e = this.assigned.first().face;
      let i = e.outside;
      do {
        const o = e.distanceToPoint(i.point);
        o > t && (t = o, s = i), i = i.next;
      } while (i !== null && i.face === e);
      return s;
    }
  }
  // Computes a chain of half edges in CCW order called the 'horizon'.
  // For an edge to be part of the horizon it must join a face that can see
  // 'eyePoint' and a face that cannot see 'eyePoint'.
  computeHorizon(s, t, e, i) {
    this.deleteFaceVertices(e), e.mark = Er;
    let o;
    t === null ? o = t = e.getEdge(0) : o = t.next;
    do {
      const n = o.twin, r = n.face;
      r.mark === ms && (r.distanceToPoint(s) > this.tolerance ? this.computeHorizon(s, n, r, i) : i.push(o)), o = o.next;
    } while (o !== t);
    return this;
  }
  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order
  addAdjoiningFace(s, t) {
    const e = Rt.create(s, t.tail(), t.head());
    return this.faces.push(e), e.getEdge(-1).setTwin(t.twin), e.getEdge(0);
  }
  //  Adds 'horizon.length' faces to the hull, each face will be linked with the
  //  horizon opposite face and the face on the left/right
  addNewFaces(s, t) {
    this.newFaces = [];
    let e = null, i = null;
    for (let o = 0; o < t.length; o++) {
      const n = t[o], r = this.addAdjoiningFace(s, n);
      e === null ? e = r : r.next.setTwin(i), this.newFaces.push(r.face), i = r;
    }
    return e.next.setTwin(i), this;
  }
  // Adds a vertex to the hull
  addVertexToHull(s) {
    const t = [];
    return this.unassigned.clear(), this.removeVertexFromFace(s, s.face), this.computeHorizon(s.point, null, s.face, t), this.addNewFaces(s, t), this.resolveUnassignedPoints(this.newFaces), this;
  }
  cleanup() {
    return this.assigned.clear(), this.unassigned.clear(), this.newFaces = [], this;
  }
  compute() {
    let s;
    for (this.computeInitialHull(); (s = this.nextVertexToAdd()) !== void 0; )
      this.addVertexToHull(s);
    return this.reindexFaces(), this.cleanup(), this;
  }
};
var Rt = class _Rt {
  constructor() {
    this.normal = new Vector3(), this.midpoint = new Vector3(), this.area = 0, this.constant = 0, this.outside = null, this.mark = ms, this.edge = null;
  }
  static create(s, t, e) {
    const i = new _Rt(), o = new Ks(s, i), n = new Ks(t, i), r = new Ks(e, i);
    return o.next = r.prev = n, n.next = o.prev = r, r.next = n.prev = o, i.edge = o, i.compute();
  }
  getEdge(s) {
    let t = this.edge;
    for (; s > 0; )
      t = t.next, s--;
    for (; s < 0; )
      t = t.prev, s++;
    return t;
  }
  compute() {
    const s = this.edge.tail(), t = this.edge.head(), e = this.edge.next.head();
    return ls.set(s.point, t.point, e.point), ls.getNormal(this.normal), ls.getMidpoint(this.midpoint), this.area = ls.getArea(), this.constant = this.normal.dot(this.midpoint), this;
  }
  distanceToPoint(s) {
    return this.normal.dot(s) - this.constant;
  }
};
var Ks = class {
  constructor(s, t) {
    this.vertex = s, this.prev = null, this.next = null, this.twin = null, this.face = t;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const s = this.head(), t = this.tail();
    return t !== null ? t.point.distanceTo(s.point) : -1;
  }
  lengthSquared() {
    const s = this.head(), t = this.tail();
    return t !== null ? t.point.distanceToSquared(s.point) : -1;
  }
  setTwin(s) {
    return this.twin = s, s.twin = this, this;
  }
};
var Ir = class {
  constructor(s) {
    this.point = s, this.prev = null, this.next = null, this.face = null;
  }
};
var en = class {
  constructor() {
    this.head = null, this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    return this.head = this.tail = null, this;
  }
  // Inserts a vertex before the target vertex
  insertBefore(s, t) {
    return t.prev = s.prev, t.next = s, t.prev === null ? this.head = t : t.prev.next = t, s.prev = t, this;
  }
  // Inserts a vertex after the target vertex
  insertAfter(s, t) {
    return t.prev = s, t.next = s.next, t.next === null ? this.tail = t : t.next.prev = t, s.next = t, this;
  }
  // Appends a vertex to the end of the linked list
  append(s) {
    return this.head === null ? this.head = s : this.tail.next = s, s.prev = this.tail, s.next = null, this.tail = s, this;
  }
  // Appends a chain of vertices where 'vertex' is the head.
  appendChain(s) {
    for (this.head === null ? this.head = s : this.tail.next = s, s.prev = this.tail; s.next !== null; )
      s = s.next;
    return this.tail = s, this;
  }
  // Removes a vertex from the linked list
  remove(s) {
    return s.prev === null ? this.head = s.next : s.prev.next = s.next, s.next === null ? this.tail = s.prev : s.next.prev = s.prev, this;
  }
  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b
  removeSubList(s, t) {
    return s.prev === null ? this.head = t.next : s.prev.next = t.next, t.next === null ? this.tail = s.prev : t.next.prev = s.prev, this;
  }
  isEmpty() {
    return this.head === null;
  }
};
var Ii = [2, 2, 1];
var fi = [1, 0, 0];
function Nt(l, s) {
  return l * 3 + s;
}
function fr(l) {
  const s = l.elements;
  let t = 0;
  for (let e = 0; e < 9; e++)
    t += s[e] * s[e];
  return Math.sqrt(t);
}
function pr(l) {
  const s = l.elements;
  let t = 0;
  for (let e = 0; e < 3; e++) {
    const i = s[Nt(Ii[e], fi[e])];
    t += 2 * i * i;
  }
  return Math.sqrt(t);
}
function Cr(l, s) {
  let t = 0, e = 1;
  const i = l.elements;
  for (let c = 0; c < 3; c++) {
    const h = Math.abs(i[Nt(Ii[c], fi[c])]);
    h > t && (t = h, e = c);
  }
  let o = 1, n = 0;
  const r = fi[e], a = Ii[e];
  if (Math.abs(i[Nt(a, r)]) > Number.EPSILON) {
    const c = i[Nt(a, a)], h = i[Nt(r, r)], d = i[Nt(a, r)], E = (c - h) / 2 / d;
    let u;
    E < 0 ? u = -1 / (-E + Math.sqrt(1 + E * E)) : u = 1 / (E + Math.sqrt(1 + E * E)), o = 1 / Math.sqrt(1 + u * u), n = u * o;
  }
  return s.identity(), s.elements[Nt(r, r)] = o, s.elements[Nt(a, a)] = o, s.elements[Nt(a, r)] = n, s.elements[Nt(r, a)] = -n, s;
}
function Tr(l, s) {
  let t = 0, e = 0;
  const i = 10;
  s.unitary.identity(), s.diagonal.copy(l);
  const o = s.unitary, n = s.diagonal, r = new Matrix3(), a = new Matrix3(), c = Number.EPSILON * fr(n);
  for (; e < i && pr(n) > c; )
    Cr(n, r), a.copy(r).transpose(), n.multiply(r), n.premultiply(a), o.multiply(r), ++t > 2 && (e++, t = 0);
  return s;
}
function mr(l) {
  const s = [];
  for (let it = 0; it < l.length - 2; it += 3) {
    const Xt = l[it], J = l[it + 1], $t = l[it + 2];
    s.push(new Vector3(Xt, J, $t));
  }
  const t = new ur();
  t.setFromPoints(s);
  const e = {
    unitary: new Matrix3(),
    diagonal: new Matrix3()
  }, i = t.faces, o = [], n = [];
  for (let it = 0, Xt = i.length; it < Xt; it++) {
    const J = i[it];
    let $t = J.edge;
    o.length = 0;
    do
      o.push($t), $t = $t.next;
    while ($t !== J.edge);
    const Hn = o.length - 2;
    for (let Xe = 1, Wn = Hn; Xe <= Wn; Xe++) {
      const bs = o[0].vertex, vs = o[Xe + 0].vertex, Bs = o[Xe + 1].vertex;
      n.push(bs.point.x, bs.point.y, bs.point.z), n.push(vs.point.x, vs.point.y, vs.point.z), n.push(Bs.point.x, Bs.point.y, Bs.point.z);
    }
  }
  const r = new Vector3(), a = new Vector3(), c = new Vector3(), h = new Vector3(), d = new Vector3(), E = new Vector3(), u = new Vector3(), f = new Vector3();
  let T = 0, R = 0, C = 0, A = 0, F = 0, p = 0, m = 0;
  for (let it = 0, Xt = n.length; it < Xt; it += 9) {
    r.fromArray(n, it), a.fromArray(n, it + 3), c.fromArray(n, it + 6), u.set(0, 0, 0), u.add(r).add(a).add(c).divideScalar(3), h.subVectors(a, r), d.subVectors(c, r);
    const J = E.crossVectors(h, d).length() / 2;
    f.add(E.copy(u).multiplyScalar(J)), T += J, R += (9 * u.x * u.x + r.x * r.x + a.x * a.x + c.x * c.x) * (J / 12), C += (9 * u.x * u.y + r.x * r.y + a.x * a.y + c.x * c.y) * (J / 12), A += (9 * u.x * u.z + r.x * r.z + a.x * a.z + c.x * c.z) * (J / 12), F += (9 * u.y * u.y + r.y * r.y + a.y * a.y + c.y * c.y) * (J / 12), p += (9 * u.y * u.z + r.y * r.z + a.y * a.z + c.y * c.z) * (J / 12), m += (9 * u.z * u.z + r.z * r.z + a.z * a.z + c.z * c.z) * (J / 12);
  }
  f.divideScalar(T), R /= T, C /= T, A /= T, F /= T, p /= T, m /= T, R -= f.x * f.x, C -= f.x * f.y, A -= f.x * f.z, F -= f.y * f.y, p -= f.y * f.z, m -= f.z * f.z;
  const g = new Matrix3();
  g.elements[0] = R, g.elements[1] = C, g.elements[2] = A, g.elements[3] = C, g.elements[4] = F, g.elements[5] = p, g.elements[6] = A, g.elements[7] = p, g.elements[8] = m, Tr(g, e);
  const S = e.unitary, _ = new Vector3(), N = new Vector3(), y = new Vector3();
  S.extractBasis(_, N, y);
  let w = -1 / 0, L = -1 / 0, U = -1 / 0, b = 1 / 0, B = 1 / 0, H = 1 / 0;
  for (let it = 0, Xt = s.length; it < Xt; it++) {
    const J = s[it];
    w = Math.max(_.dot(J), w), L = Math.max(N.dot(J), L), U = Math.max(y.dot(J), U), b = Math.min(_.dot(J), b), B = Math.min(N.dot(J), B), H = Math.min(y.dot(J), H);
  }
  _.multiplyScalar(0.5 * (b + w)), N.multiplyScalar(0.5 * (B + L)), y.multiplyScalar(0.5 * (H + U));
  const q = new Vector3(), st = new Vector3(), Q = new Matrix3();
  q.add(_).add(N).add(y), st.x = w - b, st.y = L - B, st.z = U - H, st.multiplyScalar(0.5), Q.copy(S);
  const { x: Ht, y: Wt, z: kt } = st, ke2 = new Matrix4();
  ke2.makeScale(Ht * 2, Wt * 2, kt * 2);
  const Te = new Matrix4();
  Te.makeTranslation(-Ht, -Wt, -kt);
  const Li = new Matrix4();
  Li.makeTranslation(q.x, q.y, q.z);
  const Mi = new Matrix4();
  Mi.setFromMatrix3(Q);
  const me = new Matrix4();
  return me.multiply(Li), me.multiply(Mi), me.multiply(Te), me.multiply(ke2), { center: q, halfSizes: st, rotation: Q, transformation: me };
}
function Rr(l, s, t) {
  const e = [
    l[0] - s[0],
    l[1] - s[1],
    l[2] - s[2]
  ];
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] > 0;
}
var sn = class {
  static isTransparent(s) {
    return s.transparent && s.opacity < 1;
  }
};
var $ = class $2 {
  // Copied from three.js source
  // Original source: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  static create() {
    const s = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
    return `${$2._lut[s & 255] + $2._lut[s >> 8 & 255] + $2._lut[s >> 16 & 255] + $2._lut[s >> 24 & 255]}-${$2._lut[t & 255]}${$2._lut[t >> 8 & 255]}-${$2._lut[t >> 16 & 15 | 64]}${$2._lut[t >> 24 & 255]}-${$2._lut[e & 63 | 128]}${$2._lut[e >> 8 & 255]}-${$2._lut[e >> 16 & 255]}${$2._lut[e >> 24 & 255]}${$2._lut[i & 255]}${$2._lut[i >> 8 & 255]}${$2._lut[i >> 16 & 255]}${$2._lut[i >> 24 & 255]}`.toLowerCase();
  }
  static validate(s) {
    if (!$2._pattern.test(s))
      throw new Error(
        `${s} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`
      );
  }
};
I($, "_pattern", /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/), // prettier-ignore
I($, "_lut", [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff"
]);
var ze = $;
var sa = class extends et {
  constructor(t, e) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "onVertexFound", new D());
    I(this, "onVertexLost", new D());
    I(this, "onEnabled", new D());
    I(this, "components");
    I(this, "workingPlane", null);
    I(this, "_pickedPoint", null);
    I(this, "_config");
    I(this, "_enabled", false);
    this.components = t, this.config = {
      snapDistance: 0.25,
      showOnlyVertex: false,
      ...e
    }, this.enabled = false;
  }
  /**
   * Sets the enabled state of the VertexPicker.
   * When enabled, the VertexPicker will actively search for vertices in the 3D scene.
   * When disabled, the VertexPicker will stop searching for vertices and reset the picked point.
   *
   * @param value - The new enabled state.
   */
  set enabled(t) {
    this._enabled = t, t || (this._pickedPoint = null), this.onEnabled.trigger(t);
  }
  /**
   * Gets the current enabled state of the VertexPicker.
   *
   * @returns The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Sets the configuration for the VertexPicker component.
   *
   * @param value - A Partial object containing the configuration properties to update.
   * The properties not provided in the value object will retain their current values.
   *
   * @example
   * ```typescript
   * vertexPicker.config = {
   *   snapDistance: 0.5,
   *   showOnlyVertex: true,
   * };
   * ```
   */
  set config(t) {
    this._config = { ...this._config, ...t };
  }
  /**
   * Gets the current configuration for the VertexPicker component.
   *
   * @returns A copy of the current VertexPickerConfig object.
   *
   * @example
   * ```typescript
   * const currentConfig = vertexPicker.config;
   * console.log(currentConfig.snapDistance); // Output: 0.25
   * ```
   */
  get config() {
    return this._config;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onVertexFound.reset(), this.onVertexLost.reset(), this.components = null, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Performs the vertex picking operation based on the current state of the VertexPicker.
   *
   * @param world - The World instance to use for raycasting.
   *
   * @returns The current picked point, or null if no point is picked.
   *
   * @remarks
   * This method checks if the VertexPicker is enabled. If not, it returns the current picked point.
   * If enabled, it performs raycasting to find the closest intersecting object.
   * It then determines the closest vertex or point on the face, based on the configuration settings.
   * If the picked point is on the working plane (if defined), it triggers the `onVertexFound` event and updates the `pickedPoint`.
   * If the picked point is not on the working plane, it resets the `pickedPoint`.
   * If no intersecting object is found, it triggers the `onVertexLost` event and resets the `pickedPoint`.
   */
  get(t) {
    if (!this.enabled)
      return this._pickedPoint;
    const o = this.components.get(He).get(t).castRay();
    if (!o)
      return this._pickedPoint !== null && (this.onVertexLost.trigger(), this._pickedPoint = null), this._pickedPoint;
    const n = this.getClosestVertex(o);
    return n ? (this.workingPlane ? Math.abs(this.workingPlane.distanceToPoint(n)) < 1e-3 : true) ? ((this._pickedPoint === null || !this._pickedPoint.equals(n)) && (this._pickedPoint = n.clone(), this.onVertexFound.trigger(this._pickedPoint)), this._pickedPoint) : (this._pickedPoint = null, this._pickedPoint) : (this._pickedPoint !== null && (this.onVertexLost.trigger(), this._pickedPoint = null), this._pickedPoint);
  }
  getClosestVertex(t) {
    let e = new Vector3(), i = false, o = Number.MAX_SAFE_INTEGER;
    const n = this.getVertices(t);
    if (n === null)
      return null;
    for (const r of n) {
      if (!r)
        continue;
      const a = t.point.distanceTo(r);
      a > o || a > this._config.snapDistance || (i = true, e = r, o = t.point.distanceTo(r));
    }
    return i ? e : this.config.showOnlyVertex ? null : t.point;
  }
  getVertices(t) {
    const e = t.object;
    if (!t.face || !e)
      return null;
    const i = e.geometry, o = new Matrix4(), { instanceId: n } = t, r = n !== void 0, a = e instanceof InstancedMesh;
    return a && r && e.getMatrixAt(n, o), [
      this.getVertex(t.face.a, i),
      this.getVertex(t.face.b, i),
      this.getVertex(t.face.c, i)
    ].map((c) => (c && (a && r && c.applyMatrix4(o), c.applyMatrix4(e.matrixWorld)), c));
  }
  getVertex(t, e) {
    if (t === void 0)
      return null;
    const i = e.attributes.position;
    return new Vector3(
      i.getX(t),
      i.getY(t),
      i.getZ(t)
    );
  }
};
var Fs = class Fs2 {
  constructor() {
    I(this, "onDisposed", new D());
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "enabled", false);
    I(this, "_clock");
    I(this, "update", () => {
      if (!this.enabled)
        return;
      const s = this._clock.getDelta();
      for (const [t, e] of this.list)
        e.enabled && e.isUpdateable() && e.update(s);
      requestAnimationFrame(this.update);
    });
    this._clock = new Clock(), Fs2.setupBVH();
  }
  /**
   * Adds a component to the list of components.
   * Throws an error if a component with the same UUID already exists.
   *
   * @param uuid - The unique identifier of the component.
   * @param instance - The instance of the component to be added.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  add(s, t) {
    if (this.list.has(s))
      throw new Error(
        "You're trying to add a component that already exists in the components instance. Use Components.get() instead."
      );
    ze.validate(s), this.list.set(s, t);
  }
  /**
   * Retrieves a component instance by its constructor function.
   * If the component does not exist in the list, it will be created and added.
   *
   * @template U - The type of the component to retrieve.
   * @param Component - The constructor function of the component to retrieve.
   *
   * @returns The instance of the requested component.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  get(s) {
    const t = s.uuid;
    if (!this.list.has(t)) {
      const e = new s(this);
      return this.list.has(t) || this.add(t, e), e;
    }
    return this.list.get(t);
  }
  /**
   * Initializes the Components instance.
   * This method starts the animation loop, sets the enabled flag to true,
   * and calls the update method.
   *
   * @returns {void}
   */
  init() {
    this.enabled = true, this._clock.start(), this.update();
  }
  /**
   * Disposes the memory of all the components and tools of this instance of
   * the library. A memory leak will be created if:
   *
   * - An instance of the library ends up out of scope and this function isn't
   * called. This is especially relevant in Single Page Applications (React,
   * Angular, Vue, etc).
   *
   * - Any of the objects of this instance (meshes, geometries,materials, etc) is
   * referenced by a reference type (object or array).
   *
   * You can learn more about how Three.js handles memory leaks
   * [here](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
   *
   */
  dispose() {
    this.enabled = false;
    for (const [s, t] of this.list)
      t.enabled = false, t.isDisposeable() && t.dispose();
    this._clock.stop(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  static setupBVH() {
    BufferGeometry.prototype.computeBoundsTree = rr, BufferGeometry.prototype.disposeBoundsTree = ar, Mesh.prototype.raycast = or;
  }
};
I(Fs, "release", "2.1.13");
var pi = Fs;
var Ar = class {
  constructor(s) {
    I(this, "_event");
    I(this, "_position", new Vector2());
    I(this, "onDisposed", new D());
    I(this, "updateMouseInfo", (s2) => {
      this._event = s2;
    });
    this.dom = s, this.setupEvents(true);
  }
  /**
   * The real position of the mouse of the Three.js canvas.
   */
  get position() {
    if (this._event) {
      const s = this.dom.getBoundingClientRect();
      this._position.x = this.getPositionX(s, this._event), this._position.y = this.getPositionY(s, this._event);
    }
    return this._position;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  getPositionY(s, t) {
    return -((t.clientY - s.top) / (s.bottom - s.top)) * 2 + 1;
  }
  getPositionX(s, t) {
    return (t.clientX - s.left) / (s.right - s.left) * 2 - 1;
  }
  setupEvents(s) {
    s ? this.dom.addEventListener("pointermove", this.updateMouseInfo) : this.dom.removeEventListener("pointermove", this.updateMouseInfo);
  }
};
var Fr = class {
  constructor(s, t) {
    I(this, "enabled", true);
    I(this, "components");
    I(this, "onDisposed", new D());
    I(this, "mouse");
    I(this, "three", new Raycaster());
    I(this, "world");
    const e = t.renderer;
    if (!e)
      throw new Error("A renderer is needed for the raycaster to work!");
    this.world = t, this.mouse = new Ar(e.three.domElement), this.components = s;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.mouse.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Throws a ray from the camera to the mouse or touch event point and returns
   * the first item found. This also takes into account the clipping planes
   * used by the renderer.
   *
   * @param items - the [meshes](https://threejs.org/docs/#api/en/objects/Mesh)
   * to query. If not provided, it will query all the meshes stored in
   * {@link Components.meshes}.
   */
  castRay(s = Array.from(this.world.meshes)) {
    if (!this.world)
      throw new Error("A world is needed to cast rays!");
    const t = this.world.camera.three;
    return this.three.setFromCamera(this.mouse.position, t), this.intersect(s);
  }
  /**
   * Casts a ray from a given origin in a given direction and returns the first item found.
   * This method also takes into account the clipping planes used by the renderer.
   *
   * @param origin - The origin of the ray.
   * @param direction - The direction of the ray.
   * @param items - The meshes to query. If not provided, it will query all the meshes stored in {@link World.meshes}.
   * @returns The first intersection found or `null` if no intersection was found.
   */
  castRayFromVector(s, t, e = Array.from(this.world.meshes)) {
    return this.three.set(s, t), this.intersect(e);
  }
  intersect(s = Array.from(this.world.meshes)) {
    const t = this.three.intersectObjects(s), e = this.filterClippingPlanes(t);
    return e.length > 0 ? e[0] : null;
  }
  filterClippingPlanes(s) {
    if (!this.world.renderer)
      throw new Error("Renderer not found!");
    const t = this.world.renderer.three;
    if (!t.clippingPlanes)
      return s;
    const e = t.clippingPlanes;
    return s.length <= 0 || !e || (e == null ? void 0 : e.length) <= 0 ? s : s.filter(
      (i) => e.every((o) => o.distanceToPoint(i.point) > 0)
    );
  }
};
var gs = class gs2 extends et {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "onDisposed", new D());
    t.add(gs2.uuid, this);
  }
  /**
   * Retrieves a SimpleRaycaster instance for the given world.
   * If a SimpleRaycaster instance already exists for the world, it will be returned.
   * Otherwise, a new SimpleRaycaster instance will be created and added to the list.
   *
   * @param world - The world for which to retrieve or create a SimpleRaycaster instance.
   * @returns The SimpleRaycaster instance for the given world.
   */
  get(t) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const e = new Fr(this.components, t);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  /**
   * Deletes the SimpleRaycaster instance associated with the given world.
   * If a SimpleRaycaster instance exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the SimpleRaycaster instance.
   * @returns {void}
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
};
I(gs, "uuid", "d5d8bdf0-db25-4952-b951-b643af207ace");
var He = gs;
var gr = class extends _i {
  constructor() {
    super(...arguments);
    I(this, "meshes", /* @__PURE__ */ new Set());
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "onDisposed", new D());
    I(this, "isDisposing", false);
    I(this, "enabled", true);
    I(this, "uuid", ze.create());
    I(this, "name");
    I(this, "_scene");
    I(this, "_camera");
    I(this, "_renderer", null);
  }
  /**
   * Getter for the scene. If no scene is initialized, it throws an error.
   * @returns The current scene.
   */
  get scene() {
    if (!this._scene)
      throw new Error("No scene initialized!");
    return this._scene;
  }
  /**
   * Setter for the scene. It sets the current scene, adds the world to the scene's worlds set,
   * sets the current world in the scene, and triggers the scene's onWorldChanged event with the added action.
   * @param scene - The new scene to be set.
   */
  set scene(t) {
    this._scene = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the camera. If no camera is initialized, it throws an error.
   * @returns The current camera.
   */
  get camera() {
    if (!this._camera)
      throw new Error("No camera initialized!");
    return this._camera;
  }
  /**
   * Setter for the camera. It sets the current camera, adds the world to the camera's worlds set,
   * sets the current world in the camera, and triggers the camera's onWorldChanged event with the added action.
   * @param camera - The new camera to be set.
   */
  set camera(t) {
    this._camera = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the renderer.
   * @returns The current renderer or null if no renderer is set. Some worlds don't need a renderer to work (when your mail goal is not to display a 3D viewport to the user).
   */
  get renderer() {
    return this._renderer;
  }
  /**
   * Setter for the renderer. It sets the current renderer, adds the world to the renderer's worlds set,
   * sets the current world in the renderer, and triggers the renderer's onWorldChanged event with the added action.
   * If a new renderer is set, it also triggers the onWorldChanged event with the removed action for the old renderer.
   * @param renderer - The new renderer to be set or null to remove the current renderer.
   */
  set renderer(t) {
    this._renderer = t, t && (t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" }));
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (!this._scene || !this._camera || (this.scene.currentWorld = this, this.camera.currentWorld = this, this.renderer && (this.renderer.currentWorld = this), this.onBeforeUpdate.trigger(), this.scene.isUpdateable() && this.scene.update(t), this.camera.isUpdateable() && this.camera.update(t), this.renderer && this.renderer.update(t), this.onAfterUpdate.trigger()));
  }
  /** {@link Disposable.dispose} */
  dispose(t = true) {
    if (this.enabled = false, this.isDisposing = true, this.scene.onWorldChanged.trigger({ world: this, action: "removed" }), this.camera.onWorldChanged.trigger({ world: this, action: "removed" }), this.renderer && this.renderer.onWorldChanged.trigger({ world: this, action: "removed" }), t) {
      const e = this.components.get(zt);
      this.scene.dispose(), this.camera.isDisposeable() && this.camera.dispose(), this.renderer && this.renderer.dispose();
      for (const i of this.meshes)
        e.destroy(i);
      this.meshes.clear();
    }
    this._scene = null, this._camera = null, this._renderer = null, this.onDisposed.trigger();
  }
};
var ia = class extends hr {
  constructor(t) {
    super(t);
    I(this, "isSetup", false);
    I(this, "three");
    I(this, "onSetup", new D());
    I(this, "config", {
      directionalLight: {
        color: new Color("white"),
        intensity: 1.5,
        position: new Vector3(5, 10, 3)
      },
      ambientLight: {
        color: new Color("white"),
        intensity: 1
      }
    });
    this.three = new Scene(), this.three.background = new Color(2107698);
  }
  /** {@link Configurable.setup} */
  setup(t) {
    this.config = { ...this.config, ...t };
    const e = new DirectionalLight(
      this.config.directionalLight.color,
      this.config.directionalLight.intensity
    );
    e.position.copy(this.config.directionalLight.position);
    const i = new AmbientLight(
      this.config.ambientLight.color,
      this.config.ambientLight.intensity
    );
    this.three.add(e, i), this.isSetup = true, this.onSetup.trigger(this);
  }
};
var na = class extends lr {
  /**
   * Constructor for the SimpleRenderer class.
   *
   * @param components - The components instance.
   * @param container - The HTML container where the THREE.js canvas will be rendered.
   * @param parameters - Optional parameters for the THREE.js WebGLRenderer.
   */
  constructor(t, e, i) {
    super(t);
    I(this, "enabled", true);
    I(this, "container");
    I(this, "three");
    I(this, "_canvas");
    I(this, "_parameters");
    I(this, "_resizeObserver", null);
    I(this, "onContainerUpdated", new D());
    I(this, "_resizing", false);
    I(this, "resize", (t2) => {
      if (this._resizing)
        return;
      this._resizing = true, this.onContainerUpdated.trigger();
      const e2 = t2 ? t2.x : this.container.clientWidth, i2 = t2 ? t2.y : this.container.clientHeight;
      this.three.setSize(e2, i2), this.onResize.trigger(new Vector2(e2, i2)), this._resizing = false;
    });
    I(this, "resizeEvent", () => {
      this.resize();
    });
    I(this, "onContextLost", (t2) => {
      t2.preventDefault(), this.enabled = false;
    });
    I(this, "onContextBack", () => {
      this.three.setRenderTarget(null), this.three.dispose(), this.three = new WebGLRenderer({
        canvas: this._canvas,
        antialias: true,
        alpha: true,
        ...this._parameters
      }), this.enabled = true;
    });
    this.container = e, this._parameters = i, this.three = new WebGLRenderer({
      antialias: true,
      alpha: true,
      ...i
    }), this.three.setPixelRatio(Math.min(window.devicePixelRatio, 2)), this.setupRenderer(), this.setupEvents(true), this.resize(), this._canvas = this.three.domElement;
    const o = this.three.getContext(), { canvas: n } = o;
    n.addEventListener("webglcontextlost", this.onContextLost, false), n.addEventListener("webglcontextrestored", this.onContextBack, false);
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger(this);
    const t = this.currentWorld.scene.three, e = this.currentWorld.camera.three;
    this.three.render(t, e), this.onAfterUpdate.trigger(this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.setupEvents(false), this.three.domElement.remove(), this.three.dispose(), this.onResize.reset(), this.onAfterUpdate.reset(), this.onBeforeUpdate.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /** {@link Resizeable.getSize}. */
  getSize() {
    return new Vector2(
      this.three.domElement.clientWidth,
      this.three.domElement.clientHeight
    );
  }
  /**
   * Sets up and manages the event listeners for the renderer.
   *
   * @param active - A boolean indicating whether to activate or deactivate the event listeners.
   *
   * @throws Will throw an error if the renderer does not have an HTML container.
   */
  setupEvents(t) {
    const e = this.three.domElement.parentElement;
    if (!e)
      throw new Error("This renderer needs to have an HTML container!");
    this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null), window.removeEventListener("resize", this.resizeEvent), t && (this._resizeObserver = new ResizeObserver(this.resizeEvent), this._resizeObserver.observe(e), window.addEventListener("resize", this.resizeEvent));
  }
  setupRenderer() {
    this.three.localClippingEnabled = true, this.container && this.container.appendChild(this.three.domElement), this.onContainerUpdated.trigger();
  }
};
var V = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var P = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
});
var le2 = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function Zt(l) {
  return l.isPerspectiveCamera;
}
function bt(l) {
  return l.isOrthographicCamera;
}
var he = Math.PI * 2;
var nn = Math.PI / 2;
var xn = 1e-5;
var Ne = Math.PI / 180;
function mt(l, s, t) {
  return Math.max(s, Math.min(t, l));
}
function X(l, s = xn) {
  return Math.abs(l) < s;
}
function W(l, s, t = xn) {
  return X(l - s, t);
}
function on(l, s) {
  return Math.round(l / s) * s;
}
function Pe(l) {
  return isFinite(l) ? l : l < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function ye(l) {
  return Math.abs(l) < Number.MAX_VALUE ? l : l * (1 / 0);
}
function hs(l, s, t, e, i = 1 / 0, o) {
  e = Math.max(1e-4, e);
  const n = 2 / e, r = n * o, a = 1 / (1 + r + 0.48 * r * r + 0.235 * r * r * r);
  let c = l - s;
  const h = s, d = i * e;
  c = mt(c, -d, d), s = l - c;
  const E = (t.value + n * c) * o;
  t.value = (t.value - n * E) * a;
  let u = s + (c + E) * a;
  return h - l > 0 == u > h && (u = h, t.value = (u - h) / o), u;
}
function rn(l, s, t, e, i = 1 / 0, o, n) {
  e = Math.max(1e-4, e);
  const r = 2 / e, a = r * o, c = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
  let h = s.x, d = s.y, E = s.z, u = l.x - h, f = l.y - d, T = l.z - E;
  const R = h, C = d, A = E, F = i * e, p = F * F, m = u * u + f * f + T * T;
  if (m > p) {
    const B = Math.sqrt(m);
    u = u / B * F, f = f / B * F, T = T / B * F;
  }
  h = l.x - u, d = l.y - f, E = l.z - T;
  const g = (t.x + r * u) * o, S = (t.y + r * f) * o, _ = (t.z + r * T) * o;
  t.x = (t.x - r * g) * c, t.y = (t.y - r * S) * c, t.z = (t.z - r * _) * c, n.x = h + (u + g) * c, n.y = d + (f + S) * c, n.z = E + (T + _) * c;
  const N = R - l.x, y = C - l.y, w = A - l.z, L = n.x - R, U = n.y - C, b = n.z - A;
  return N * L + y * U + w * b > 0 && (n.x = R, n.y = C, n.z = A, t.x = (n.x - R) / o, t.y = (n.y - C) / o, t.z = (n.z - A) / o), n;
}
function $s(l, s) {
  s.set(0, 0), l.forEach((t) => {
    s.x += t.clientX, s.y += t.clientY;
  }), s.x /= l.length, s.y /= l.length;
}
function Js(l, s) {
  return bt(l) ? (console.warn(`${s} is not supported in OrthographicCamera`), true) : false;
}
var Or = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(s, t) {
    const e = this._listeners;
    e[s] === void 0 && (e[s] = []), e[s].indexOf(t) === -1 && e[s].push(t);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(s, t) {
    const e = this._listeners;
    return e[s] !== void 0 && e[s].indexOf(t) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(s, t) {
    const i = this._listeners[s];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(s) {
    if (!s) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[s]) && (this._listeners[s].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(s) {
    const e = this._listeners[s.type];
    if (e !== void 0) {
      s.target = this;
      const i = e.slice(0);
      for (let o = 0, n = i.length; o < n; o++)
        i[o].call(this, s);
    }
  }
};
var Sr = "2.7.3";
var Es = 1 / 8;
var bn = typeof window < "u";
var _r = bn && /Mac/.test(navigator.platform);
var Nr = !(bn && "PointerEvent" in window);
var Y;
var an;
var ds;
var ti;
var lt;
var G;
var z;
var Ee2;
var Le;
var Ot;
var St;
var Qt;
var cn;
var ln2;
var ut;
var Me;
var de;
var hn;
var ei;
var En;
var si;
var ii;
var us;
var ot = class _ot extends Or {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(s) {
    Y = s.THREE, an = Object.freeze(new Y.Vector3(0, 0, 0)), ds = Object.freeze(new Y.Vector3(0, 1, 0)), ti = Object.freeze(new Y.Vector3(0, 0, 1)), lt = new Y.Vector2(), G = new Y.Vector3(), z = new Y.Vector3(), Ee2 = new Y.Vector3(), Le = new Y.Vector3(), Ot = new Y.Vector3(), St = new Y.Vector3(), Qt = new Y.Vector3(), cn = new Y.Vector3(), ln2 = new Y.Vector3(), ut = new Y.Spherical(), Me = new Y.Spherical(), de = new Y.Box3(), hn = new Y.Box3(), ei = new Y.Sphere(), En = new Y.Quaternion(), si = new Y.Quaternion(), ii = new Y.Matrix4(), us = new Y.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return P;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(s, t) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = false, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = false, this.truckSpeed = 2, this.dollyToCursor = false, this.dragToOffset = false, this.verticalDragToForward = false, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = true, this._state = P.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = true, this._boundaryEnclosesCamera = false, this._needsUpdate = true, this._updatedLastTime = false, this._elementRect = new DOMRect(), this._isDragging = false, this._dragNeedsUpdate = true, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._isUserControllingOffset = false, this._isUserControllingZoom = false, this._lastDollyDirection = le2.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new Y.Vector3(), this._focalOffsetVelocity = new Y.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (p, m, g) => {
      let S, _;
      if (Zt(this._camera)) {
        const N = G.copy(this._camera.position).sub(this._target), y = this._camera.getEffectiveFOV() * Ne, w = N.length() * Math.tan(y * 0.5);
        S = this.truckSpeed * p * w / this._elementRect.height, _ = this.truckSpeed * m * w / this._elementRect.height;
      } else if (bt(this._camera)) {
        const N = this._camera;
        S = p * (N.right - N.left) / N.zoom / this._elementRect.width, _ = m * (N.top - N.bottom) / N.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (g ? this.setFocalOffset(this._focalOffsetEnd.x + S, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(S, 0, true), this.forward(-_, true)) : g ? this.setFocalOffset(this._focalOffsetEnd.x + S, this._focalOffsetEnd.y + _, this._focalOffsetEnd.z, true) : this.truck(S, _, true);
    }, this._rotateInternal = (p, m) => {
      const g = he * this.azimuthRotateSpeed * p / this._elementRect.height, S = he * this.polarRotateSpeed * m / this._elementRect.height;
      this.rotate(g, S, true);
    }, this._dollyInternal = (p, m, g) => {
      const S = Math.pow(0.95, -p * this.dollySpeed), _ = this._sphericalEnd.radius, N = this._sphericalEnd.radius * S, y = mt(N, this.minDistance, this.maxDistance), w = y - N;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(N, true) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(w, true), this._dollyToNoClamp(y, true)) : this._dollyToNoClamp(y, true), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? N : y) - _, this._dollyControlCoord.set(m, g)), this._lastDollyDirection = Math.sign(-p);
    }, this._zoomInternal = (p, m, g) => {
      const S = Math.pow(0.95, p * this.dollySpeed), _ = this._zoom, N = this._zoom * S;
      this.zoomTo(N, true), this.dollyToCursor && (this._changedZoom += N - _, this._dollyControlCoord.set(m, g));
    }, typeof Y > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = s, this._yAxisUpSpace = new Y.Quaternion().setFromUnitVectors(this._camera.up, ds), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = P.NONE, this._target = new Y.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new Y.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new Y.Spherical().setFromVector3(G.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new Y.Vector3(),
      new Y.Vector3(),
      new Y.Vector3(),
      new Y.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new Y.Box3(new Y.Vector3(-1 / 0, -1 / 0, -1 / 0), new Y.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new Y.Vector2(), this.mouseButtons = {
      left: P.ROTATE,
      middle: P.DOLLY,
      right: P.TRUCK,
      wheel: Zt(this._camera) ? P.DOLLY : bt(this._camera) ? P.ZOOM : P.NONE
    }, this.touches = {
      one: P.TOUCH_ROTATE,
      two: Zt(this._camera) ? P.TOUCH_DOLLY_TRUCK : bt(this._camera) ? P.TOUCH_ZOOM_TRUCK : P.NONE,
      three: P.TOUCH_TRUCK
    };
    const e = new Y.Vector2(), i = new Y.Vector2(), o = new Y.Vector2(), n = (p) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const S = this._domElement.getBoundingClientRect(), _ = p.clientX / S.width, N = p.clientY / S.height;
        if (_ < this._interactiveArea.left || _ > this._interactiveArea.right || N < this._interactiveArea.top || N > this._interactiveArea.bottom)
          return;
      }
      const m = p.pointerType !== "mouse" ? null : (p.buttons & V.LEFT) === V.LEFT ? V.LEFT : (p.buttons & V.MIDDLE) === V.MIDDLE ? V.MIDDLE : (p.buttons & V.RIGHT) === V.RIGHT ? V.RIGHT : null;
      if (m !== null) {
        const S = this._findPointerByMouseButton(m);
        S && this._disposePointer(S);
      }
      if ((p.buttons & V.LEFT) === V.LEFT && this._lockedPointer)
        return;
      const g = {
        pointerId: p.pointerId,
        clientX: p.clientX,
        clientY: p.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: m
      };
      this._activePointers.push(g), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", h), this._isDragging = true, T(p);
    }, r = (p) => {
      if (!this._enabled || !this._domElement || this._lockedPointer)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const S = this._domElement.getBoundingClientRect(), _ = p.clientX / S.width, N = p.clientY / S.height;
        if (_ < this._interactiveArea.left || _ > this._interactiveArea.right || N < this._interactiveArea.top || N > this._interactiveArea.bottom)
          return;
      }
      const m = (p.buttons & V.LEFT) === V.LEFT ? V.LEFT : (p.buttons & V.MIDDLE) === V.MIDDLE ? V.MIDDLE : (p.buttons & V.RIGHT) === V.RIGHT ? V.RIGHT : null;
      if (m !== null) {
        const S = this._findPointerByMouseButton(m);
        S && this._disposePointer(S);
      }
      const g = {
        pointerId: 1,
        clientX: p.clientX,
        clientY: p.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: (p.buttons & V.LEFT) === V.LEFT ? V.LEFT : (p.buttons & V.MIDDLE) === V.LEFT ? V.MIDDLE : (p.buttons & V.RIGHT) === V.LEFT ? V.RIGHT : null
      };
      this._activePointers.push(g), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("mouseup", d), this._domElement.ownerDocument.addEventListener("mousemove", c), this._domElement.ownerDocument.addEventListener("mouseup", d), this._isDragging = true, T(p);
    }, a = (p) => {
      p.cancelable && p.preventDefault();
      const m = p.pointerId, g = this._lockedPointer || this._findPointerById(m);
      if (g) {
        if (g.clientX = p.clientX, g.clientY = p.clientY, g.deltaX = p.movementX, g.deltaY = p.movementY, this._state = 0, p.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (p.buttons & V.LEFT) === V.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (p.buttons & V.MIDDLE) === V.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (p.buttons & V.RIGHT) === V.RIGHT && (this._state = this._state | this.mouseButtons.right);
        R();
      }
    }, c = (p) => {
      const m = this._lockedPointer || this._findPointerById(1);
      m && (m.clientX = p.clientX, m.clientY = p.clientY, m.deltaX = p.movementX, m.deltaY = p.movementY, this._state = 0, (this._lockedPointer || (p.buttons & V.LEFT) === V.LEFT) && (this._state = this._state | this.mouseButtons.left), (p.buttons & V.MIDDLE) === V.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (p.buttons & V.RIGHT) === V.RIGHT && (this._state = this._state | this.mouseButtons.right), R());
    }, h = (p) => {
      const m = this._findPointerById(p.pointerId);
      if (!(m && m === this._lockedPointer)) {
        if (m && this._disposePointer(m), p.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = P.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = P.NONE;
        C();
      }
    }, d = () => {
      const p = this._findPointerById(1);
      p && p === this._lockedPointer || (p && this._disposePointer(p), this._state = P.NONE, C());
    };
    let E = -1;
    const u = (p) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === P.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const N = this._domElement.getBoundingClientRect(), y = p.clientX / N.width, w = p.clientY / N.height;
        if (y < this._interactiveArea.left || y > this._interactiveArea.right || w < this._interactiveArea.top || w > this._interactiveArea.bottom)
          return;
      }
      if (p.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === P.ROTATE || this.mouseButtons.wheel === P.TRUCK) {
        const N = performance.now();
        E - N < 1e3 && this._getClientRect(this._elementRect), E = N;
      }
      const m = _r ? -1 : -3, g = p.deltaMode === 1 ? p.deltaY / m : p.deltaY / (m * 10), S = this.dollyToCursor ? (p.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, _ = this.dollyToCursor ? (p.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case P.ROTATE: {
          this._rotateInternal(p.deltaX, p.deltaY), this._isUserControllingRotate = true;
          break;
        }
        case P.TRUCK: {
          this._truckInternal(p.deltaX, p.deltaY, false), this._isUserControllingTruck = true;
          break;
        }
        case P.OFFSET: {
          this._truckInternal(p.deltaX, p.deltaY, true), this._isUserControllingOffset = true;
          break;
        }
        case P.DOLLY: {
          this._dollyInternal(-g, S, _), this._isUserControllingDolly = true;
          break;
        }
        case P.ZOOM: {
          this._zoomInternal(-g, S, _), this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, f = (p) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === _ot.ACTION.NONE) {
          const m = p instanceof PointerEvent ? p.pointerId : (p instanceof MouseEvent, 0), g = this._findPointerById(m);
          g && this._disposePointer(g), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("mouseup", d);
          return;
        }
        p.preventDefault();
      }
    }, T = (p) => {
      if (!this._enabled)
        return;
      if ($s(this._activePointers, lt), this._getClientRect(this._elementRect), e.copy(lt), i.copy(lt), this._activePointers.length >= 2) {
        const g = lt.x - this._activePointers[1].clientX, S = lt.y - this._activePointers[1].clientY, _ = Math.sqrt(g * g + S * S);
        o.set(0, _);
        const N = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        i.set(N, y);
      }
      if (this._state = 0, !p)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in p && p.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (p.buttons & V.LEFT) === V.LEFT && (this._state = this._state | this.mouseButtons.left), (p.buttons & V.MIDDLE) === V.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (p.buttons & V.RIGHT) === V.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & P.ROTATE) === P.ROTATE || (this._state & P.TOUCH_ROTATE) === P.TOUCH_ROTATE || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE || (this._state & P.TOUCH_ZOOM_ROTATE) === P.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & P.TRUCK) === P.TRUCK || (this._state & P.TOUCH_TRUCK) === P.TOUCH_TRUCK || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_ZOOM_TRUCK) === P.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & P.DOLLY) === P.DOLLY || (this._state & P.TOUCH_DOLLY) === P.TOUCH_DOLLY || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & P.ZOOM) === P.ZOOM || (this._state & P.TOUCH_ZOOM) === P.TOUCH_ZOOM || (this._state & P.TOUCH_ZOOM_TRUCK) === P.TOUCH_ZOOM_TRUCK || (this._state & P.TOUCH_ZOOM_OFFSET) === P.TOUCH_ZOOM_OFFSET || (this._state & P.TOUCH_ZOOM_ROTATE) === P.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & P.OFFSET) === P.OFFSET || (this._state & P.TOUCH_OFFSET) === P.TOUCH_OFFSET || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET || (this._state & P.TOUCH_ZOOM_OFFSET) === P.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, R = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false, $s(this._activePointers, lt);
      const m = this._domElement && document.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, g = m ? -m.deltaX : i.x - lt.x, S = m ? -m.deltaY : i.y - lt.y;
      if (i.copy(lt), ((this._state & P.ROTATE) === P.ROTATE || (this._state & P.TOUCH_ROTATE) === P.TOUCH_ROTATE || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE || (this._state & P.TOUCH_ZOOM_ROTATE) === P.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(g, S), this._isUserControllingRotate = true), (this._state & P.DOLLY) === P.DOLLY || (this._state & P.ZOOM) === P.ZOOM) {
        const _ = this.dollyToCursor ? (e.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, N = this.dollyToCursor ? (e.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, y = this.dollyDragInverted ? -1 : 1;
        (this._state & P.DOLLY) === P.DOLLY ? (this._dollyInternal(y * S * Es, _, N), this._isUserControllingDolly = true) : (this._zoomInternal(y * S * Es, _, N), this._isUserControllingZoom = true);
      }
      if ((this._state & P.TOUCH_DOLLY) === P.TOUCH_DOLLY || (this._state & P.TOUCH_ZOOM) === P.TOUCH_ZOOM || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_ZOOM_TRUCK) === P.TOUCH_ZOOM_TRUCK || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET || (this._state & P.TOUCH_ZOOM_OFFSET) === P.TOUCH_ZOOM_OFFSET || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE || (this._state & P.TOUCH_ZOOM_ROTATE) === P.TOUCH_ZOOM_ROTATE) {
        const _ = lt.x - this._activePointers[1].clientX, N = lt.y - this._activePointers[1].clientY, y = Math.sqrt(_ * _ + N * N), w = o.y - y;
        o.set(0, y);
        const L = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, U = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & P.TOUCH_DOLLY) === P.TOUCH_DOLLY || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(w * Es, L, U), this._isUserControllingDolly = true) : (this._zoomInternal(w * Es, L, U), this._isUserControllingZoom = true);
      }
      ((this._state & P.TRUCK) === P.TRUCK || (this._state & P.TOUCH_TRUCK) === P.TOUCH_TRUCK || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_ZOOM_TRUCK) === P.TOUCH_ZOOM_TRUCK) && (this._truckInternal(g, S, false), this._isUserControllingTruck = true), ((this._state & P.OFFSET) === P.OFFSET || (this._state & P.TOUCH_OFFSET) === P.TOUCH_OFFSET || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET || (this._state & P.TOUCH_ZOOM_OFFSET) === P.TOUCH_ZOOM_OFFSET) && (this._truckInternal(g, S, true), this._isUserControllingOffset = true), this.dispatchEvent({ type: "control" });
    }, C = () => {
      $s(this._activePointers, lt), i.copy(lt), this._dragNeedsUpdate = false, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = false), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.ownerDocument.removeEventListener("mouseup", d), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", A), this._domElement.ownerDocument.addEventListener("pointerlockerror", F), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", h), T());
    }, this.unlockPointer = () => {
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), document.exitPointerLock(), this.cancel(), this._domElement && (this._domElement.ownerDocument.removeEventListener("pointerlockchange", A), this._domElement.ownerDocument.removeEventListener("pointerlockerror", F));
    };
    const A = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, F = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (p) => {
      this._domElement = p, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", n), Nr && this._domElement.addEventListener("mousedown", r), this._domElement.addEventListener("pointercancel", h), this._domElement.addEventListener("wheel", u, { passive: false }), this._domElement.addEventListener("contextmenu", f);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", n), this._domElement.removeEventListener("mousedown", r), this._domElement.removeEventListener("pointercancel", h), this._domElement.removeEventListener("wheel", u, { passive: false }), this._domElement.removeEventListener("contextmenu", f), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.ownerDocument.removeEventListener("mouseup", d), this._domElement.ownerDocument.removeEventListener("pointerlockchange", A), this._domElement.ownerDocument.removeEventListener("pointerlockerror", F));
    }, this.cancel = () => {
      this._state !== P.NONE && (this._state = P.NONE, this._activePointers.length = 0, C());
    }, t && this.connect(t), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(s) {
    this._camera = s, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(s) {
    this._enabled = s, this._domElement && (s ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(s) {
    this._spherical.radius === s && this._sphericalEnd.radius === s || (this._spherical.radius = s, this._sphericalEnd.radius = s, this._needsUpdate = true);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(s) {
    this._spherical.theta === s && this._sphericalEnd.theta === s || (this._spherical.theta = s, this._sphericalEnd.theta = s, this._needsUpdate = true);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(s) {
    this._spherical.phi === s && this._sphericalEnd.phi === s || (this._spherical.phi = s, this._sphericalEnd.phi = s, this._needsUpdate = true);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(s) {
    this._boundaryEnclosesCamera = s, this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(s) {
    this._interactiveArea.width = mt(s.width, 0, 1), this._interactiveArea.height = mt(s.height, 0, 1), this._interactiveArea.x = mt(s.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = mt(s.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(s, t) {
    super.addEventListener(s, t);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(s, t) {
    super.removeEventListener(s, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(s, t, e = false) {
    return this.rotateTo(this._sphericalEnd.theta + s, this._sphericalEnd.phi + t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(s, t = false) {
    return this.rotateTo(s, this._sphericalEnd.phi, t);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(s, t = false) {
    return this.rotateTo(this._sphericalEnd.theta, s, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(s, t, e = false) {
    this._isUserControllingRotate = false;
    const i = mt(s, this.minAzimuthAngle, this.maxAzimuthAngle), o = mt(t, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = i, this._sphericalEnd.phi = o, this._sphericalEnd.makeSafe(), this._needsUpdate = true, e || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const n = !e || W(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && W(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(s, t = false) {
    return this.dollyTo(this._sphericalEnd.radius - s, t);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(s, t = false) {
    return this._isUserControllingDolly = false, this._lastDollyDirection = le2.NONE, this._changedDolly = 0, this._dollyToNoClamp(mt(s, this.minDistance, this.maxDistance), t);
  }
  _dollyToNoClamp(s, t = false) {
    const e = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const n = this._collisionTest(), r = W(n, this._spherical.radius);
      if (!(e > s) && r)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(s, n);
    } else
      this._sphericalEnd.radius = s;
    this._needsUpdate = true, t || (this._spherical.radius = this._sphericalEnd.radius);
    const o = !t || W(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(s, t = false) {
    this._targetEnd.add(this._getCameraDirection(Le).multiplyScalar(s)), t || this._target.copy(this._targetEnd);
    const e = !t || W(this._target.x, this._targetEnd.x, this.restThreshold) && W(this._target.y, this._targetEnd.y, this.restThreshold) && W(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(e);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(s, t = false) {
    return this.zoomTo(this._zoomEnd + s, t);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(s, t = false) {
    this._isUserControllingZoom = false, this._zoomEnd = mt(s, this.minZoom, this.maxZoom), this._needsUpdate = true, t || (this._zoom = this._zoomEnd);
    const e = !t || W(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(e);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(s, t, e = false) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(s, t, e);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(s, t, e = false) {
    this._camera.updateMatrix(), Ot.setFromMatrixColumn(this._camera.matrix, 0), St.setFromMatrixColumn(this._camera.matrix, 1), Ot.multiplyScalar(s), St.multiplyScalar(-t);
    const i = G.copy(Ot).add(St), o = z.copy(this._targetEnd).add(i);
    return this.moveTo(o.x, o.y, o.z, e);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(s, t = false) {
    G.setFromMatrixColumn(this._camera.matrix, 0), G.crossVectors(this._camera.up, G), G.multiplyScalar(s);
    const e = z.copy(this._targetEnd).add(G);
    return this.moveTo(e.x, e.y, e.z, t);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(s, t = false) {
    return G.copy(this._camera.up).multiplyScalar(s), this.moveTo(this._targetEnd.x + G.x, this._targetEnd.y + G.y, this._targetEnd.z + G.z, t);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(s, t, e, i = false) {
    this._isUserControllingTruck = false;
    const o = G.set(s, t, e).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, o, this.boundaryFriction), this._needsUpdate = true, i || this._target.copy(this._targetEnd);
    const n = !i || W(this._target.x, this._targetEnd.x, this.restThreshold) && W(this._target.y, this._targetEnd.y, this.restThreshold) && W(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(s, t, e, i = false) {
    const r = G.set(s, t, e).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius);
    return this.setPosition(r.x, r.y, r.z, i);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(s, t, { cover: e = false, paddingLeft: i = 0, paddingRight: o = 0, paddingBottom: n = 0, paddingTop: r = 0 } = {}) {
    const a = [], c = s.isBox3 ? de.copy(s) : de.setFromObject(s);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const h = on(this._sphericalEnd.theta, nn), d = on(this._sphericalEnd.phi, nn);
    a.push(this.rotateTo(h, d, t));
    const E = G.setFromSpherical(this._sphericalEnd).normalize(), u = En.setFromUnitVectors(E, ti), f = W(Math.abs(E.y), 1);
    f && u.multiply(si.setFromAxisAngle(ds, h)), u.multiply(this._yAxisUpSpaceInverse);
    const T = hn.makeEmpty();
    z.copy(c.min).applyQuaternion(u), T.expandByPoint(z), z.copy(c.min).setX(c.max.x).applyQuaternion(u), T.expandByPoint(z), z.copy(c.min).setY(c.max.y).applyQuaternion(u), T.expandByPoint(z), z.copy(c.max).setZ(c.min.z).applyQuaternion(u), T.expandByPoint(z), z.copy(c.min).setZ(c.max.z).applyQuaternion(u), T.expandByPoint(z), z.copy(c.max).setY(c.min.y).applyQuaternion(u), T.expandByPoint(z), z.copy(c.max).setX(c.min.x).applyQuaternion(u), T.expandByPoint(z), z.copy(c.max).applyQuaternion(u), T.expandByPoint(z), T.min.x -= i, T.min.y -= n, T.max.x += o, T.max.y += r, u.setFromUnitVectors(ti, E), f && u.premultiply(si.invert()), u.premultiply(this._yAxisUpSpace);
    const R = T.getSize(G), C = T.getCenter(z).applyQuaternion(u);
    if (Zt(this._camera)) {
      const A = this.getDistanceToFitBox(R.x, R.y, R.z, e);
      a.push(this.moveTo(C.x, C.y, C.z, t)), a.push(this.dollyTo(A, t)), a.push(this.setFocalOffset(0, 0, 0, t));
    } else if (bt(this._camera)) {
      const A = this._camera, F = A.right - A.left, p = A.top - A.bottom, m = e ? Math.max(F / R.x, p / R.y) : Math.min(F / R.x, p / R.y);
      a.push(this.moveTo(C.x, C.y, C.z, t)), a.push(this.zoomTo(m, t)), a.push(this.setFocalOffset(0, 0, 0, t));
    }
    return Promise.all(a);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(s, t) {
    const e = [], o = s instanceof Y.Sphere ? ei.copy(s) : _ot.createBoundingSphere(s, ei);
    if (e.push(this.moveTo(o.center.x, o.center.y, o.center.z, t)), Zt(this._camera)) {
      const n = this.getDistanceToFitSphere(o.radius);
      e.push(this.dollyTo(n, t));
    } else if (bt(this._camera)) {
      const n = this._camera.right - this._camera.left, r = this._camera.top - this._camera.bottom, a = 2 * o.radius, c = Math.min(n / a, r / a);
      e.push(this.zoomTo(c, t));
    }
    return e.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(e);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(s, t, e, i, o, n, r = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = le2.NONE, this._changedDolly = 0;
    const a = z.set(i, o, n), c = G.set(s, t, e);
    this._targetEnd.copy(a), this._sphericalEnd.setFromVector3(c.sub(a).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = true, r || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const h = !r || W(this._target.x, this._targetEnd.x, this.restThreshold) && W(this._target.y, this._targetEnd.y, this.restThreshold) && W(this._target.z, this._targetEnd.z, this.restThreshold) && W(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && W(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && W(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(h);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(s, t, e, i, o, n, r, a, c, h, d, E, u, f = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = le2.NONE, this._changedDolly = 0;
    const T = G.set(i, o, n), R = z.set(s, t, e);
    ut.setFromVector3(R.sub(T).applyQuaternion(this._yAxisUpSpace));
    const C = Ee2.set(h, d, E), A = z.set(r, a, c);
    Me.setFromVector3(A.sub(C).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(T.lerp(C, u));
    const F = Me.theta - ut.theta, p = Me.phi - ut.phi, m = Me.radius - ut.radius;
    this._sphericalEnd.set(ut.radius + m * u, ut.phi + p * u, ut.theta + F * u), this.normalizeRotations(), this._needsUpdate = true, f || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const g = !f || W(this._target.x, this._targetEnd.x, this.restThreshold) && W(this._target.y, this._targetEnd.y, this.restThreshold) && W(this._target.z, this._targetEnd.z, this.restThreshold) && W(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && W(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && W(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(g);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(s, t, e, i = false) {
    return this.setLookAt(s, t, e, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, i);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(s, t, e, i = false) {
    const o = this.getPosition(G), n = this.setLookAt(o.x, o.y, o.z, s, t, e, i);
    return this._sphericalEnd.phi = mt(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), n;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(s, t, e, i = false) {
    this._isUserControllingOffset = false, this._focalOffsetEnd.set(s, t, e), this._needsUpdate = true, i || this._focalOffset.copy(this._focalOffsetEnd);
    const o = !i || W(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && W(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && W(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(s, t, e) {
    this._camera.updateMatrixWorld(), Ot.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), St.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), Qt.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const i = G.set(s, t, e), o = i.distanceTo(this._camera.position), n = i.sub(this._camera.position);
    Ot.multiplyScalar(n.x), St.multiplyScalar(n.y), Qt.multiplyScalar(n.z), G.copy(Ot).add(St).add(Qt), G.z = G.z + o, this.dollyTo(o, false), this.setFocalOffset(-G.x, G.y, -G.z, false), this.moveTo(s, t, e, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(s) {
    if (!s) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = true;
      return;
    }
    this._boundary.copy(s), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(s, t, e, i) {
    if (s === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new Y.Vector4(), typeof s == "number" ? this._viewport.set(s, t, e, i) : this._viewport.copy(s);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(s, t, e, i = false) {
    if (Js(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const o = s / t, n = this._camera.getEffectiveFOV() * Ne, r = this._camera.aspect;
    return ((i ? o > r : o < r) ? t : s / r) * 0.5 / Math.tan(n * 0.5) + e * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(s) {
    if (Js(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const t = this._camera.getEffectiveFOV() * Ne, e = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, i = 1 < this._camera.aspect ? t : e;
    return s / Math.sin(i * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(s, t = true) {
    return (s && s.isVector3 ? s : new Y.Vector3()).copy(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(s, t = true) {
    return (s && s.isVector3 ? s : new Y.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(s, t = true) {
    return (s && s instanceof Y.Spherical ? s : new Y.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(s, t = true) {
    return (s && s.isVector3 ? s : new Y.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % he, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += he), this._spherical.theta += he * Math.round((this._sphericalEnd.theta - this._spherical.theta) / he);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(s = false) {
    if (!W(this._camera.up.x, this._cameraUp0.x) || !W(this._camera.up.y, this._cameraUp0.y) || !W(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const e = this.getPosition(G);
      this.updateCameraUp(), this.setPosition(e.x, e.y, e.z);
    }
    const t = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, s),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, s),
      this.zoomTo(this._zoom0, s)
    ];
    return Promise.all(t);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, ds), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const s = G.subVectors(this._target, this._camera.position).normalize(), t = z.crossVectors(s, this._camera.up);
    this._camera.up.crossVectors(t, s).normalize(), this._camera.updateMatrixWorld();
    const e = this.getPosition(G);
    this.updateCameraUp(), this.setPosition(e.x, e.y, e.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(s) {
    const t = this._sphericalEnd.theta - this._spherical.theta, e = this._sphericalEnd.phi - this._spherical.phi, i = this._sphericalEnd.radius - this._spherical.radius, o = cn.subVectors(this._targetEnd, this._target), n = ln2.subVectors(this._focalOffsetEnd, this._focalOffset), r = this._zoomEnd - this._zoom;
    if (X(t))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = hs(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, d, 1 / 0, s), this._needsUpdate = true;
    }
    if (X(e))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = hs(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, d, 1 / 0, s), this._needsUpdate = true;
    }
    if (X(i))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const d = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = hs(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, d, this.maxSpeed, s), this._needsUpdate = true;
    }
    if (X(o.x) && X(o.y) && X(o.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const d = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      rn(this._target, this._targetEnd, this._targetVelocity, d, this.maxSpeed, s, this._target), this._needsUpdate = true;
    }
    if (X(n.x) && X(n.y) && X(n.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const d = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      rn(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, d, this.maxSpeed, s, this._focalOffset), this._needsUpdate = true;
    }
    if (X(r))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const d = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = hs(this._zoom, this._zoomEnd, this._zoomVelocity, d, 1 / 0, s);
    }
    if (this.dollyToCursor) {
      if (Zt(this._camera) && this._changedDolly !== 0) {
        const d = this._spherical.radius - this._lastDistance, E = this._camera, u = this._getCameraDirection(Le), f = G.copy(u).cross(E.up).normalize();
        f.lengthSq() === 0 && (f.x = 1);
        const T = z.crossVectors(f, u), R = this._sphericalEnd.radius * Math.tan(E.getEffectiveFOV() * Ne * 0.5), A = (this._sphericalEnd.radius - d - this._sphericalEnd.radius) / this._sphericalEnd.radius, F = Ee2.copy(this._targetEnd).add(f.multiplyScalar(this._dollyControlCoord.x * R * E.aspect)).add(T.multiplyScalar(this._dollyControlCoord.y * R)), p = G.copy(this._targetEnd).lerp(F, A), m = this._lastDollyDirection === le2.IN && this._spherical.radius <= this.minDistance, g = this._lastDollyDirection === le2.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (m || g)) {
          this._sphericalEnd.radius -= d, this._spherical.radius -= d;
          const _ = z.copy(u).multiplyScalar(-d);
          p.add(_);
        }
        this._boundary.clampPoint(p, p);
        const S = z.subVectors(p, this._targetEnd);
        this._targetEnd.copy(p), this._target.add(S), this._changedDolly -= d, X(this._changedDolly) && (this._changedDolly = 0);
      } else if (bt(this._camera) && this._changedZoom !== 0) {
        const d = this._zoom - this._lastZoom, E = this._camera, u = G.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (E.near + E.far) / (E.near - E.far)).unproject(E), f = z.set(0, 0, -1).applyQuaternion(E.quaternion), T = Ee2.copy(u).add(f.multiplyScalar(-u.dot(E.up))), C = -(this._zoom - d - this._zoom) / this._zoom, A = this._getCameraDirection(Le), F = this._targetEnd.dot(A), p = G.copy(this._targetEnd).lerp(T, C), m = p.dot(A), g = A.multiplyScalar(m - F);
        p.sub(g), this._boundary.clampPoint(p, p);
        const S = z.subVectors(p, this._targetEnd);
        this._targetEnd.copy(p), this._target.add(S), this._changedZoom -= d, X(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true), this._dragNeedsUpdate = true;
    const a = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, a), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!X(this._focalOffset.x) || !X(this._focalOffset.y) || !X(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), Ot.setFromMatrixColumn(this._camera.matrix, 0), St.setFromMatrixColumn(this._camera.matrix, 1), Qt.setFromMatrixColumn(this._camera.matrix, 2), Ot.multiplyScalar(this._focalOffset.x), St.multiplyScalar(-this._focalOffset.y), Qt.multiplyScalar(this._focalOffset.z), G.copy(Ot).add(St).add(Qt), this._camera.position.add(G)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), G.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const h = this._needsUpdate;
    return h && !this._updatedLastTime ? (this._hasRested = false, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : h ? (this.dispatchEvent({ type: "update" }), X(t, this.restThreshold) && X(e, this.restThreshold) && X(i, this.restThreshold) && X(o.x, this.restThreshold) && X(o.y, this.restThreshold) && X(o.z, this.restThreshold) && X(n.x, this.restThreshold) && X(n.y, this.restThreshold) && X(n.z, this.restThreshold) && X(r, this.restThreshold) && !this._hasRested && (this._hasRested = true, this.dispatchEvent({ type: "rest" }))) : !h && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = h, this._needsUpdate = false, h;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: Pe(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: Pe(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: Pe(this.maxPolarAngle),
      minAzimuthAngle: Pe(this.minAzimuthAngle),
      maxAzimuthAngle: Pe(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: G.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(s, t = false) {
    const e = JSON.parse(s);
    this.enabled = e.enabled, this.minDistance = e.minDistance, this.maxDistance = ye(e.maxDistance), this.minZoom = e.minZoom, this.maxZoom = ye(e.maxZoom), this.minPolarAngle = e.minPolarAngle, this.maxPolarAngle = ye(e.maxPolarAngle), this.minAzimuthAngle = ye(e.minAzimuthAngle), this.maxAzimuthAngle = ye(e.maxAzimuthAngle), this.smoothTime = e.smoothTime, this.draggingSmoothTime = e.draggingSmoothTime, this.dollySpeed = e.dollySpeed, this.truckSpeed = e.truckSpeed, this.dollyToCursor = e.dollyToCursor, this.verticalDragToForward = e.verticalDragToForward, this._target0.fromArray(e.target0), this._position0.fromArray(e.position0), this._zoom0 = e.zoom0, this._focalOffset0.fromArray(e.focalOffset0), this.moveTo(e.target[0], e.target[1], e.target[2], t), ut.setFromVector3(G.fromArray(e.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(ut.theta, ut.phi, t), this.dollyTo(ut.radius, t), this.zoomTo(e.zoom, t), this.setFocalOffset(e.focalOffset[0], e.focalOffset[1], e.focalOffset[2], t), this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(s) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    s.setAttribute("data-camera-controls-version", Sr), this._addAllEventListeners(s), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(s) {
    return s.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(s) {
    return this._getTargetDirection(s).negate();
  }
  _findPointerById(s) {
    return this._activePointers.find((t) => t.pointerId === s);
  }
  _findPointerByMouseButton(s) {
    return this._activePointers.find((t) => t.mouseButton === s);
  }
  _disposePointer(s) {
    this._activePointers.splice(this._activePointers.indexOf(s), 1);
  }
  _encloseToBoundary(s, t, e) {
    const i = t.lengthSq();
    if (i === 0)
      return s;
    const o = z.copy(t).add(s), r = this._boundary.clampPoint(o, Ee2).sub(o), a = r.lengthSq();
    if (a === 0)
      return s.add(t);
    if (a === i)
      return s;
    if (e === 0)
      return s.add(t).add(r);
    {
      const c = 1 + e * a / t.dot(r);
      return s.add(z.copy(t).multiplyScalar(c)).add(r.multiplyScalar(1 - e));
    }
  }
  _updateNearPlaneCorners() {
    if (Zt(this._camera)) {
      const s = this._camera, t = s.near, e = s.getEffectiveFOV() * Ne, i = Math.tan(e * 0.5) * t, o = i * s.aspect;
      this._nearPlaneCorners[0].set(-o, -i, 0), this._nearPlaneCorners[1].set(o, -i, 0), this._nearPlaneCorners[2].set(o, i, 0), this._nearPlaneCorners[3].set(-o, i, 0);
    } else if (bt(this._camera)) {
      const s = this._camera, t = 1 / s.zoom, e = s.left * t, i = s.right * t, o = s.top * t, n = s.bottom * t;
      this._nearPlaneCorners[0].set(e, o, 0), this._nearPlaneCorners[1].set(i, o, 0), this._nearPlaneCorners[2].set(i, n, 0), this._nearPlaneCorners[3].set(e, n, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let s = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || Js(this._camera, "_collisionTest"))
      return s;
    const e = this._getTargetDirection(Le);
    ii.lookAt(an, e, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const o = z.copy(this._nearPlaneCorners[i]);
      o.applyMatrix4(ii);
      const n = Ee2.addVectors(this._target, o);
      us.set(n, e), us.far = this._spherical.radius + 1;
      const r = us.intersectObjects(this.colliderMeshes);
      r.length !== 0 && r[0].distance < s && (s = r[0].distance);
    }
    return s;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(s) {
    if (!this._domElement)
      return;
    const t = this._domElement.getBoundingClientRect();
    return s.x = t.left, s.y = t.top, this._viewport ? (s.x += this._viewport.x, s.y += t.height - this._viewport.w - this._viewport.y, s.width = this._viewport.z, s.height = this._viewport.w) : (s.width = t.width, s.height = t.height), s;
  }
  _createOnRestPromise(s) {
    return s ? Promise.resolve() : (this._hasRested = false, this.dispatchEvent({ type: "transitionstart" }), new Promise((t) => {
      const e = () => {
        this.removeEventListener("rest", e), t();
      };
      this.addEventListener("rest", e);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(s) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(s) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(s) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(s, t = new Y.Sphere()) {
    const e = t, i = e.center;
    de.makeEmpty(), s.traverseVisible((n) => {
      n.isMesh && de.expandByObject(n);
    }), de.getCenter(i);
    let o = 0;
    return s.traverseVisible((n) => {
      if (!n.isMesh)
        return;
      const r = n, a = r.geometry.clone();
      a.applyMatrix4(r.matrixWorld);
      const h = a.attributes.position;
      for (let d = 0, E = h.count; d < E; d++)
        G.fromBufferAttribute(h, d), o = Math.max(o, i.distanceToSquared(G));
    }), e.radius = Math.sqrt(o), e;
  }
};
var We = class _We extends cr {
  constructor(t) {
    super(t);
    I(this, "onBeforeUpdate", new D());
    I(this, "onAfterUpdate", new D());
    I(this, "onAspectUpdated", new D());
    I(this, "onDisposed", new D());
    I(this, "three");
    I(this, "_allControls", /* @__PURE__ */ new Map());
    I(this, "updateAspect", () => {
      var t2;
      if (!(!this.currentWorld || !this.currentWorld.renderer)) {
        if (this.three instanceof OrthographicCamera) {
          this.onAspectUpdated.trigger();
          return;
        }
        if ((t2 = this.currentWorld.renderer) != null && t2.isResizeable()) {
          const e = this.currentWorld.renderer.getSize();
          this.three.aspect = e.width / e.height, this.three.updateProjectionMatrix(), this.onAspectUpdated.trigger();
        }
      }
    });
    this.three = this.setupCamera(), this.setupEvents(true), this.onWorldChanged.add(({ action: e, world: i }) => {
      if (e === "added") {
        const o = this.newCameraControls();
        this._allControls.set(i.uuid, o);
      }
      if (e === "removed") {
        const o = this._allControls.get(i.uuid);
        o && (o.dispose(), this._allControls.delete(i.uuid));
      }
    });
  }
  /**
   * The object that controls the camera. An instance of
   * [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls).
   * Transforming the camera directly will have no effect: you need to use this
   * object to move, rotate, look at objects, etc.
   */
  get controls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    const t = this._allControls.get(this.currentWorld.uuid);
    if (!t)
      throw new Error("Controls not found!");
    return t;
  }
  /**
   * Getter for the enabled state of the camera controls.
   * If the current world is null, it returns false.
   * Otherwise, it returns the enabled state of the camera controls.
   *
   * @returns {boolean} The enabled state of the camera controls.
   */
  get enabled() {
    return this.currentWorld === null ? false : this.controls.enabled;
  }
  /**
   * Setter for the enabled state of the camera controls.
   * If the current world is not null, it sets the enabled state of the camera controls to the provided value.
   *
   * @param {boolean} enabled - The new enabled state of the camera controls.
   */
  set enabled(t) {
    this.currentWorld !== null && (this.controls.enabled = t);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.onAspectUpdated.reset(), this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.three.removeFromParent(), this.onDisposed.trigger(), this.onDisposed.reset();
    for (const [t, e] of this._allControls)
      e.dispose();
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (this.onBeforeUpdate.trigger(this), this.controls.update(t), this.onAfterUpdate.trigger(this));
  }
  setupCamera() {
    const t = window.innerWidth / window.innerHeight, e = new PerspectiveCamera(60, t, 1, 1e3);
    return e.position.set(50, 50, 50), e.lookAt(new Vector3(0, 0, 0)), e;
  }
  newCameraControls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    if (!this.currentWorld.renderer)
      throw new Error("This camera needs a renderer to work!");
    ot.install({ THREE: _We.getSubsetOfThree() });
    const { domElement: t } = this.currentWorld.renderer.three, e = new ot(this.three, t);
    return e.smoothTime = 0.2, e.dollyToCursor = true, e.infinityDolly = true, e.minDistance = 6, e;
  }
  setupEvents(t) {
    t ? window.addEventListener("resize", this.updateAspect) : window.removeEventListener("resize", this.updateAspect);
  }
  static getSubsetOfThree() {
    return {
      MOUSE,
      Vector2,
      Vector3,
      Vector4,
      Quaternion,
      Matrix4,
      Spherical,
      Box3,
      Sphere,
      Raycaster,
      MathUtils
    };
  }
};
var Os = class Os2 extends et {
  constructor(t) {
    super(t);
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "onDisposed", new D());
    I(this, "onWorldCreated", new D());
    I(this, "onWorldDeleted", new D());
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "enabled", true);
    t.add(Os2.uuid, this);
  }
  /**
   * Creates a new instance of a SimpleWorld and adds it to the list of worlds.
   *
   * @template T - The type of the scene, extending from BaseScene. Defaults to BaseScene.
   * @template U - The type of the camera, extending from BaseCamera. Defaults to BaseCamera.
   * @template S - The type of the renderer, extending from BaseRenderer. Defaults to BaseRenderer.
   *
   * @throws {Error} - Throws an error if a world with the same UUID already exists in the list.
   */
  create() {
    const t = new gr(this.components), e = t.uuid;
    if (this.list.has(e))
      throw new Error("There is already a world with this name!");
    return this.list.set(e, t), this.onWorldCreated.trigger(t), t;
  }
  /**
   * Deletes a world from the list of worlds.
   *
   * @param {World} world - The world to be deleted.
   *
   * @throws {Error} - Throws an error if the provided world is not found in the list.
   *
   * @returns {void}
   */
  delete(t) {
    if (!this.list.has(t.uuid))
      throw new Error("The provided world is not found in the list!");
    const e = t.uuid;
    this.list.delete(t.uuid), t.dispose(), this.onWorldDeleted.trigger(e);
  }
  /**
   * Disposes of the Worlds component and all its managed worlds.
   * This method sets the enabled flag to false, disposes of all worlds, clears the list,
   * and triggers the onDisposed event.
   *
   * @returns {void}
   */
  dispose() {
    this.enabled = false;
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update(t) {
    if (this.enabled)
      for (const [e, i] of this.list)
        i.update(t);
  }
};
I(Os, "uuid", "fdb61dc4-2ec1-4966-b83d-54ea795fad4a");
var Ci = Os;
var Pr = class {
  constructor(s, t, e) {
    I(this, "onDisposed", new D());
    I(this, "world");
    I(this, "components");
    I(this, "three");
    I(this, "_fade", 3);
    I(this, "updateZoom", () => {
      this.world.camera instanceof We && (this.material.uniforms.uZoom.value = this.world.camera.three.zoom);
    });
    this.world = t;
    const { color: i, size1: o, size2: n, distance: r } = e;
    this.components = s;
    const a = new PlaneGeometry(2, 2, 1, 1), c = new ShaderMaterial({
      side: DoubleSide,
      uniforms: {
        uSize1: {
          value: o
        },
        uSize2: {
          value: n
        },
        uColor: {
          value: i
        },
        uDistance: {
          value: r
        },
        uFade: {
          value: this._fade
        },
        uZoom: {
          value: 1
        }
      },
      transparent: true,
      vertexShader: `
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,
      fragmentShader: `
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,
      extensions: {
        derivatives: true
      }
    });
    this.three = new Mesh(a, c), this.three.frustumCulled = false, t.scene.three.add(this.three), this.setupEvents(true);
  }
  /** {@link Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /** {@link Hideable.visible} */
  set visible(s) {
    s ? this.world.scene.three.add(this.three) : this.three.removeFromParent();
  }
  /** The material of the grid. */
  get material() {
    return this.three.material;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  get fade() {
    return this._fade === 3;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  set fade(s) {
    this._fade = s ? 3 : 0, this.material.uniforms.uFade.value = this._fade;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.components.get(zt).destroy(this.three), this.onDisposed.trigger(), this.onDisposed.reset(), this.world = null, this.components = null;
  }
  setupEvents(s) {
    if (this.world.isDisposing || !(this.world.camera instanceof We))
      return;
    const t = this.world.camera.controls;
    s ? t.addEventListener("update", this.updateZoom) : t.removeEventListener("update", this.updateZoom);
  }
};
var Ss = class Ss2 extends et {
  constructor(t) {
    super(t);
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "config", {
      color: new Color(12303291),
      size1: 1,
      size2: 10,
      distance: 500
    });
    I(this, "onDisposed", new D());
    I(this, "enabled", true);
    t.add(Ss2.uuid, this);
  }
  /**
   * Creates a new grid for the given world.
   * Throws an error if a grid already exists for the world.
   *
   * @param world - The world to create the grid for.
   * @returns The newly created grid.
   *
   * @throws Will throw an error if a grid already exists for the given world.
   */
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a grid!");
    const e = new Pr(this.components, t, this.config);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  /**
   * Deletes the grid associated with the given world.
   * If a grid does not exist for the given world, this method does nothing.
   *
   * @param world - The world for which to delete the grid.
   *
   * @remarks
   * This method will dispose of the grid and remove it from the internal list.
   * If the world is disposed before calling this method, the grid will be automatically deleted.
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
I(Ss, "uuid", "d1e814d5-b81c-4452-87a2-f039375e0489");
var dn = Ss;
var jt = new Raycaster();
var nt = new Vector3();
var xt = new Vector3();
var j = new Quaternion();
var un = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
var ni = { type: "change" };
var In = { type: "mouseDown" };
var fn2 = { type: "mouseUp", mode: null };
var pn = { type: "objectChange" };
var yr = class extends Object3D {
  constructor(s, t) {
    super(), t === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = true, this.visible = false, this.domElement = t, this.domElement.style.touchAction = "none";
    const e = new xr();
    this._gizmo = e, this.add(e);
    const i = new br();
    this._plane = i, this.add(i);
    const o = this;
    function n(A, F) {
      let p = F;
      Object.defineProperty(o, A, {
        get: function() {
          return p !== void 0 ? p : F;
        },
        set: function(m) {
          p !== m && (p = m, i[A] = m, e[A] = m, o.dispatchEvent({ type: A + "-changed", value: m }), o.dispatchEvent(ni));
        }
      }), o[A] = F, i[A] = F, e[A] = F;
    }
    n("camera", s), n("object", void 0), n("enabled", true), n("axis", null), n("mode", "translate"), n("translationSnap", null), n("rotationSnap", null), n("scaleSnap", null), n("space", "world"), n("size", 1), n("dragging", false), n("showX", true), n("showY", true), n("showZ", true);
    const r = new Vector3(), a = new Vector3(), c = new Quaternion(), h = new Quaternion(), d = new Vector3(), E = new Quaternion(), u = new Vector3(), f = new Vector3(), T = new Vector3(), R = 0, C = new Vector3();
    n("worldPosition", r), n("worldPositionStart", a), n("worldQuaternion", c), n("worldQuaternionStart", h), n("cameraPosition", d), n("cameraQuaternion", E), n("pointStart", u), n("pointEnd", f), n("rotationAxis", T), n("rotationAngle", R), n("eye", C), this._offset = new Vector3(), this._startNorm = new Vector3(), this._endNorm = new Vector3(), this._cameraScale = new Vector3(), this._parentPosition = new Vector3(), this._parentQuaternion = new Quaternion(), this._parentQuaternionInv = new Quaternion(), this._parentScale = new Vector3(), this._worldScaleStart = new Vector3(), this._worldQuaternionInv = new Quaternion(), this._worldScale = new Vector3(), this._positionStart = new Vector3(), this._quaternionStart = new Quaternion(), this._scaleStart = new Vector3(), this._getPointer = Lr.bind(this), this._onPointerDown = wr.bind(this), this._onPointerHover = Mr.bind(this), this._onPointerMove = Dr.bind(this), this._onPointerUp = Ur.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld  updates key transformation variables
  updateMatrixWorld() {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
  }
  pointerHover(s) {
    if (this.object === void 0 || this.dragging === true)
      return;
    jt.setFromCamera(s, this.camera);
    const t = oi(this._gizmo.picker[this.mode], jt);
    t ? this.axis = t.object.name : this.axis = null;
  }
  pointerDown(s) {
    if (!(this.object === void 0 || this.dragging === true || s.button !== 0) && this.axis !== null) {
      jt.setFromCamera(s, this.camera);
      const t = oi(this._plane, jt, true);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = true, In.mode = this.mode, this.dispatchEvent(In);
    }
  }
  pointerMove(s) {
    const t = this.axis, e = this.mode, i = this.object;
    let o = this.space;
    if (e === "scale" ? o = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (o = "world"), i === void 0 || t === null || this.dragging === false || s.button !== -1)
      return;
    jt.setFromCamera(s, this.camera);
    const n = oi(this._plane, jt, true);
    if (n) {
      if (this.pointEnd.copy(n.point).sub(this.worldPositionStart), e === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), o === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), o === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), i.position.copy(this._offset).add(this._positionStart), this.translationSnap && (o === "local" && (i.position.applyQuaternion(j.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.position.applyQuaternion(this._quaternionStart)), o === "world" && (i.parent && i.position.add(nt.setFromMatrixPosition(i.parent.matrixWorld)), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.parent && i.position.sub(nt.setFromMatrixPosition(i.parent.matrixWorld))));
      else if (e === "scale") {
        if (t.search("XYZ") !== -1) {
          let r = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (r *= -1), xt.set(r, r, r);
        } else
          nt.copy(this.pointStart), xt.copy(this.pointEnd), nt.applyQuaternion(this._worldQuaternionInv), xt.applyQuaternion(this._worldQuaternionInv), xt.divide(nt), t.search("X") === -1 && (xt.x = 1), t.search("Y") === -1 && (xt.y = 1), t.search("Z") === -1 && (xt.z = 1);
        i.scale.copy(this._scaleStart).multiply(xt), this.scaleSnap && (t.search("X") !== -1 && (i.scale.x = Math.round(i.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (i.scale.y = Math.round(i.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (i.scale.z = Math.round(i.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (e === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const r = 20 / this.worldPosition.distanceTo(nt.setFromMatrixPosition(this.camera.matrixWorld));
        let a = false;
        t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(nt.copy(this.rotationAxis).cross(this.eye)) * r) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(un[t]), nt.copy(un[t]), o === "local" && nt.applyQuaternion(this.worldQuaternion), nt.cross(this.eye), nt.length() === 0 ? a = true : this.rotationAngle = this._offset.dot(nt.normalize()) * r), (t === "E" || a) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), o === "local" && t !== "E" && t !== "XYZE" ? (i.quaternion.copy(this._quaternionStart), i.quaternion.multiply(j.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), i.quaternion.copy(j.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), i.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(ni), this.dispatchEvent(pn);
    }
  }
  pointerUp(s) {
    s.button === 0 && (this.dragging && this.axis !== null && (fn2.mode = this.mode, this.dispatchEvent(fn2)), this.dragging = false, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(s) {
      s.geometry && s.geometry.dispose(), s.material && s.material.dispose();
    });
  }
  // Set current object
  attach(s) {
    return this.object = s, this.visible = true, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.visible = false, this.axis = null, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(ni), this.dispatchEvent(pn), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return jt;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(s) {
    this.mode = s;
  }
  setTranslationSnap(s) {
    this.translationSnap = s;
  }
  setRotationSnap(s) {
    this.rotationSnap = s;
  }
  setScaleSnap(s) {
    this.scaleSnap = s;
  }
  setSize(s) {
    this.size = s;
  }
  setSpace(s) {
    this.space = s;
  }
};
function Lr(l) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: l.button
    };
  {
    const s = this.domElement.getBoundingClientRect();
    return {
      x: (l.clientX - s.left) / s.width * 2 - 1,
      y: -(l.clientY - s.top) / s.height * 2 + 1,
      button: l.button
    };
  }
}
function Mr(l) {
  if (this.enabled)
    switch (l.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(l));
        break;
    }
}
function wr(l) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(l.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(l)), this.pointerDown(this._getPointer(l)));
}
function Dr(l) {
  this.enabled && this.pointerMove(this._getPointer(l));
}
function Ur(l) {
  this.enabled && (this.domElement.releasePointerCapture(l.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(l)));
}
function oi(l, s, t) {
  const e = s.intersectObject(l, true);
  for (let i = 0; i < e.length; i++)
    if (e[i].object.visible || t)
      return e[i];
  return false;
}
var Is = new Euler();
var k = new Vector3(0, 1, 0);
var Cn = new Vector3(0, 0, 0);
var Tn = new Matrix4();
var fs = new Quaternion();
var Rs = new Quaternion();
var _t = new Vector3();
var mn = new Matrix4();
var Ue = new Vector3(1, 0, 0);
var qt = new Vector3(0, 1, 0);
var xe = new Vector3(0, 0, 1);
var ps = new Vector3();
var we = new Vector3();
var De = new Vector3();
var xr = class extends Object3D {
  constructor() {
    super(), this.isTransformControlsGizmo = true, this.type = "TransformControlsGizmo";
    const s = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    }), t = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    }), e = s.clone();
    e.opacity = 0.15;
    const i = t.clone();
    i.opacity = 0.5;
    const o = s.clone();
    o.color.setHex(16711680);
    const n = s.clone();
    n.color.setHex(65280);
    const r = s.clone();
    r.color.setHex(255);
    const a = s.clone();
    a.color.setHex(16711680), a.opacity = 0.5;
    const c = s.clone();
    c.color.setHex(65280), c.opacity = 0.5;
    const h = s.clone();
    h.color.setHex(255), h.opacity = 0.5;
    const d = s.clone();
    d.opacity = 0.25;
    const E = s.clone();
    E.color.setHex(16776960), E.opacity = 0.25, s.clone().color.setHex(16776960);
    const f = s.clone();
    f.color.setHex(7895160);
    const T = new CylinderGeometry(0, 0.04, 0.1, 12);
    T.translate(0, 0.05, 0);
    const R = new BoxGeometry(0.08, 0.08, 0.08);
    R.translate(0, 0.04, 0);
    const C = new BufferGeometry();
    C.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const A = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    A.translate(0, 0.25, 0);
    function F(B, H) {
      const q = new TorusGeometry(B, 75e-4, 3, 64, H * Math.PI * 2);
      return q.rotateY(Math.PI / 2), q.rotateX(Math.PI / 2), q;
    }
    function p() {
      const B = new BufferGeometry();
      return B.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3)), B;
    }
    const m = {
      X: [
        [new Mesh(T, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(T, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(A, o), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(T, n), [0, 0.5, 0]],
        [new Mesh(T, n), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(A, n)]
      ],
      Z: [
        [new Mesh(T, r), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(T, r), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(A, r), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), d.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), h.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), a.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), c.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, g = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), e)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), e), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), e), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), e), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, S = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), i), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), i), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(p(), i), null, null, null, "helper"]
      ],
      X: [
        [new Line(C, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(C, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(C, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, _ = {
      XYZE: [
        [new Mesh(F(0.5, 1), f), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(F(0.5, 0.5), o)]
      ],
      Y: [
        [new Mesh(F(0.5, 0.5), n), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(F(0.5, 0.5), r), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(F(0.75, 1), E), null, [0, Math.PI / 2, 0]]
      ]
    }, N = {
      AXIS: [
        [new Line(C, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, y = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), e)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), e), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), e), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), e), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), e)]
      ]
    }, w = {
      X: [
        [new Mesh(R, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(A, o), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(R, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(R, n), [0, 0.5, 0]],
        [new Mesh(A, n)],
        [new Mesh(R, n), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(R, r), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(A, r), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(R, r), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), h), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), a), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), c), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), d.clone())]
      ]
    }, L = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), e), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), e), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), e), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), e), [0, 0, 0]]
      ]
    }, U = {
      X: [
        [new Line(C, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(C, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(C, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function b(B) {
      const H = new Object3D();
      for (const q in B)
        for (let st = B[q].length; st--; ) {
          const Q = B[q][st][0].clone(), Ht = B[q][st][1], Wt = B[q][st][2], kt = B[q][st][3], ke2 = B[q][st][4];
          Q.name = q, Q.tag = ke2, Ht && Q.position.set(Ht[0], Ht[1], Ht[2]), Wt && Q.rotation.set(Wt[0], Wt[1], Wt[2]), kt && Q.scale.set(kt[0], kt[1], kt[2]), Q.updateMatrix();
          const Te = Q.geometry.clone();
          Te.applyMatrix4(Q.matrix), Q.geometry = Te, Q.renderOrder = 1 / 0, Q.position.set(0, 0, 0), Q.rotation.set(0, 0, 0), Q.scale.set(1, 1, 1), H.add(Q);
        }
      return H;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = b(m)), this.add(this.gizmo.rotate = b(_)), this.add(this.gizmo.scale = b(w)), this.add(this.picker.translate = b(g)), this.add(this.picker.rotate = b(y)), this.add(this.picker.scale = b(L)), this.add(this.helper.translate = b(S)), this.add(this.helper.rotate = b(N)), this.add(this.helper.scale = b(U)), this.picker.translate.visible = false, this.picker.rotate.visible = false, this.picker.scale.visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(s) {
    const e = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : Rs;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let i = [];
    i = i.concat(this.picker[this.mode].children), i = i.concat(this.gizmo[this.mode].children), i = i.concat(this.helper[this.mode].children);
    for (let o = 0; o < i.length; o++) {
      const n = i[o];
      n.visible = true, n.rotation.set(0, 0, 0), n.position.copy(this.worldPosition);
      let r;
      if (this.camera.isOrthographicCamera ? r = (this.camera.top - this.camera.bottom) / this.camera.zoom : r = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), n.scale.set(1, 1, 1).multiplyScalar(r * this.size / 4), n.tag === "helper") {
        n.visible = false, n.name === "AXIS" ? (n.visible = !!this.axis, this.axis === "X" && (j.setFromEuler(Is.set(0, 0, 0)), n.quaternion.copy(e).multiply(j), Math.abs(k.copy(Ue).applyQuaternion(e).dot(this.eye)) > 0.9 && (n.visible = false)), this.axis === "Y" && (j.setFromEuler(Is.set(0, 0, Math.PI / 2)), n.quaternion.copy(e).multiply(j), Math.abs(k.copy(qt).applyQuaternion(e).dot(this.eye)) > 0.9 && (n.visible = false)), this.axis === "Z" && (j.setFromEuler(Is.set(0, Math.PI / 2, 0)), n.quaternion.copy(e).multiply(j), Math.abs(k.copy(xe).applyQuaternion(e).dot(this.eye)) > 0.9 && (n.visible = false)), this.axis === "XYZE" && (j.setFromEuler(Is.set(0, Math.PI / 2, 0)), k.copy(this.rotationAxis), n.quaternion.setFromRotationMatrix(Tn.lookAt(Cn, k, qt)), n.quaternion.multiply(j), n.visible = this.dragging), this.axis === "E" && (n.visible = false)) : n.name === "START" ? (n.position.copy(this.worldPositionStart), n.visible = this.dragging) : n.name === "END" ? (n.position.copy(this.worldPosition), n.visible = this.dragging) : n.name === "DELTA" ? (n.position.copy(this.worldPositionStart), n.quaternion.copy(this.worldQuaternionStart), nt.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), nt.applyQuaternion(this.worldQuaternionStart.clone().invert()), n.scale.copy(nt), n.visible = this.dragging) : (n.quaternion.copy(e), this.dragging ? n.position.copy(this.worldPositionStart) : n.position.copy(this.worldPosition), this.axis && (n.visible = this.axis.search(n.name) !== -1));
        continue;
      }
      n.quaternion.copy(e), this.mode === "translate" || this.mode === "scale" ? (n.name === "X" && Math.abs(k.copy(Ue).applyQuaternion(e).dot(this.eye)) > 0.99 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "Y" && Math.abs(k.copy(qt).applyQuaternion(e).dot(this.eye)) > 0.99 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "Z" && Math.abs(k.copy(xe).applyQuaternion(e).dot(this.eye)) > 0.99 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "XY" && Math.abs(k.copy(xe).applyQuaternion(e).dot(this.eye)) < 0.2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "YZ" && Math.abs(k.copy(Ue).applyQuaternion(e).dot(this.eye)) < 0.2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "XZ" && Math.abs(k.copy(qt).applyQuaternion(e).dot(this.eye)) < 0.2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false)) : this.mode === "rotate" && (fs.copy(e), k.copy(this.eye).applyQuaternion(j.copy(e).invert()), n.name.search("E") !== -1 && n.quaternion.setFromRotationMatrix(Tn.lookAt(this.eye, Cn, qt)), n.name === "X" && (j.setFromAxisAngle(Ue, Math.atan2(-k.y, k.z)), j.multiplyQuaternions(fs, j), n.quaternion.copy(j)), n.name === "Y" && (j.setFromAxisAngle(qt, Math.atan2(k.x, k.z)), j.multiplyQuaternions(fs, j), n.quaternion.copy(j)), n.name === "Z" && (j.setFromAxisAngle(xe, Math.atan2(k.y, k.x)), j.multiplyQuaternions(fs, j), n.quaternion.copy(j))), n.visible = n.visible && (n.name.indexOf("X") === -1 || this.showX), n.visible = n.visible && (n.name.indexOf("Y") === -1 || this.showY), n.visible = n.visible && (n.name.indexOf("Z") === -1 || this.showZ), n.visible = n.visible && (n.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), n.material._color = n.material._color || n.material.color.clone(), n.material._opacity = n.material._opacity || n.material.opacity, n.material.color.copy(n.material._color), n.material.opacity = n.material._opacity, this.enabled && this.axis && (n.name === this.axis || this.axis.split("").some(function(a) {
        return n.name === a;
      })) && (n.material.color.setHex(16776960), n.material.opacity = 1);
    }
    super.updateMatrixWorld(s);
  }
};
var br = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    ), this.isTransformControlsPlane = true, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(s) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), ps.copy(Ue).applyQuaternion(t === "local" ? this.worldQuaternion : Rs), we.copy(qt).applyQuaternion(t === "local" ? this.worldQuaternion : Rs), De.copy(xe).applyQuaternion(t === "local" ? this.worldQuaternion : Rs), k.copy(we), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            k.copy(this.eye).cross(ps), _t.copy(ps).cross(k);
            break;
          case "Y":
            k.copy(this.eye).cross(we), _t.copy(we).cross(k);
            break;
          case "Z":
            k.copy(this.eye).cross(De), _t.copy(De).cross(k);
            break;
          case "XY":
            _t.copy(De);
            break;
          case "YZ":
            _t.copy(ps);
            break;
          case "XZ":
            k.copy(De), _t.copy(we);
            break;
          case "XYZ":
          case "E":
            _t.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        _t.set(0, 0, 0);
    }
    _t.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (mn.lookAt(nt.set(0, 0, 0), _t, k), this.quaternion.setFromRotationMatrix(mn)), super.updateMatrixWorld(s);
  }
};
var Pi = class _Pi {
  constructor(s, t, e, i, o, n = 5, r = true) {
    I(this, "onDraggingStarted", new D());
    I(this, "onDraggingEnded", new D());
    I(this, "onDisposed", new D());
    I(this, "normal");
    I(this, "origin");
    I(this, "three", new Plane());
    I(this, "components");
    I(this, "world");
    I(this, "type", "default");
    I(this, "_helper");
    I(this, "_visible", true);
    I(this, "_enabled", true);
    I(this, "_controlsActive", false);
    I(this, "_arrowBoundBox", new Mesh());
    I(this, "_planeMesh");
    I(this, "_controls");
    I(this, "_hiddenMaterial", new MeshBasicMaterial({
      visible: false
    }));
    I(this, "update", () => {
      this._enabled && this.three.setFromNormalAndCoplanarPoint(
        this.normal,
        this._helper.position
      );
    });
    I(this, "changeDrag", (s2) => {
      this._visible = !s2.value, this.preventCameraMovement(), this.notifyDraggingChanged(s2);
    });
    if (this.components = s, this.world = t, !t.renderer)
      throw new Error("The given world must have a renderer!");
    this.normal = i, this.origin = e, t.renderer.setPlane(true, this.three), this._planeMesh = _Pi.newPlaneMesh(n, o), this._helper = this.newHelper(), this._controls = this.newTransformControls(), this.three.setFromNormalAndCoplanarPoint(i, e), r && this.toggleControls(true);
  }
  /**
   * Getter for the enabled state of the clipping plane.
   * @returns {boolean} The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Setter for the enabled state of the clipping plane.
   * Updates the clipping plane state in the renderer and throws an error if no renderer is found.
   * @param {boolean} state - The new enabled state.
   */
  set enabled(s) {
    if (!this.world.renderer)
      throw new Error("No renderer found for clipping plane!");
    this._enabled = s, this.world.renderer.setPlane(s, this.three);
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(s) {
    this._visible = s, this._controls.visible = s, this._helper.visible = s, this.toggleControls(s);
  }
  /** The meshes used for raycasting */
  get meshes() {
    return [this._planeMesh, this._arrowBoundBox];
  }
  /** The material of the clipping plane representation. */
  get planeMaterial() {
    return this._planeMesh.material;
  }
  /** The material of the clipping plane representation. */
  set planeMaterial(s) {
    this._planeMesh.material = s;
  }
  /** The size of the clipping plane representation. */
  get size() {
    return this._planeMesh.scale.x;
  }
  /** Sets the size of the clipping plane representation. */
  set size(s) {
    this._planeMesh.scale.set(s, s, s);
  }
  /**
   * Getter for the helper object of the clipping plane.
   * The helper object is a THREE.Object3D that contains the clipping plane mesh and other related objects.
   * It is used for positioning, rotating, and scaling the clipping plane in the 3D scene.
   *
   * @returns {THREE.Object3D} The helper object of the clipping plane.
   */
  get helper() {
    return this._helper;
  }
  /**
   * Sets the clipping plane's normal and origin from the given normal and point.
   * This method resets the clipping plane's state, updates the normal and origin,
   * and positions the helper object accordingly.
   *
   * @param normal - The new normal vector for the clipping plane.
   * @param point - The new origin point for the clipping plane.
   *
   * @returns {void}
   */
  setFromNormalAndCoplanarPoint(s, t) {
    this.reset(), this.normal.equals(s) || (this.normal.copy(s), this._helper.lookAt(s)), this.origin.copy(t), this._helper.position.copy(t), this._helper.updateMatrix(), this.update();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false, this.onDraggingStarted.reset(), this.onDraggingEnded.reset(), this._helper.removeFromParent(), this.world.renderer && this.world.renderer.setPlane(false, this.three), this._arrowBoundBox.removeFromParent(), this._arrowBoundBox.geometry.dispose(), this._planeMesh.geometry.dispose(), this._controls.removeFromParent(), this._controls.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  reset() {
    const s = new Vector3(1, 0, 0), t = new Vector3();
    this.normal.equals(s) || (this.normal.copy(s), this._helper.lookAt(s)), this.origin.copy(t), this._helper.position.copy(t), this._helper.updateMatrix();
  }
  toggleControls(s) {
    if (s) {
      if (this._controlsActive)
        return;
      this._controls.addEventListener("change", this.update), this._controls.addEventListener("dragging-changed", this.changeDrag);
    } else
      this._controls.removeEventListener("change", this.update), this._controls.removeEventListener("dragging-changed", this.changeDrag);
    this._controlsActive = s;
  }
  newTransformControls() {
    if (!this.world.renderer)
      throw new Error("No renderer found for clipping plane!");
    const s = this.world.camera.three, t = this.world.renderer.three.domElement, e = new yr(s, t);
    return this.initializeControls(e), this.world.scene.three.add(e), e;
  }
  initializeControls(s) {
    s.attach(this._helper), s.showX = false, s.showY = false, s.setSpace("local"), this.createArrowBoundingBox(), s.children[0].children[0].add(this._arrowBoundBox);
  }
  createArrowBoundingBox() {
    this._arrowBoundBox.geometry = new CylinderGeometry(0.18, 0.18, 1.2), this._arrowBoundBox.material = this._hiddenMaterial, this._arrowBoundBox.rotateX(Math.PI / 2), this._arrowBoundBox.updateMatrix(), this._arrowBoundBox.geometry.applyMatrix4(this._arrowBoundBox.matrix);
  }
  notifyDraggingChanged(s) {
    s.value ? this.onDraggingStarted.trigger() : this.onDraggingEnded.trigger();
  }
  preventCameraMovement() {
    this.world.camera.enabled = this._visible;
  }
  newHelper() {
    const s = new Object3D();
    return s.lookAt(this.normal), s.position.copy(this.origin), this._planeMesh.position.z += 0.01, s.add(this._planeMesh), this.world.scene.three.add(s), s;
  }
  static newPlaneMesh(s, t) {
    const e = new PlaneGeometry(1), i = new Mesh(e, t);
    return i.scale.set(s, s, s), i;
  }
};
var Be = class Be2 extends et {
  constructor(t) {
    super(t);
    I(this, "onBeforeDrag", new D());
    I(this, "onAfterDrag", new D());
    I(this, "onBeforeCreate", new D());
    I(this, "onBeforeCancel", new D());
    I(this, "onAfterCancel", new D());
    I(this, "onBeforeDelete", new D());
    I(this, "onAfterCreate", new D());
    I(this, "onAfterDelete", new D());
    I(this, "onDisposed", new D());
    I(this, "orthogonalY", false);
    I(this, "toleranceOrthogonalY", 0.7);
    I(this, "Type", Pi);
    I(this, "list", []);
    I(this, "_material", new MeshBasicMaterial({
      color: 12255487,
      side: DoubleSide,
      transparent: true,
      opacity: 0.2
    }));
    I(this, "_size", 5);
    I(this, "_enabled", false);
    I(this, "_visible", true);
    I(this, "_onStartDragging", () => {
      this.onBeforeDrag.trigger();
    });
    I(this, "_onEndDragging", () => {
      this.onAfterDrag.trigger();
    });
    this.components.add(Be2.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this._enabled = t;
    for (const e of this.list)
      e.enabled = t;
    this.updateMaterialsAndPlanes();
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(t) {
    this._visible = t;
    for (const e of this.list)
      e.visible = t;
  }
  /** The material of the clipping plane representation. */
  get material() {
    return this._material;
  }
  /** The material of the clipping plane representation. */
  set material(t) {
    this._material = t;
    for (const e of this.list)
      e.planeMaterial = t;
  }
  /** The size of the geometric representation of the clippings planes. */
  get size() {
    return this._size;
  }
  /** The size of the geometric representation of the clippings planes. */
  set size(t) {
    this._size = t;
    for (const e of this.list)
      e.size = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false;
    for (const t of this.list)
      t.dispose();
    this.list.length = 0, this._material.dispose(), this.onBeforeCreate.reset(), this.onBeforeCancel.reset(), this.onBeforeDelete.reset(), this.onBeforeDrag.reset(), this.onAfterCreate.reset(), this.onAfterCancel.reset(), this.onAfterDelete.reset(), this.onAfterDrag.reset(), this.onDisposed.trigger(Be2.uuid), this.onDisposed.reset();
  }
  /** {@link Createable.create} */
  create(t) {
    const o = this.components.get(He).get(t).castRay();
    return o ? this.createPlaneFromIntersection(t, o) : null;
  }
  /**
   * Creates a plane in a certain place and with a certain orientation,
   * without the need of the mouse.
   *
   * @param world - the world where this plane should be created.
   * @param normal - the orientation of the clipping plane.
   * @param point - the position of the clipping plane.
   * navigation.
   */
  createFromNormalAndCoplanarPoint(t, e, i) {
    const o = this.newPlane(t, i, e);
    return this.updateMaterialsAndPlanes(), o;
  }
  /**
   * {@link Createable.delete}
   *
   * @param world - the world where the plane to delete is.
   * @param plane - the plane to delete. If undefined, the first plane
   * found under the cursor will be deleted.
   */
  delete(t, e) {
    e || (e = this.pickPlane(t)), e && this.deletePlane(e);
  }
  /**
   * Deletes all the existing clipping planes.
   *
   * @param types - the types of planes to be deleted. If not provided, all planes will be deleted.
   */
  deleteAll(t) {
    const e = [...this.list];
    for (const i of e)
      if (!t || t.has(i.type)) {
        this.delete(i.world, i);
        const o = this.list.indexOf(i);
        o !== -1 && this.list.splice(o, 1);
      }
  }
  deletePlane(t) {
    const e = this.list.indexOf(t);
    if (e !== -1) {
      if (this.list.splice(e, 1), !t.world.renderer)
        throw new Error("Renderer not found for this plane's world!");
      t.world.renderer.setPlane(false, t.three), t.dispose(), this.updateMaterialsAndPlanes(), this.onAfterDelete.trigger(t);
    }
  }
  pickPlane(t) {
    const i = this.components.get(He).get(t), o = this.getAllPlaneMeshes(), n = i.castRay(o);
    if (n) {
      const r = n.object;
      return this.list.find((a) => a.meshes.includes(r));
    }
  }
  getAllPlaneMeshes() {
    const t = [];
    for (const e of this.list)
      t.push(...e.meshes);
    return t;
  }
  createPlaneFromIntersection(t, e) {
    var a;
    if (!t.renderer)
      throw new Error("The given world must have a renderer!");
    const i = e.point.distanceTo(new Vector3(0, 0, 0)), o = (a = e.face) == null ? void 0 : a.normal;
    if (!i || !o)
      return null;
    const n = this.getWorldNormal(e, o), r = this.newPlane(t, e.point, n.negate());
    return r.visible = this._visible, r.size = this._size, t.renderer.setPlane(true, r.three), this.updateMaterialsAndPlanes(), r;
  }
  getWorldNormal(t, e) {
    const i = t.object;
    let o = t.object.matrixWorld.clone();
    if (i instanceof InstancedMesh && t.instanceId !== void 0) {
      const c = new Matrix4();
      i.getMatrixAt(t.instanceId, c), o = c.multiply(o);
    }
    const r = new Matrix3().getNormalMatrix(o), a = e.clone().applyMatrix3(r).normalize();
    return this.normalizePlaneDirectionY(a), a;
  }
  normalizePlaneDirectionY(t) {
    this.orthogonalY && (t.y > this.toleranceOrthogonalY && (t.x = 0, t.y = 1, t.z = 0), t.y < -this.toleranceOrthogonalY && (t.x = 0, t.y = -1, t.z = 0));
  }
  newPlane(t, e, i) {
    const o = new this.Type(
      this.components,
      t,
      e,
      i,
      this._material
    );
    return o.onDraggingStarted.add(this._onStartDragging), o.onDraggingEnded.add(this._onEndDragging), this.list.push(o), this.onAfterCreate.trigger(o), o;
  }
  updateMaterialsAndPlanes() {
    const t = this.components.get(Ci);
    for (const [e, i] of t.list) {
      if (!i.renderer)
        continue;
      i.renderer.updateClippingPlanes();
      const { clippingPlanes: o } = i.renderer;
      for (const n of i.meshes)
        if (n.material)
          if (Array.isArray(n.material))
            for (const r of n.material)
              r.clippingPlanes = o;
          else
            n.material.clippingPlanes = o;
    }
  }
};
I(Be, "uuid", "66290bc5-18c4-4cd1-9379-2e17a0617611");
var Rn = Be;
function vr(l, s, t, e) {
  return new Promise((i, o) => {
    function n() {
      const r = l.clientWaitSync(s, t, 0);
      if (r === l.WAIT_FAILED) {
        o();
        return;
      }
      if (r === l.TIMEOUT_EXPIRED) {
        setTimeout(n, e);
        return;
      }
      i();
    }
    n();
  });
}
async function Br(l, s, t, e, i, o, n) {
  const r = l.fenceSync(l.SYNC_GPU_COMMANDS_COMPLETE, 0);
  l.flush(), await vr(l, r, 0, 10), l.deleteSync(r), l.bindBuffer(s, t), l.getBufferSubData(s, e, i, o, n), l.bindBuffer(s, null);
}
async function Yr(l, s, t, e, i, o, n, r) {
  const a = l.createBuffer();
  return l.bindBuffer(l.PIXEL_PACK_BUFFER, a), l.bufferData(l.PIXEL_PACK_BUFFER, r.byteLength, l.STREAM_READ), l.readPixels(s, t, e, i, o, n, 0), l.bindBuffer(l.PIXEL_PACK_BUFFER, null), await Br(l, l.PIXEL_PACK_BUFFER, a, 0, r), l.deleteBuffer(a), r;
}
var Vr = class {
  constructor(s, t, e) {
    I(this, "onDisposed", new D());
    I(this, "onViewUpdated", new Ts());
    I(this, "enabled", true);
    I(this, "needsUpdate", false);
    I(this, "renderDebugFrame", false);
    I(this, "components");
    I(this, "world");
    I(this, "renderer");
    I(this, "autoUpdate", true);
    I(this, "updateInterval", 1e3);
    I(this, "worker");
    I(this, "scene", new Scene());
    I(this, "_width", 512);
    I(this, "_height", 512);
    I(this, "_availableColor", 1);
    I(this, "renderTarget");
    I(this, "bufferSize");
    I(this, "_buffer");
    I(this, "_isWorkerBusy", false);
    I(this, "updateVisibility", async (s2) => {
      if (!this.enabled || !this.needsUpdate && !s2 || this._isWorkerBusy)
        return;
      this._isWorkerBusy = true;
      const t2 = this.world.camera.three;
      t2.updateMatrix(), this.renderer.setSize(this._width, this._height), this.renderer.setRenderTarget(this.renderTarget), this.renderer.render(this.scene, t2);
      const e2 = this.renderer.getContext();
      await Yr(
        e2,
        0,
        0,
        this._width,
        this._height,
        e2.RGBA,
        e2.UNSIGNED_BYTE,
        this._buffer
      ), this.renderer.setRenderTarget(null), this.renderDebugFrame && this.renderer.render(this.scene, t2), this.worker.postMessage({
        buffer: this._buffer
      }), this.needsUpdate = false;
    });
    if (!t.renderer)
      throw new Error("The given world must have a renderer!");
    this.components = s, this.applySettings(e), this.world = t, this.renderer = new WebGLRenderer(), this.renderTarget = new WebGLRenderTarget(this._width, this._height), this.bufferSize = this._width * this._height * 4, this._buffer = new Uint8Array(this.bufferSize), this.renderer.clippingPlanes = t.renderer.clippingPlanes;
    const i = `
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Map();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          const g = buffer[i + 1];
          const b = buffer[i + 2];
          const code = "" + r + "-" + g + "-" + b;
          if(colors.has(code)) {
            colors.set(code, colors.get(code) + 1);
          } else {
            colors.set(code, 1);
          }
        }
        postMessage({ colors });
      });
    `, o = new Blob([i], { type: "application/javascript" });
    this.worker = new Worker(URL.createObjectURL(o));
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    for (const s of this.scene.children)
      s.removeFromParent();
    this.onViewUpdated.reset(), this.worker.terminate(), this.renderer.dispose(), this.renderTarget.dispose(), this._buffer = null, this.onDisposed.reset();
  }
  getAvailableColor() {
    let s = BigInt(this._availableColor.toString());
    const t = [];
    do
      t.unshift(Number(s % 256n)), s /= 256n;
    while (s);
    for (; t.length !== 3; )
      t.unshift(0);
    const [e, i, o] = t, n = `${e}-${i}-${o}`;
    return { r: e, g: i, b: o, code: n };
  }
  increaseColor() {
    if (this._availableColor === 256 * 256 * 256) {
      console.warn("Color can't be increased over 256 x 256 x 256!");
      return;
    }
    this._availableColor++;
  }
  decreaseColor() {
    if (this._availableColor === 1) {
      console.warn("Color can't be decreased under 0!");
      return;
    }
    this._availableColor--;
  }
  applySettings(s) {
    s && (s.updateInterval !== void 0 && (this.updateInterval = s.updateInterval), s.height !== void 0 && (this._height = s.height), s.width !== void 0 && (this._width = s.width), s.autoUpdate !== void 0 && (this.autoUpdate = s.autoUpdate));
  }
};
var Gr = class extends Vr {
  constructor(t, e, i) {
    super(t, e, i);
    I(this, "onViewUpdated", new D());
    I(this, "threshold", 100);
    I(this, "colorMeshes", /* @__PURE__ */ new Map());
    I(this, "isProcessing", false);
    I(this, "_colorCodeMeshMap", /* @__PURE__ */ new Map());
    I(this, "_meshIDColorCodeMap", /* @__PURE__ */ new Map());
    I(this, "_currentVisibleMeshes", /* @__PURE__ */ new Set());
    I(this, "_recentlyHiddenMeshes", /* @__PURE__ */ new Set());
    I(this, "_intervalID", null);
    I(this, "_transparentMat", new MeshBasicMaterial({
      transparent: true,
      opacity: 0
    }));
    I(this, "handleWorkerMessage", async (t2) => {
      if (this.isProcessing)
        return;
      const e2 = t2.data.colors;
      this._recentlyHiddenMeshes = new Set(this._currentVisibleMeshes), this._currentVisibleMeshes.clear();
      for (const [i2, o] of e2) {
        if (o < this.threshold)
          continue;
        const n = this._colorCodeMeshMap.get(i2);
        n && (this._currentVisibleMeshes.add(n), this._recentlyHiddenMeshes.delete(n));
      }
      this.onViewUpdated.trigger({
        seen: this._currentVisibleMeshes,
        unseen: this._recentlyHiddenMeshes
      }), this._isWorkerBusy = false;
    });
    this.worker.addEventListener("message", this.handleWorkerMessage), this.autoUpdate && window.setInterval(async () => {
      this.isProcessing || await this.updateVisibility();
    }, this.updateInterval), this.onViewUpdated.add(({ seen: o, unseen: n }) => {
      for (const r of o)
        r.visible = true;
      for (const r of n)
        r.visible = false;
    });
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose(), this._intervalID !== null && (window.clearInterval(this._intervalID), this._intervalID = null), this._currentVisibleMeshes.clear(), this._recentlyHiddenMeshes.clear(), this._meshIDColorCodeMap.clear(), this._transparentMat.dispose(), this._colorCodeMeshMap.clear();
    const t = this.components.get(zt);
    for (const e in this.colorMeshes) {
      const i = this.colorMeshes.get(e);
      i && t.destroy(i, true);
    }
    this.colorMeshes.clear();
  }
  /**
   * Adds a mesh to the culler. When the mesh is not visibile anymore, it will be removed from the scene. When it's visible again, it will be added to the scene.
   * @param mesh - The mesh to add. It can be a regular THREE.Mesh or an instance of THREE.InstancedMesh.
   * @returns {void}
   */
  add(t) {
    if (!this.enabled)
      return;
    if (this.isProcessing) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.isProcessing = true;
    const e = t instanceof InstancedMesh, { geometry: i, material: o } = t, { colorMaterial: n, code: r } = this.getAvailableMaterial();
    let a;
    if (Array.isArray(o)) {
      let d = true;
      const E = [];
      for (const u of o)
        sn.isTransparent(u) ? E.push(this._transparentMat) : (d = false, E.push(n));
      if (d) {
        n.dispose(), this.isProcessing = false;
        return;
      }
      a = E;
    } else if (sn.isTransparent(o)) {
      n.dispose(), this.isProcessing = false;
      return;
    } else
      a = n;
    this._colorCodeMeshMap.set(r, t), this._meshIDColorCodeMap.set(t.uuid, r);
    const c = e ? t.count : 1, h = new InstancedMesh(i, a, c);
    e ? h.instanceMatrix = t.instanceMatrix : h.setMatrixAt(0, new Matrix4()), t.visible = false, t.updateWorldMatrix(true, false), h.applyMatrix4(t.matrixWorld), h.updateMatrix(), this.scene.add(h), this.colorMeshes.set(t.uuid, h), this.increaseColor(), this.isProcessing = false;
  }
  /**
   * Removes a mesh from the culler, so its visibility is not controlled by the culler anymore.
   * When the mesh is removed, it will be hidden from the scene and its color-coded mesh will be destroyed.
   * @param mesh - The mesh to remove. It can be a regular THREE.Mesh or an instance of THREE.InstancedMesh.
   * @returns {void}
   */
  remove(t) {
    if (this.isProcessing) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.isProcessing = true;
    const e = this.components.get(zt);
    this._currentVisibleMeshes.delete(t), this._recentlyHiddenMeshes.delete(t);
    const i = this.colorMeshes.get(t.uuid), o = this._meshIDColorCodeMap.get(t.uuid);
    if (!i || !o) {
      this.isProcessing = false;
      return;
    }
    this._colorCodeMeshMap.delete(o), this._meshIDColorCodeMap.delete(t.uuid), this.colorMeshes.delete(t.uuid), i.geometry = void 0, i.material = [], e.destroy(i, true), this._recentlyHiddenMeshes.delete(t), this._currentVisibleMeshes.delete(t), this.isProcessing = false;
  }
  getAvailableMaterial() {
    const { r: t, g: e, b: i, code: o } = this.getAvailableColor(), n = ColorManagement.enabled;
    ColorManagement.enabled = false;
    const r = new Color(`rgb(${t}, ${e}, ${i})`);
    if (!this.world.renderer)
      throw new Error("Renderer not found in the world!");
    const a = this.world.renderer.clippingPlanes, c = new MeshBasicMaterial({
      color: r,
      clippingPlanes: a,
      side: DoubleSide
    });
    return ColorManagement.enabled = n, { colorMaterial: c, code: o };
  }
};
var Ye = class Ye2 extends et {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "_enabled", true);
    I(this, "list", /* @__PURE__ */ new Map());
    t.add(Ye2.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this._enabled = t;
    for (const [e, i] of this.list)
      i.enabled = t;
  }
  /**
   * Creates a new MeshCullerRenderer for the given world.
   * If a MeshCullerRenderer already exists for the world, it will return the existing one.
   *
   * @param world - The world for which to create the MeshCullerRenderer.
   * @param config - Optional configuration settings for the MeshCullerRenderer.
   *
   * @returns The newly created or existing MeshCullerRenderer for the given world.
   */
  create(t, e) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const i = new Gr(this.components, t, e);
    return this.list.set(t.uuid, i), i;
  }
  /**
   * Deletes the MeshCullerRenderer associated with the given world.
   * If a MeshCullerRenderer exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the MeshCullerRenderer.
   *
   * @returns {void}
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.onDisposed.trigger(Ye2.uuid), this.onDisposed.reset();
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear();
  }
};
I(Ye, "uuid", "69f2a50d-c266-44fc-b1bd-fa4d34be89e6");
var Ti = Ye;
var zr = class {
  constructor(s) {
    I(this, "onDisposed", new D());
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "onResize", new D());
    I(this, "frontOffset", 0);
    I(this, "overrideMaterial", new MeshDepthMaterial());
    I(this, "backgroundColor", new Color(395274));
    I(this, "renderer");
    I(this, "enabled", true);
    I(this, "world");
    I(this, "_lockRotation", true);
    I(this, "_camera");
    I(this, "_plane");
    I(this, "_size", new Vector2(320, 160));
    I(this, "_tempVector1", new Vector3());
    I(this, "_tempVector2", new Vector3());
    I(this, "_tempTarget", new Vector3());
    I(this, "down", new Vector3(0, -1, 0));
    I(this, "updatePlanes", () => {
      if (!this.world.renderer)
        throw new Error("The given world must have a renderer!");
      const s2 = [], t2 = this.world.renderer.three;
      for (const e2 of t2.clippingPlanes)
        s2.push(e2);
      s2.push(this._plane), this.renderer.clippingPlanes = s2;
    });
    if (this.world = s, !this.world.renderer)
      throw new Error("The given world must have a renderer!");
    this.renderer = new WebGLRenderer(), this.renderer.setSize(this._size.x, this._size.y);
    const t = 1, e = this._size.x / this._size.y;
    this._camera = new OrthographicCamera(
      t * e / -2,
      t * e / 2,
      t / 2,
      t / -2
    ), this.world.renderer.onClippingPlanesUpdated.add(this.updatePlanes), this._camera.position.set(0, 200, 0), this._camera.zoom = 0.1, this._camera.rotation.x = -Math.PI / 2, this._plane = new Plane(this.down, 200), this.updatePlanes();
  }
  /**
   * Gets or sets whether the minimap rotation is locked.
   * When rotation is locked, the minimap will always face the same direction as the camera.
   */
  get lockRotation() {
    return this._lockRotation;
  }
  /**
   * Sets whether the minimap rotation is locked.
   * When rotation is locked, the minimap will always face the same direction as the camera.
   * @param active - If `true`, rotation is locked. If `false`, rotation is not locked.
   */
  set lockRotation(s) {
    this._lockRotation = s, s && (this._camera.rotation.z = 0);
  }
  /**
   * Gets the current zoom level of the minimap.
   * The zoom level determines how much of the world is visible on the minimap.
   * @returns The current zoom level of the minimap.
   */
  get zoom() {
    return this._camera.zoom;
  }
  /**
   * Sets the zoom level of the minimap.
   * The zoom level determines how much of the world is visible on the minimap.
   * @param value - The new zoom level of the minimap.
   */
  set zoom(s) {
    this._camera.zoom = s, this._camera.updateProjectionMatrix();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.onResize.reset(), this.overrideMaterial.dispose(), this.renderer.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /** Returns the camera used by the MiniMap */
  get() {
    return this._camera;
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled)
      return;
    this.onBeforeUpdate.trigger();
    const s = this.world.scene.three, t = this.world.camera;
    if (!t.hasCameraControls())
      throw new Error("The given world must use camera controls!");
    if (!(s instanceof Scene))
      throw new Error("The given world must have a THREE.Scene as a root!");
    const e = t.controls;
    if (e.getPosition(this._tempVector1), this._camera.position.x = this._tempVector1.x, this._camera.position.z = this._tempVector1.z, this.frontOffset !== 0 && (e.getTarget(this._tempVector2), this._tempVector2.sub(this._tempVector1), this._tempVector2.normalize().multiplyScalar(this.frontOffset), this._camera.position.x += this._tempVector2.x, this._camera.position.z += this._tempVector2.z), !this._lockRotation) {
      e.getTarget(this._tempTarget);
      const o = Math.atan2(
        this._tempTarget.x - this._tempVector1.x,
        this._tempTarget.z - this._tempVector1.z
      );
      this._camera.rotation.z = o + Math.PI;
    }
    this._plane.set(this.down, this._tempVector1.y);
    const i = s.background;
    s.background = this.backgroundColor, this.renderer.render(s, this._camera), s.background = i, this.onAfterUpdate.trigger();
  }
  /** {@link Resizeable.getSize} */
  getSize() {
    return this._size;
  }
  /** {@link Resizeable.resize} */
  resize(s = this._size) {
    this._size.copy(s), this.renderer.setSize(s.x, s.y);
    const t = s.x / s.y, e = 1;
    this._camera.left = e * t / -2, this._camera.right = e * t / 2, this._camera.top = e / 2, this._camera.bottom = -e / 2, this._camera.updateProjectionMatrix(), this.onResize.trigger(s);
  }
};
var _s = class _s2 extends et {
  constructor(t) {
    super(t);
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "onDisposed", new D());
    I(this, "enabled", true);
    I(this, "list", /* @__PURE__ */ new Map());
    this.components.add(_s2.uuid, this);
  }
  /**
   * Creates a new {@link MiniMap} instance associated with the given world.
   * If a {@link MiniMap} instance already exists for the given world, an error will be thrown.
   *
   * @param world - The {@link World} for which to create a {@link MiniMap} instance.
   * @returns The newly created {@link MiniMap} instance.
   * @throws Will throw an error if a {@link MiniMap} instance already exists for the given world.
   */
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a minimap!");
    const e = new zr(t);
    return this.list.set(t.uuid, e), e;
  }
  /**
   * Deletes a {@link MiniMap} instance associated with the given world ID.
   * If a {@link MiniMap} instance does not exist for the given ID, nothing happens.
   *
   * @param id - The unique identifier of the world for which to delete the {@link MiniMap} instance.
   * @returns {void}
   */
  delete(t) {
    const e = this.list.get(t);
    e && e.dispose(), this.list.delete(t);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update() {
    for (const [t, e] of this.list)
      e.update();
  }
};
I(_s, "uuid", "39ad6aad-84c8-4adf-a1e0-7f25313a9e7f");
var An = _s;
var Hr = class {
  constructor(s) {
    I(this, "enabled", false);
    I(this, "id", "FirstPerson");
    this.camera = s;
  }
  /** {@link NavigationMode.set} */
  set(s) {
    if (this.enabled = s, s) {
      if (this.camera.projection.current !== "Perspective") {
        this.camera.set("Orbit");
        return;
      }
      this.setupFirstPersonCamera();
    }
  }
  setupFirstPersonCamera() {
    const s = this.camera.controls, t = new Vector3();
    s.distance--, s.getPosition(t), s.minDistance = 1, s.maxDistance = 1, s.distance = 1, s.moveTo(
      t.x,
      t.y,
      t.z
    ), s.truckSpeed = 50, s.mouseButtons.wheel = ot.ACTION.DOLLY, s.touches.two = ot.ACTION.TOUCH_ZOOM_TRUCK;
  }
};
var Wr = class {
  constructor(s) {
    I(this, "enabled", true);
    I(this, "id", "Orbit");
    this.camera = s, this.activateOrbitControls();
  }
  /** {@link NavigationMode.set} */
  set(s) {
    this.enabled = s, s && this.activateOrbitControls();
  }
  activateOrbitControls() {
    const s = this.camera.controls;
    s.minDistance = 1, s.maxDistance = 300;
    const t = new Vector3();
    s.getPosition(t);
    const e = t.length();
    s.distance = e, s.truckSpeed = 2;
    const { rotation: i } = this.camera.three, o = new Vector3(0, 0, -1).applyEuler(i), n = t.addScaledVector(o, e);
    s.moveTo(n.x, n.y, n.z);
  }
};
var kr = class {
  constructor(s) {
    I(this, "enabled", false);
    I(this, "id", "Plan");
    I(this, "mouseAction1");
    I(this, "mouseAction2");
    I(this, "mouseInitialized", false);
    I(this, "defaultAzimuthSpeed");
    I(this, "defaultPolarSpeed");
    this.camera = s, this.defaultAzimuthSpeed = s.controls.azimuthRotateSpeed, this.defaultPolarSpeed = s.controls.polarRotateSpeed;
  }
  /** {@link NavigationMode.set} */
  set(s) {
    this.enabled = s;
    const t = this.camera.controls;
    t.azimuthRotateSpeed = s ? 0 : this.defaultAzimuthSpeed, t.polarRotateSpeed = s ? 0 : this.defaultPolarSpeed, this.mouseInitialized || (this.mouseAction1 = t.touches.one, this.mouseAction2 = t.touches.two, this.mouseInitialized = true), s ? (t.mouseButtons.left = ot.ACTION.TRUCK, t.touches.one = ot.ACTION.TOUCH_TRUCK, t.touches.two = ot.ACTION.TOUCH_ZOOM) : (t.mouseButtons.left = ot.ACTION.ROTATE, t.touches.one = this.mouseAction1, t.touches.two = this.mouseAction2);
  }
};
var Xr = class {
  constructor(s) {
    I(this, "onChanged", new D());
    I(this, "current", "Perspective");
    I(this, "camera");
    I(this, "matchOrthoDistanceEnabled", false);
    I(this, "_component");
    I(this, "_previousDistance", -1);
    this._component = s, this.camera = s.three;
  }
  /**
   * Sets the {@link CameraProjection} of the {@link OrthoPerspectiveCamera}.
   *
   * @param projection - the new projection to set. If it is the current projection,
   * it will have no effect.
   */
  async set(s) {
    this.current !== s && (s === "Orthographic" ? this.setOrthoCamera() : await this.setPerspectiveCamera(), this.onChanged.trigger(this.camera));
  }
  /**
   * Changes the current {@link CameraProjection} from Ortographic to Perspective
   * and vice versa.
   */
  async toggle() {
    const t = this.current === "Perspective" ? "Orthographic" : "Perspective";
    await this.set(t);
  }
  setOrthoCamera() {
    if (this._component.mode === null || this._component.mode.id === "FirstPerson")
      return;
    this._previousDistance = this._component.controls.distance, this._component.controls.distance = 200;
    const s = this.getPerspectiveDims();
    if (!s)
      return;
    const { width: t, height: e } = s;
    this.setupOrthoCamera(e, t), this.camera = this._component.threeOrtho, this.current = "Orthographic";
  }
  getPerspectiveDims() {
    const s = this._component.currentWorld;
    if (!s || !s.renderer)
      return null;
    const t = new Vector3();
    this._component.threePersp.getWorldDirection(t);
    const e = new Vector3();
    this._component.controls.getTarget(e);
    const o = e.clone().sub(this._component.threePersp.position).dot(t), n = s.renderer.getSize(), r = n.x / n.y, a = this._component.threePersp, c = o * 2 * Math.atan(a.fov * (Math.PI / 180) / 2);
    return { width: c * r, height: c };
  }
  setupOrthoCamera(s, t) {
    this._component.controls.mouseButtons.wheel = ot.ACTION.ZOOM, this._component.controls.mouseButtons.middle = ot.ACTION.ZOOM;
    const e = this._component.threePersp, i = this._component.threeOrtho;
    i.zoom = 1, i.left = t / -2, i.right = t / 2, i.top = s / 2, i.bottom = s / -2, i.updateProjectionMatrix(), i.position.copy(e.position), i.quaternion.copy(e.quaternion), this._component.controls.camera = i;
  }
  getDistance() {
    const s = this._component.threePersp, t = this._component.threeOrtho;
    return (t.top - t.bottom) / t.zoom / (2 * Math.atan(s.fov * (Math.PI / 180) / 2));
  }
  async setPerspectiveCamera() {
    this._component.controls.mouseButtons.wheel = ot.ACTION.DOLLY, this._component.controls.mouseButtons.middle = ot.ACTION.DOLLY;
    const s = this._component.threePersp, t = this._component.threeOrtho;
    s.position.copy(t.position), s.quaternion.copy(t.quaternion), this._component.controls.mouseButtons.wheel = ot.ACTION.DOLLY, this.matchOrthoDistanceEnabled ? this._component.controls.distance = this.getDistance() : this._component.controls.distance = this._previousDistance, await this._component.controls.zoomTo(1), s.updateProjectionMatrix(), this._component.controls.camera = s, this.camera = s, this.current = "Perspective";
  }
};
var oa = class extends We {
  constructor(t) {
    super(t);
    I(this, "projection");
    I(this, "threeOrtho");
    I(this, "threePersp");
    I(this, "_userInputButtons", {});
    I(this, "_frustumSize", 50);
    I(this, "_navigationModes", /* @__PURE__ */ new Map());
    I(this, "_mode", null);
    I(this, "previousSize", null);
    this.threePersp = this.three, this.threeOrtho = this.newOrthoCamera(), this.projection = new Xr(this), this.onAspectUpdated.add(() => {
      this.setOrthoPerspCameraAspect();
    }), this.projection.onChanged.add(
      (e) => {
        this.three = e, this.updateAspect();
      }
    ), this.onWorldChanged.add(({ action: e }) => {
      e === "added" && (this._navigationModes.clear(), this._navigationModes.set("Orbit", new Wr(this)), this._navigationModes.set("FirstPerson", new Hr(this)), this._navigationModes.set("Plan", new kr(this)), this._mode = this._navigationModes.get("Orbit"), this.mode.set(true, { preventTargetAdjustment: true }), this.currentWorld && this.currentWorld.renderer && (this.previousSize = this.currentWorld.renderer.getSize().clone()));
    });
  }
  /**
   * Getter for the current navigation mode.
   * Throws an error if the mode is not found or the camera is not initialized.
   *
   * @returns {NavigationMode} The current navigation mode.
   *
   * @throws {Error} Throws an error if the mode is not found or the camera is not initialized.
   */
  get mode() {
    if (!this._mode)
      throw new Error("Mode not found, camera not initialized");
    return this._mode;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose(), this.threeOrtho.removeFromParent();
  }
  /**
   * Sets a new {@link NavigationMode} and disables the previous one.
   *
   * @param mode - The {@link NavigationMode} to set.
   */
  set(t) {
    if (this.mode !== null && this.mode.id !== t) {
      if (this.mode.set(false), !this._navigationModes.has(t))
        throw new Error("The specified mode does not exist!");
      this._mode = this._navigationModes.get(t), this.mode.set(true);
    }
  }
  /**
   * Make the camera view fit all the specified meshes.
   *
   * @param meshes the meshes to fit. If it is not defined, it will
   * evaluate {@link Components.meshes}.
   * @param offset the distance to the fit object
   */
  async fit(t, e = 1.5) {
    if (!this.enabled)
      return;
    const i = Number.MAX_VALUE, o = Number.MIN_VALUE, n = new Vector3(i, i, i), r = new Vector3(o, o, o);
    for (const u of t) {
      const f = new Box3().setFromObject(u);
      f.min.x < n.x && (n.x = f.min.x), f.min.y < n.y && (n.y = f.min.y), f.min.z < n.z && (n.z = f.min.z), f.max.x > r.x && (r.x = f.max.x), f.max.y > r.y && (r.y = f.max.y), f.max.z > r.z && (r.z = f.max.z);
    }
    const a = new Box3(n, r), c = new Vector3();
    a.getSize(c);
    const h = new Vector3();
    a.getCenter(h);
    const d = Math.max(c.x, c.y, c.z) * e, E = new Sphere(h, d);
    await this.controls.fitToSphere(E, true);
  }
  /**
   * Allows or prevents all user input.
   *
   * @param active - whether to enable or disable user inputs.
   */
  setUserInput(t) {
    t ? this.enableUserInput() : this.disableUserInput();
  }
  disableUserInput() {
    this._userInputButtons.left = this.controls.mouseButtons.left, this._userInputButtons.right = this.controls.mouseButtons.right, this._userInputButtons.middle = this.controls.mouseButtons.middle, this._userInputButtons.wheel = this.controls.mouseButtons.wheel, this.controls.mouseButtons.left = 0, this.controls.mouseButtons.right = 0, this.controls.mouseButtons.middle = 0, this.controls.mouseButtons.wheel = 0;
  }
  enableUserInput() {
    Object.keys(this._userInputButtons).length !== 0 && (this.controls.mouseButtons.left = this._userInputButtons.left, this.controls.mouseButtons.right = this._userInputButtons.right, this.controls.mouseButtons.middle = this._userInputButtons.middle, this.controls.mouseButtons.wheel = this._userInputButtons.wheel);
  }
  newOrthoCamera() {
    const t = window.innerWidth / window.innerHeight;
    return new OrthographicCamera(
      this._frustumSize * t / -2,
      this._frustumSize * t / 2,
      this._frustumSize / 2,
      this._frustumSize / -2,
      0.1,
      1e3
    );
  }
  setOrthoPerspCameraAspect() {
    if (!this.currentWorld || !this.currentWorld.renderer || !this.previousSize)
      return;
    const t = this.currentWorld.renderer.getSize(), e = this.threeOrtho.top, i = this.threeOrtho.right, o = t.y / this.previousSize.y, n = t.x / this.previousSize.x, r = e * o, a = i * n;
    this.threeOrtho.left = -a, this.threeOrtho.right = a, this.threeOrtho.top = r, this.threeOrtho.bottom = -r, this.threeOrtho.updateProjectionMatrix(), this.previousSize.copy(t);
  }
};
var Zr = /* @__PURE__ */ new Map([
  [
    IFCRELAGGREGATES,
    {
      forRelating: "IsDecomposedBy",
      forRelated: "Decomposes"
    }
  ],
  [
    IFCRELASSOCIATESMATERIAL,
    {
      forRelating: "AssociatedTo",
      forRelated: "HasAssociations"
    }
  ],
  [
    IFCRELASSOCIATESCLASSIFICATION,
    {
      forRelating: "ClassificationForObjects",
      forRelated: "HasAssociations"
    }
  ],
  [
    IFCRELASSIGNSTOGROUP,
    {
      forRelating: "IsGroupedBy",
      forRelated: "HasAssignments"
    }
  ],
  [
    IFCRELDEFINESBYPROPERTIES,
    {
      forRelated: "IsDefinedBy",
      forRelating: "DefinesOcurrence"
    }
  ],
  [
    IFCRELDEFINESBYTYPE,
    {
      forRelated: "IsTypedBy",
      forRelating: "Types"
    }
  ],
  [
    IFCRELDEFINESBYTEMPLATE,
    {
      forRelated: "IsDefinedBy",
      forRelating: "Defines"
    }
  ],
  [
    IFCRELCONTAINEDINSPATIALSTRUCTURE,
    {
      forRelated: "ContainedInStructure",
      forRelating: "ContainsElements"
    }
  ]
]);
var Ve = class Ve2 extends et {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "onRelationsIndexed", new D());
    I(this, "relationMaps", {});
    I(this, "enabled", true);
    I(this, "_relToAttributesMap", Zr);
    I(this, "_inverseAttributes", [
      "IsDecomposedBy",
      "Decomposes",
      "AssociatedTo",
      "HasAssociations",
      "ClassificationForObjects",
      "IsGroupedBy",
      "HasAssignments",
      "IsDefinedBy",
      "DefinesOcurrence",
      "IsTypedBy",
      "Types",
      "Defines",
      "ContainedInStructure",
      "ContainsElements"
    ]);
    I(this, "_ifcRels", [
      IFCRELAGGREGATES,
      IFCRELASSOCIATESMATERIAL,
      IFCRELASSOCIATESCLASSIFICATION,
      IFCRELASSIGNSTOGROUP,
      IFCRELDEFINESBYPROPERTIES,
      IFCRELDEFINESBYTYPE,
      IFCRELDEFINESBYTEMPLATE,
      IFCRELCONTAINEDINSPATIALSTRUCTURE
    ]);
    I(this, "onFragmentsDisposed", (t2) => {
      delete this.relationMaps[t2.groupID];
    });
    this.components.add(Ve2.uuid, this), t.get(ht).onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  indexRelations(t, e, i, o) {
    const n = Object.keys(e).find(
      (E) => E.startsWith("Relating")
    ), r = Object.keys(e).find(
      (E) => E.startsWith("Related")
    );
    if (!(n && r))
      return;
    const a = e[n].value, c = e[r].map((E) => E.value), h = t.get(a) ?? /* @__PURE__ */ new Map(), d = this.getAttributeIndex(o);
    d !== null && (h.set(d, c), t.set(a, h));
    for (const E of c) {
      const u = t.get(E) ?? /* @__PURE__ */ new Map(), f = this.getAttributeIndex(i);
      if (!f)
        continue;
      const T = u.get(f) ?? [];
      T.push(a), u.set(f, T), t.set(E, u);
    }
  }
  getAttributeIndex(t) {
    const e = this._inverseAttributes.indexOf(t);
    return e === -1 ? null : e;
  }
  /**
   * Adds a relation map to the model's relations map.
   *
   * @param model - The `FragmentsGroup` model to which the relation map will be added.
   * @param relationMap - The `RelationsMap` to be added to the model's relations map.
   *
   * @fires onRelationsIndexed - Triggers an event with the model's UUID and the added relation map.
   */
  setRelationMap(t, e) {
    this.relationMaps[t.uuid] = e, this.onRelationsIndexed.trigger({
      modelID: t.uuid,
      relationsMap: e
    });
  }
  /**
   * Processes a given model to index its IFC entities relations based on predefined inverse attributes.
   * This method iterates through each specified inverse attribute, retrieves the corresponding relations,
   * and maps them in a structured way to facilitate quick access to related entities.
   *
   * The process involves querying the model for each relation type associated with the inverse attributes
   * and updating the internal relationMaps with the relationships found. This map is keyed by the model's UUID
   * and contains a nested map where each key is an entity's expressID and its value is another map.
   * This inner map's keys are the indices of the inverse attributes, and its values are arrays of expressIDs
   * of entities that are related through that attribute.
   *
   * @param model The `FragmentsGroup` model to be processed. It must have properties loaded.
   * @returns A promise that resolves to the relations map for the processed model. This map is a detailed
   * representation of the relations indexed by entity expressIDs and relation types.
   * @throws An error if the model does not have properties loaded.
   */
  async process(t) {
    if (!t.hasProperties)
      throw new Error("FragmentsGroup properties not found");
    let e = this.relationMaps[t.uuid];
    if (e)
      return e;
    e = /* @__PURE__ */ new Map();
    for (const i of this._ifcRels) {
      const o = await t.getAllPropertiesOfType(i);
      if (!o)
        continue;
      const n = this._relToAttributesMap.get(i);
      if (!n)
        continue;
      const { forRelated: r, forRelating: a } = n;
      for (const c in o) {
        const h = o[c];
        this.indexRelations(e, h, r, a);
      }
    }
    return this.setRelationMap(t, e), e;
  }
  /**
   * Processes a given model from a WebIfc API to index its IFC entities relations.
   *
   * @param ifcApi - The WebIfc API instance from which to retrieve the model's properties.
   * @param modelID - The unique identifier of the model within the WebIfc API.
   * @returns A promise that resolves to the relations map for the processed model.
   *          This map is a detailed representation of the relations indexed by entity expressIDs and relation types.
   */
  async processFromWebIfc(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (const o of this._ifcRels) {
      const n = this._relToAttributesMap.get(o);
      if (!n)
        continue;
      const { forRelated: r, forRelating: a } = n, c = t.GetLineIDsWithType(e, o);
      for (let h = 0; h < c.size(); h++) {
        const d = await t.properties.getItemProperties(
          e,
          c.get(h)
        );
        this.indexRelations(i, d, r, a);
      }
    }
    return this.onRelationsIndexed.trigger({
      modelID: e.toString(),
      relationsMap: i
    }), i;
  }
  /**
   * Retrieves the relations of a specific entity within a model based on the given relation name.
   * This method searches the indexed relation maps for the specified model and entity,
   * returning the IDs of related entities if a match is found.
   *
   * @param model The `FragmentsGroup` model containing the entity.
   * @param expressID The unique identifier of the entity within the model.
   * @param relationName The IFC schema inverse attribute of the relation to search for (e.g., "IsDefinedBy", "ContainsElements").
   * @returns An array of express IDs representing the related entities, or `null` if no relations are found
   * or the specified relation name is not indexed.
   */
  getEntityRelations(t, e, i) {
    const o = this.relationMaps[t.uuid];
    if (!o)
      throw new Error(
        `IfcRelationsIndexer: model ${t.uuid} has no relations indexed.`
      );
    const n = o.get(e), r = this.getAttributeIndex(i);
    if (n === void 0 || r === null)
      return null;
    const a = n.get(r);
    return a || null;
  }
  /**
   * Serializes the relations of a given relation map into a JSON string.
   * This method iterates through the relations in the given map, organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param relationMap - The map of relations to be serialized. The map keys are expressIDs of entities, and the values are maps where each key is a relation type ID and its value is an array of expressIDs of entities related through that relation type.
   * @returns A JSON string representing the serialized relations of the given relation map.
   */
  serializeRelations(t) {
    const e = {};
    for (const [i, o] of t.entries()) {
      e[i] || (e[i] = {});
      for (const [n, r] of o.entries())
        e[i][n] = r;
    }
    return JSON.stringify(e);
  }
  /**
   * Serializes the relations of a specific model into a JSON string.
   * This method iterates through the relations indexed for the given model,
   * organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param model The `FragmentsGroup` model whose relations are to be serialized.
   * @returns A JSON string representing the serialized relations of the specified model.
   * If the model has no indexed relations, `null` is returned.
   */
  serializeModelRelations(t) {
    const e = this.relationMaps[t.uuid];
    return e ? this.serializeRelations(e) : null;
  }
  /**
   * Serializes all relations of every model processed by the indexer into a JSON string.
   * This method iterates through each model's relations indexed in `relationMaps`, organizing them
   * into a structured JSON object. Each top-level key in this object corresponds to a model's UUID,
   * and its value is another object mapping entity expressIDs to their related entities, categorized
   * by relation types. The structure facilitates easy access to any entity's relations across all models.
   *
   * @returns A JSON string representing the serialized relations of all models processed by the indexer.
   *          If no relations have been indexed, an empty object is returned as a JSON string.
   */
  serializeAllRelations() {
    const t = {};
    for (const e in this.relationMaps) {
      const i = this.relationMaps[e], o = {};
      for (const [n, r] of i.entries()) {
        o[n] || (o[n] = {});
        for (const [a, c] of r.entries())
          o[n][a] = c;
      }
      t[e] = o;
    }
    return JSON.stringify(t);
  }
  /**
   * Converts a JSON string representing relations between entities into a structured map.
   * This method parses the JSON string to reconstruct the relations map that indexes
   * entity relations by their express IDs. The outer map keys are the express IDs of entities,
   * and the values are maps where each key is a relation type ID and its value is an array
   * of express IDs of entities related through that relation type.
   *
   * @param json The JSON string to be parsed into the relations map.
   * @returns A `Map` where the key is the express ID of an entity as a number, and the value
   * is another `Map`. This inner map's key is the relation type ID as a number, and its value
   * is an array of express IDs (as numbers) of entities related through that relation type.
   */
  getRelationsMapFromJSON(t) {
    const e = JSON.parse(t), i = /* @__PURE__ */ new Map();
    for (const o in e) {
      const n = e[o], r = /* @__PURE__ */ new Map();
      for (const a in n)
        r.set(Number(a), n[a]);
      i.set(Number(o), r);
    }
    return i;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.relationMaps = {}, this.components.get(ht).onFragmentsDisposed.remove(this.onFragmentsDisposed), this.onDisposed.trigger(Ve2.uuid), this.onDisposed.reset();
  }
  /**
   * Adds relations between an entity and other entities in a BIM model.
   *
   * @param model - The BIM model to which the relations will be added.
   * @param expressID - The expressID of the entity within the model.
   * @param relationName - The IFC schema inverse attribute of the relation to add (e.g., "IsDefinedBy", "ContainsElements").
   * @param relIDs - The expressIDs of the related entities within the model.
   *
   * @throws An error if the relation name is not a valid relation name.
   */
  addEntityRelations(t, e, i, ...o) {
    const n = this.getEntityRelations(
      t,
      e,
      i
    );
    if (n)
      n.push(...o);
    else {
      const r = this.getAttributeIndex(i);
      if (!r)
        throw new Error(
          `IfcRelationsIndexer: ${i} is not a valid relation name.`
        );
      const a = this.relationMaps[t.uuid].get(e);
      a == null || a.set(r, o);
    }
  }
  /**
   * Gets the children of the given element recursively. E.g. in a model with project - site - building - storeys - rooms, passing a storey will include all its children and the children of the rooms contained in it.
   *
   * @param model The BIM model whose children to get.
   * @param expressID The expressID of the item whose children to get.
   * @param found An optional parameter that includes a set of expressIDs where the found element IDs will be added.
   *
   * @returns A `Set` with the expressIDs of the found items.
   */
  getEntityChildren(t, e, i = /* @__PURE__ */ new Set()) {
    if (i.add(e), this.relationMaps[t.uuid] === void 0)
      throw new Error(
        "The provided model has no indices. You have to generate them first."
      );
    const n = this.getEntityRelations(
      t,
      e,
      "IsDecomposedBy"
    );
    if (n)
      for (const a of n)
        this.getEntityChildren(t, a, i);
    const r = this.getEntityRelations(t, e, "ContainsElements");
    if (r)
      for (const a of r)
        this.getEntityChildren(t, a, i);
    return i;
  }
};
I(Ve, "uuid", "23a889ab-83b3-44a4-8bee-ead83438370b");
var pe = Ve;
var Ns = class Ns2 extends et {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "onFragmentsLoaded", new D());
    I(this, "onFragmentsDisposed", new D());
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "groups", /* @__PURE__ */ new Map());
    I(this, "baseCoordinationModel", "");
    I(this, "baseCoordinationMatrix", new Matrix4());
    I(this, "enabled", true);
    I(this, "_loader", new fn());
    this.components.add(Ns2.uuid, this);
  }
  /**
   * Getter for the meshes of all fragments in the FragmentsManager.
   * It iterates over the fragments in the list and pushes their meshes into an array.
   * @returns {THREE.Mesh[]} An array of THREE.Mesh objects representing the fragments.
   */
  get meshes() {
    const t = [];
    for (const [e, i] of this.list)
      t.push(i.mesh);
    return t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.groups)
      e.dispose(true);
    this.baseCoordinationModel = "", this.groups.clear(), this.list.clear(), this.onFragmentsLoaded.reset(), this.onFragmentsDisposed.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Dispose of a specific fragment group.
   * This method removes the group from the groups map, deletes all fragments within the group from the list,
   * disposes of the group, and triggers the onFragmentsDisposed event.
   *
   * @param group - The fragment group to be disposed.
   */
  disposeGroup(t) {
    const { uuid: e } = t, i = [];
    for (const o of t.items)
      i.push(o.id), this.list.delete(o.id);
    t.dispose(true), this.groups.delete(t.uuid), this.onFragmentsDisposed.trigger({
      groupID: e,
      fragmentIDs: i
    });
  }
  /**
   * Loads a binary file that contain fragment geometry.
   * @param data - The binary data to load.
   * @param config - Optional configuration for loading.
   * @param config.coordinate - Whether to apply coordinate transformation. Default is true.
   * @param config.properties - Ifc properties to set on the loaded fragments. Not to be used when streaming.
   * @returns The loaded FragmentsGroup.
   */
  load(t, e) {
    const o = { ...{ coordinate: true }, ...e }, { coordinate: n, name: r, properties: a, relationsMap: c } = o, h = this._loader.import(t);
    r && (h.name = r);
    for (const d of h.items)
      d.group = h, this.list.set(d.id, d);
    return n && this.coordinate([h]), this.groups.set(h.uuid, h), a && h.setLocalProperties(a), c && this.components.get(pe).setRelationMap(h, c), this.onFragmentsLoaded.trigger(h), h;
  }
  /**
   * Export the specified fragmentsgroup to binary data.
   * @param group - the fragments group to be exported.
   * @returns the exported data as binary buffer.
   */
  export(t) {
    return this._loader.export(t);
  }
  /**
   * Gets a map of model IDs to sets of express IDs for the given fragment ID map.
   * @param fragmentIdMap - A map of fragment IDs to their corresponding express IDs.
   * @returns A map of model IDs to sets of express IDs.
   */
  getModelIdMap(t) {
    const e = {};
    for (const i in t) {
      const o = this.list.get(i);
      if (!(o && o.group))
        continue;
      const n = o.group;
      n.uuid in e || (e[n.uuid] = /* @__PURE__ */ new Set());
      const r = t[i];
      for (const a of r)
        e[n.uuid].add(a);
    }
    return e;
  }
  /**
   * Converts a map of model IDs to sets of express IDs to a fragment ID map.
   * @param modelIdMap - A map of model IDs to their corresponding express IDs.
   * @returns A fragment ID map.
   * @remarks
   * This method iterates through the provided model ID map, retrieves the corresponding model from the `groups` map,
   * and then calls the `getFragmentMap` method of the model to obtain a fragment ID map for the given express IDs.
   * The fragment ID maps are then merged into a single map and returned.
   * If a model with a given ID is not found in the `groups` map, the method skips that model and continues with the next one.
   */
  modelIdToFragmentIdMap(t) {
    let e = {};
    for (const i in t) {
      const o = this.groups.get(i);
      if (!o)
        continue;
      const n = t[i], r = o.getFragmentMap(n);
      e = { ...e, ...r };
    }
    return e;
  }
  /**
   * Applies coordinate transformation to the provided models.
   * If no models are provided, all groups are used.
   * The first model in the list becomes the base model for coordinate transformation.
   * All other models are then transformed to match the base model's coordinate system.
   *
   * @param models - The models to apply coordinate transformation to.
   * If not provided, all models are used.
   */
  coordinate(t = Array.from(this.groups.values())) {
    if (this.baseCoordinationModel.length === 0) {
      const i = t.pop();
      if (!i)
        return;
      this.baseCoordinationModel = i.uuid, this.baseCoordinationMatrix = i.coordinationMatrix.clone();
    }
    if (t.length)
      for (const i of t)
        i.coordinationMatrix.equals(this.baseCoordinationMatrix) || (i.position.set(0, 0, 0), i.rotation.set(0, 0, 0), i.scale.set(1, 1, 1), i.updateMatrix(), this.applyBaseCoordinateSystem(i, i.coordinationMatrix));
  }
  /**
   * Applies the base coordinate system to the provided object.
   *
   * This function takes an object and its original coordinate system as input.
   * It then inverts the original coordinate system and applies the base coordinate system
   * to the object. This ensures that the object's position, rotation, and scale are
   * transformed to match the base coordinate system (which is taken from the first model loaded).
   *
   * @param object - The object to which the base coordinate system will be applied.
   * This should be an instance of THREE.Object3D.
   *
   * @param originalCoordinateSystem - The original coordinate system of the object.
   * This should be a THREE.Matrix4 representing the object's transformation matrix.
   */
  applyBaseCoordinateSystem(t, e) {
    t.applyMatrix4(e.clone().invert()), t.applyMatrix4(this.baseCoordinationMatrix);
  }
};
I(Ns, "uuid", "fef46874-46a3-461b-8c44-2922ab77c806");
var ht = Ns;
var At = class At2 extends et {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    I(this, "onDisposed", new D());
    I(this, "_absoluteMin");
    I(this, "_absoluteMax");
    I(this, "_meshes", []);
    this.components.add(At2.uuid, this), this._absoluteMin = At2.newBound(true), this._absoluteMax = At2.newBound(false);
  }
  /**
   * A static method to calculate the dimensions of a given bounding box.
   *
   * @param bbox - The bounding box to calculate the dimensions for.
   * @returns An object containing the width, height, depth, and center of the bounding box.
   */
  static getDimensions(t) {
    const { min: e, max: i } = t, o = Math.abs(i.x - e.x), n = Math.abs(i.y - e.y), r = Math.abs(i.z - e.z), a = new Vector3();
    return a.subVectors(i, e).divideScalar(2).add(e), { width: o, height: n, depth: r, center: a };
  }
  /**
   * A static method to create a new bounding box boundary.
   *
   * @param positive - A boolean indicating whether to create a boundary for positive or negative values.
   * @returns A new THREE.Vector3 representing the boundary.
   *
   * @remarks
   * This method is used to create a new boundary for calculating bounding boxes.
   * It sets the x, y, and z components of the returned vector to positive or negative infinity,
   * depending on the value of the `positive` parameter.
   *
   * @example
   * ```typescript
   * const positiveBound = BoundingBoxer.newBound(true);
   * console.log(positiveBound); // Output: Vector3 { x: Infinity, y: Infinity, z: Infinity }
   *
   * const negativeBound = BoundingBoxer.newBound(false);
   * console.log(negativeBound); // Output: Vector3 { x: -Infinity, y: -Infinity, z: -Infinity }
   * ```
   */
  static newBound(t) {
    const e = t ? 1 : -1;
    return new Vector3(
      e * Number.MAX_VALUE,
      e * Number.MAX_VALUE,
      e * Number.MAX_VALUE
    );
  }
  /**
   * A static method to calculate the bounding box of a set of points.
   *
   * @param points - An array of THREE.Vector3 representing the points.
   * @param min - An optional THREE.Vector3 representing the minimum bounds. If not provided, it will be calculated.
   * @param max - An optional THREE.Vector3 representing the maximum bounds. If not provided, it will be calculated.
   * @returns A THREE.Box3 representing the bounding box of the given points.
   *
   * @remarks
   * This method calculates the bounding box of a set of points by iterating through each point and updating the minimum and maximum bounds accordingly.
   * If the `min` or `max` parameters are provided, they will be used as the initial bounds. Otherwise, the initial bounds will be set to positive and negative infinity.
   *
   * @example
   * ```typescript
   * const points = [
   *   new THREE.Vector3(1, 2, 3),
   *   new THREE.Vector3(4, 5, 6),
   *   new THREE.Vector3(7, 8, 9),
   * ];
   *
   * const bbox = BoundingBoxer.getBounds(points);
   * console.log(bbox); // Output: Box3 { min: Vector3 { x: 1, y: 2, z: 3 }, max: Vector3 { x: 7, y: 8, z: 9 } }
   * ```
   */
  static getBounds(t, e, i) {
    const o = i || this.newBound(false), n = e || this.newBound(true);
    for (const r of t)
      r.x < n.x && (n.x = r.x), r.y < n.y && (n.y = r.y), r.z < n.z && (n.z = r.z), r.x > o.x && (o.x = r.x), r.y > o.y && (o.y = r.y), r.z > o.z && (o.z = r.z);
    return new Box3(e, i);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const t = this.components.get(zt);
    for (const e of this._meshes)
      t.destroy(e);
    this._meshes = [], this.onDisposed.trigger(At2.uuid), this.onDisposed.reset();
  }
  /**
   * Returns the bounding box of the calculated fragments.
   *
   * @returns A new THREE.Box3 instance representing the bounding box.
   *
   * @remarks
   * This method clones the internal minimum and maximum vectors and returns a new THREE.Box3 instance.
   * The returned box represents the bounding box of the calculated fragments.
   *
   * @example
   * ```typescript
   * const boundingBox = boundingBoxer.get();
   * console.log(boundingBox); // Output: Box3 { min: Vector3 { x: -10, y: -10, z: -10 }, max: Vector3 { x: 10, y: 10, z: 10 } }
   * ```
   */
  get() {
    const t = this._absoluteMin.clone(), e = this._absoluteMax.clone();
    return new Box3(t, e);
  }
  /**
   * Calculates and returns a sphere that encompasses the entire bounding box.
   *
   * @returns A new THREE.Sphere instance representing the calculated sphere.
   *
   * @remarks
   * This method calculates the center and radius of a sphere that encompasses the entire bounding box.
   * The center is calculated as the midpoint between the minimum and maximum bounds of the bounding box.
   * The radius is calculated as the distance from the center to the minimum bound.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * const boundingSphere = boundingBoxer.getSphere();
   * console.log(boundingSphere); // Output: Sphere { center: Vector3 { x: 0, y: 0, z: 0 }, radius: 10 }
   * ```
   */
  getSphere() {
    const t = this._absoluteMin.clone(), e = this._absoluteMax.clone(), i = Math.abs((e.x - t.x) / 2), o = Math.abs((e.y - t.y) / 2), n = Math.abs((e.z - t.z) / 2), r = new Vector3(t.x + i, t.y + o, t.z + n), a = r.distanceTo(t);
    return new Sphere(r, a);
  }
  /**
   * Returns a THREE.Mesh instance representing the bounding box.
   *
   * @returns A new THREE.Mesh instance representing the bounding box.
   *
   * @remarks
   * This method calculates the dimensions of the bounding box using the `getDimensions` method.
   * It then creates a new THREE.BoxGeometry with the calculated dimensions.
   * A new THREE.Mesh is created using the box geometry, and it is added to the `_meshes` array.
   * The position of the mesh is set to the center of the bounding box.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * const boundingBoxMesh = boundingBoxer.getMesh();
   * scene.add(boundingBoxMesh);
   * ```
   */
  getMesh() {
    const t = new Box3(this._absoluteMin, this._absoluteMax), e = At2.getDimensions(t), { width: i, height: o, depth: n, center: r } = e, a = new BoxGeometry(i, o, n), c = new Mesh(a);
    return this._meshes.push(c), c.position.copy(r), c;
  }
  /**
   * Resets the internal minimum and maximum vectors to positive and negative infinity, respectively.
   * This method is used to prepare the BoundingBoxer for a new set of fragments.
   *
   * @remarks
   * This method is called when a new set of fragments is added to the BoundingBoxer.
   * It ensures that the bounding box calculations are accurate and up-to-date.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * // ...
   * boundingBoxer.reset();
   * ```
   */
  reset() {
    this._absoluteMin = At2.newBound(true), this._absoluteMax = At2.newBound(false);
  }
  /**
   * Adds a FragmentsGroup to the BoundingBoxer.
   *
   * @param group - The FragmentsGroup to add.
   *
   * @remarks
   * This method iterates through each fragment in the provided FragmentsGroup,
   * and calls the `addMesh` method for each fragment's mesh.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * ```
   */
  add(t) {
    for (const e of t.items)
      this.addMesh(e.mesh);
  }
  /**
   * Adds a mesh to the BoundingBoxer and calculates the bounding box.
   *
   * @param mesh - The mesh to add. It can be an instance of THREE.InstancedMesh, THREE.Mesh, or FRAGS.CurveMesh.
   * @param itemIDs - An optional iterable of numbers representing the item IDs.
   *
   * @remarks
   * This method calculates the bounding box of the provided mesh and updates the internal minimum and maximum vectors.
   * If the mesh is an instance of THREE.InstancedMesh, it calculates the bounding box for each instance.
   * If the mesh is an instance of FRAGS.FragmentMesh and itemIDs are provided, it calculates the bounding box for the specified item IDs.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.addMesh(mesh);
   * ```
   */
  addMesh(t, e) {
    if (!t.geometry.index)
      return;
    const i = At2.getFragmentBounds(t);
    t.updateMatrixWorld();
    const o = t.matrixWorld, n = new Matrix4(), r = t instanceof InstancedMesh, a = /* @__PURE__ */ new Set();
    if (e && t instanceof le)
      for (const c of e) {
        const h = t.fragment.getInstancesIDs(c);
        if (h)
          for (const d of h)
            a.add(d);
      }
    else
      a.add(0);
    for (const c of a) {
      const h = i.min.clone(), d = i.max.clone();
      r && (t.getMatrixAt(c, n), h.applyMatrix4(n), d.applyMatrix4(n)), h.applyMatrix4(o), d.applyMatrix4(o), h.x < this._absoluteMin.x && (this._absoluteMin.x = h.x), h.y < this._absoluteMin.y && (this._absoluteMin.y = h.y), h.z < this._absoluteMin.z && (this._absoluteMin.z = h.z), h.x > this._absoluteMax.x && (this._absoluteMax.x = h.x), h.y > this._absoluteMax.y && (this._absoluteMax.y = h.y), h.z > this._absoluteMax.z && (this._absoluteMax.z = h.z), d.x > this._absoluteMax.x && (this._absoluteMax.x = d.x), d.y > this._absoluteMax.y && (this._absoluteMax.y = d.y), d.z > this._absoluteMax.z && (this._absoluteMax.z = d.z), d.x < this._absoluteMin.x && (this._absoluteMin.x = d.x), d.y < this._absoluteMin.y && (this._absoluteMin.y = d.y), d.z < this._absoluteMin.z && (this._absoluteMin.z = d.z);
    }
  }
  /**
   * Uses a FragmentIdMap to add its meshes to the bb calculation.
   *
   * This method iterates through the provided `fragmentIdMap`, retrieves the corresponding fragment from the `FragmentsManager`,
   * and then calls the `addMesh` method for each fragment's mesh, passing the expression IDs as the second parameter.
   *
   * @param fragmentIdMap - A mapping of fragment IDs to their corresponding expression IDs.
   *
   * @remarks
   * This method is used to add a mapping of fragment IDs to their corresponding expression IDs.
   * It ensures that the bounding box calculations are accurate and up-to-date by updating the internal minimum and maximum vectors.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * const fragmentIdMap: FRAGS.FragmentIdMap = {
   *   '5991fa75-2eef-4825-90b3-85177f51a9c9': [123, 245, 389],
   *   '3469077e-39bf-4fc9-b3e6-4a1d78ad52b0': [454, 587, 612],
   * };
   * boundingBoxer.addFragmentIdMap(fragmentIdMap);
   * ```
   */
  addFragmentIdMap(t) {
    const e = this.components.get(ht);
    for (const i in t) {
      const o = e.list.get(i);
      if (!o)
        continue;
      const n = t[i];
      this.addMesh(o.mesh, n);
    }
  }
  static getFragmentBounds(t) {
    const e = t.geometry.attributes.position, i = Number.MAX_VALUE, o = -i, n = new Vector3(i, i, i), r = new Vector3(o, o, o);
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const a = Array.from(t.geometry.index.array);
    for (let c = 0; c < a.length; c++) {
      if (c % 3 === 0 && a[c] === 0 && a[c + 1] === 0 && a[c + 2] === 0) {
        c += 2;
        continue;
      }
      const h = a[c], d = e.getX(h), E = e.getY(h), u = e.getZ(h);
      d < n.x && (n.x = d), E < n.y && (n.y = E), u < n.z && (n.z = u), d > r.x && (r.x = d), E > r.y && (r.y = E), u > r.z && (r.z = u);
    }
    return new Box3(n, r);
  }
};
I(At, "uuid", "d1444724-dba6-4cdd-a0c7-68ee1450d166");
var Fn = At;
var vn = /* @__PURE__ */ new Set([
  1123145078,
  574549367,
  1675464909,
  2059837836,
  3798115385,
  32440307,
  3125803723,
  3207858831,
  2740243338,
  2624227202,
  4240577450,
  3615266464,
  3724593414,
  220341763,
  477187591,
  1878645084,
  1300840506,
  3303107099,
  1607154358,
  1878645084,
  846575682,
  1351298697,
  2417041796,
  3049322572,
  3331915920,
  1416205885,
  776857604,
  3285139300,
  3958052878,
  2827736869,
  2732653382,
  673634403,
  3448662350,
  4142052618,
  2924175390,
  803316827,
  2556980723,
  1809719519,
  2205249479,
  807026263,
  3737207727,
  1660063152,
  2347385850,
  2705031697,
  3732776249,
  2485617015,
  2611217952,
  1704287377,
  2937912522,
  2770003689,
  1281925730,
  1484403080,
  3448662350,
  4142052618,
  3800577675,
  4006246654,
  3590301190,
  1383045692,
  2775532180,
  2047409740,
  370225590,
  3593883385,
  2665983363,
  4124623270,
  812098782,
  3649129432,
  987898635,
  1105321065,
  3510044353,
  1635779807,
  2603310189,
  3406155212,
  1310608509,
  4261334040,
  2736907675,
  3649129432,
  1136057603,
  1260505505,
  4182860854,
  2713105998,
  2898889636,
  59481748,
  3749851601,
  3486308946,
  3150382593,
  1062206242,
  3264961684,
  15328376,
  1485152156,
  370225590,
  1981873012,
  2859738748,
  45288368,
  2614616156,
  2732653382,
  775493141,
  2147822146,
  2601014836,
  2629017746,
  1186437898,
  2367409068,
  1213902940,
  3632507154,
  3900360178,
  476780140,
  1472233963,
  2804161546,
  3008276851,
  738692330,
  374418227,
  315944413,
  3905492369,
  3570813810,
  2571569899,
  178912537,
  2294589976,
  1437953363,
  2133299955,
  572779678,
  3092502836,
  388784114,
  2624227202,
  1425443689,
  3057273783,
  2347385850,
  1682466193,
  2519244187,
  2839578677,
  3958567839,
  2513912981,
  2830218821,
  427810014
]);
var Ps = class Ps2 extends et {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    t.add(Ps2.uuid, this);
  }
  /**
   * Exports all the properties of an IFC into an array of JS objects.
   * @param webIfc The instance of [web-ifc](https://github.com/ThatOpen/engine_web-ifc) to use.
   * @param modelID ID of the IFC model whose properties to extract.
   * @param indirect whether to get the indirect relationships as well.
   * @param recursiveSpatial whether to get the properties of spatial items recursively
   * to make the location data available (e.g. absolute position of building).
   */
  async export(t, e, i = false, o = true) {
    const n = {}, r = new Set(t.GetIfcEntityList(e)), a = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const c of a)
      r.add(c);
    for (const c of r) {
      if (vn.has(c))
        continue;
      const h = a.has(c) && o, d = t.GetLineIDsWithType(e, c);
      for (const E of d) {
        const u = t.GetLine(0, E, h, i);
        n[u.expressID] = u;
      }
    }
    return n;
  }
};
I(Ps, "uuid", "b32c4332-cd67-436e-ba7f-196646c7a635");
var mi = Ps;
var Qr = {
  103090709: "IFCPROJECT",
  4097777520: "IFCSITE",
  4031249490: "IFCBUILDING",
  3124254112: "IFCBUILDINGSTOREY",
  3856911033: "IFCSPACE",
  1674181508: "IFCANNOTATION",
  25142252: "IFCCONTROLLER",
  32344328: "IFCBOILER",
  76236018: "IFCLAMP",
  90941305: "IFCPUMP",
  177149247: "IFCAIRTERMINALBOX",
  182646315: "IFCFLOWINSTRUMENT",
  263784265: "IFCFURNISHINGELEMENT",
  264262732: "IFCELECTRICGENERATOR",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  310824031: "IFCPIPEFITTING",
  331165859: "IFCSTAIR",
  342316401: "IFCDUCTFITTING",
  377706215: "IFCMECHANICALFASTENER",
  395920057: "IFCDOOR",
  402227799: "IFCELECTRICMOTOR",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  484807127: "IFCEVAPORATOR",
  486154966: "IFCWINDOWSTANDARDCASE",
  629592764: "IFCLIGHTFIXTURE",
  630975310: "IFCUNITARYCONTROLELEMENT",
  635142910: "IFCCABLECARRIERFITTING",
  639361253: "IFCCOIL",
  647756555: "IFCFASTENER",
  707683696: "IFCFLOWSTORAGEDEVICE",
  738039164: "IFCPROTECTIVEDEVICE",
  753842376: "IFCBEAM",
  812556717: "IFCTANK",
  819412036: "IFCFILTER",
  843113511: "IFCCOLUMN",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  900683007: "IFCFOOTING",
  905975707: "IFCCOLUMNSTANDARDCASE",
  926996030: "IFCVOIDINGFEATURE",
  979691226: "IFCREINFORCINGBAR",
  987401354: "IFCFLOWSEGMENT",
  1003880860: "IFCELECTRICTIMECONTROL",
  1051757585: "IFCCABLEFITTING",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1073191201: "IFCMEMBER",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1156407060: "IFCPLATESTANDARDCASE",
  1162798199: "IFCSWITCHINGDEVICE",
  1329646415: "IFCSHADINGDEVICE",
  1335981549: "IFCDISCRETEACCESSORY",
  1360408905: "IFCDUCTSILENCER",
  1404847402: "IFCSTACKTERMINAL",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  1437502449: "IFCMEDICALDEVICE",
  1509553395: "IFCFURNITURE",
  1529196076: "IFCSLAB",
  1620046519: "IFCTRANSPORTELEMENT",
  1634111441: "IFCAIRTERMINAL",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  1677625105: "IFCCIVILELEMENT",
  1687234759: "IFCPILE",
  1904799276: "IFCELECTRICAPPLIANCE",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  1973544240: "IFCCOVERING",
  1999602285: "IFCSPACEHEATER",
  2016517767: "IFCROOF",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  2058353004: "IFCFLOWCONTROLLER",
  2068733104: "IFCHUMIDIFIER",
  2176052936: "IFCJUNCTIONBOX",
  2188021234: "IFCFLOWMETER",
  2223149337: "IFCFLOWTERMINAL",
  2262370178: "IFCRAILING",
  2272882330: "IFCCONDENSER",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  2320036040: "IFCREINFORCINGMESH",
  2347447852: "IFCTENDONANCHOR",
  2391383451: "IFCVIBRATIONISOLATOR",
  2391406946: "IFCWALL",
  2474470126: "IFCMOTORCONNECTION",
  2769231204: "IFCVIRTUALELEMENT",
  2814081492: "IFCENGINE",
  2906023776: "IFCBEAMSTANDARDCASE",
  2938176219: "IFCBURNER",
  2979338954: "IFCBUILDINGELEMENTPART",
  3024970846: "IFCRAMP",
  3026737570: "IFCTUBEBUNDLE",
  3027962421: "IFCSLABSTANDARDCASE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3053780830: "IFCSANITARYTERMINAL",
  3079942009: "IFCOPENINGSTANDARDCASE",
  3087945054: "IFCALARM",
  3101698114: "IFCSURFACEFEATURE",
  3127900445: "IFCSLABELEMENTEDCASE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  3171933400: "IFCPLATE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  3242481149: "IFCDOORSTANDARDCASE",
  3283111854: "IFCRAMPFLIGHT",
  3296154744: "IFCCHIMNEY",
  3304561284: "IFCWINDOW",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3319311131: "IFCHEATEXCHANGER",
  3415622556: "IFCFAN",
  3420628829: "IFCSOLARDEVICE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  3495092785: "IFCCURTAINWALL",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3512223829: "IFCWALLSTANDARDCASE",
  3518393246: "IFCDUCTSEGMENT",
  3571504051: "IFCCOMPRESSOR",
  3588315303: "IFCOPENINGELEMENT",
  3612865200: "IFCPIPESEGMENT",
  3640358203: "IFCCOOLINGTOWER",
  3651124850: "IFCPROJECTIONELEMENT",
  3694346114: "IFCOUTLET",
  3747195512: "IFCEVAPORATIVECOOLER",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3824725483: "IFCTENDON",
  3825984169: "IFCTRANSFORMER",
  3902619387: "IFCCHILLER",
  4074379575: "IFCDAMPER",
  4086658281: "IFCSENSOR",
  4123344466: "IFCELEMENTASSEMBLY",
  4136498852: "IFCCOOLEDBEAM",
  4156078855: "IFCWALLELEMENTEDCASE",
  4175244083: "IFCINTERCEPTOR",
  4207607924: "IFCVALVE",
  4217484030: "IFCCABLESEGMENT",
  4237592921: "IFCWASTETERMINAL",
  4252922144: "IFCSTAIRFLIGHT",
  4278956645: "IFCFLOWFITTING",
  4288193352: "IFCACTUATOR",
  4292641817: "IFCUNITARYEQUIPMENT",
  3009204131: "IFCGRID"
};
var ra = class {
  getAll(s, t) {
    const e = {}, i = Object.keys(Qr).map((o) => parseInt(o, 10));
    for (let o = 0; o < i.length; o++) {
      const n = i[o], r = s.GetLineIDsWithType(t, n), a = r.size();
      for (let c = 0; c < a; c++)
        e[r.get(c)] = n;
    }
    return e;
  }
};
var Bn = {
  950732822: "IFCURIREFERENCE",
  4075327185: "IFCTIME",
  1209108979: "IFCTEMPERATURERATEOFCHANGEMEASURE",
  3457685358: "IFCSOUNDPRESSURELEVELMEASURE",
  4157543285: "IFCSOUNDPOWERLEVELMEASURE",
  2798247006: "IFCPROPERTYSETDEFINITIONSET",
  1790229001: "IFCPOSITIVEINTEGER",
  525895558: "IFCNONNEGATIVELENGTHMEASURE",
  1774176899: "IFCLINEINDEX",
  1275358634: "IFCLANGUAGEID",
  2541165894: "IFCDURATION",
  3701338814: "IFCDAYINWEEKNUMBER",
  2195413836: "IFCDATETIME",
  937566702: "IFCDATE",
  1683019596: "IFCCARDINALPOINTREFERENCE",
  2314439260: "IFCBINARY",
  1500781891: "IFCAREADENSITYMEASURE",
  3683503648: "IFCARCINDEX",
  4065007721: "IFCYEARNUMBER",
  1718600412: "IFCWARPINGMOMENTMEASURE",
  51269191: "IFCWARPINGCONSTANTMEASURE",
  2593997549: "IFCVOLUMETRICFLOWRATEMEASURE",
  3458127941: "IFCVOLUMEMEASURE",
  3345633955: "IFCVAPORPERMEABILITYMEASURE",
  1278329552: "IFCTORQUEMEASURE",
  2591213694: "IFCTIMESTAMP",
  2726807636: "IFCTIMEMEASURE",
  743184107: "IFCTHERMODYNAMICTEMPERATUREMEASURE",
  2016195849: "IFCTHERMALTRANSMITTANCEMEASURE",
  857959152: "IFCTHERMALRESISTANCEMEASURE",
  2281867870: "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",
  2645777649: "IFCTHERMALCONDUCTIVITYMEASURE",
  232962298: "IFCTHERMALADMITTANCEMEASURE",
  296282323: "IFCTEXTTRANSFORMATION",
  603696268: "IFCTEXTFONTNAME",
  3490877962: "IFCTEXTDECORATION",
  1460886941: "IFCTEXTALIGNMENT",
  2801250643: "IFCTEXT",
  58845555: "IFCTEMPERATUREGRADIENTMEASURE",
  361837227: "IFCSPECULARROUGHNESS",
  2757832317: "IFCSPECULAREXPONENT",
  3477203348: "IFCSPECIFICHEATCAPACITYMEASURE",
  993287707: "IFCSOUNDPRESSUREMEASURE",
  846465480: "IFCSOUNDPOWERMEASURE",
  3471399674: "IFCSOLIDANGLEMEASURE",
  408310005: "IFCSHEARMODULUSMEASURE",
  2190458107: "IFCSECTIONALAREAINTEGRALMEASURE",
  3467162246: "IFCSECTIONMODULUSMEASURE",
  2766185779: "IFCSECONDINMINUTE",
  3211557302: "IFCROTATIONALSTIFFNESSMEASURE",
  1755127002: "IFCROTATIONALMASSMEASURE",
  2133746277: "IFCROTATIONALFREQUENCYMEASURE",
  200335297: "IFCREAL",
  96294661: "IFCRATIOMEASURE",
  3972513137: "IFCRADIOACTIVITYMEASURE",
  3665567075: "IFCPRESSUREMEASURE",
  2169031380: "IFCPRESENTABLETEXT",
  1364037233: "IFCPOWERMEASURE",
  1245737093: "IFCPOSITIVERATIOMEASURE",
  3054510233: "IFCPOSITIVEPLANEANGLEMEASURE",
  2815919920: "IFCPOSITIVELENGTHMEASURE",
  4042175685: "IFCPLANEANGLEMEASURE",
  2642773653: "IFCPLANARFORCEMEASURE",
  2260317790: "IFCPARAMETERVALUE",
  929793134: "IFCPHMEASURE",
  2395907400: "IFCNUMERICMEASURE",
  2095195183: "IFCNORMALISEDRATIOMEASURE",
  765770214: "IFCMONTHINYEARNUMBER",
  2615040989: "IFCMONETARYMEASURE",
  3114022597: "IFCMOMENTOFINERTIAMEASURE",
  1648970520: "IFCMOLECULARWEIGHTMEASURE",
  3177669450: "IFCMOISTUREDIFFUSIVITYMEASURE",
  1753493141: "IFCMODULUSOFSUBGRADEREACTIONMEASURE",
  1052454078: "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",
  2173214787: "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",
  3341486342: "IFCMODULUSOFELASTICITYMEASURE",
  102610177: "IFCMINUTEINHOUR",
  3531705166: "IFCMASSPERLENGTHMEASURE",
  3124614049: "IFCMASSMEASURE",
  4017473158: "IFCMASSFLOWRATEMEASURE",
  1477762836: "IFCMASSDENSITYMEASURE",
  2486716878: "IFCMAGNETICFLUXMEASURE",
  286949696: "IFCMAGNETICFLUXDENSITYMEASURE",
  151039812: "IFCLUMINOUSINTENSITYMEASURE",
  2755797622: "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",
  2095003142: "IFCLUMINOUSFLUXMEASURE",
  503418787: "IFCLOGICAL",
  3086160713: "IFCLINEARVELOCITYMEASURE",
  1307019551: "IFCLINEARSTIFFNESSMEASURE",
  2128979029: "IFCLINEARMOMENTMEASURE",
  191860431: "IFCLINEARFORCEMEASURE",
  1243674935: "IFCLENGTHMEASURE",
  3258342251: "IFCLABEL",
  2054016361: "IFCKINEMATICVISCOSITYMEASURE",
  3192672207: "IFCISOTHERMALMOISTURECAPACITYMEASURE",
  3686016028: "IFCIONCONCENTRATIONMEASURE",
  3809634241: "IFCINTEGERCOUNTRATEMEASURE",
  1939436016: "IFCINTEGER",
  2679005408: "IFCINDUCTANCEMEASURE",
  3358199106: "IFCILLUMINANCEMEASURE",
  983778844: "IFCIDENTIFIER",
  2589826445: "IFCHOURINDAY",
  1158859006: "IFCHEATINGVALUEMEASURE",
  3113092358: "IFCHEATFLUXDENSITYMEASURE",
  3064340077: "IFCGLOBALLYUNIQUEID",
  3044325142: "IFCFREQUENCYMEASURE",
  1361398929: "IFCFORCEMEASURE",
  2590844177: "IFCFONTWEIGHT",
  2715512545: "IFCFONTVARIANT",
  1102727119: "IFCFONTSTYLE",
  2078135608: "IFCENERGYMEASURE",
  2506197118: "IFCELECTRICVOLTAGEMEASURE",
  2951915441: "IFCELECTRICRESISTANCEMEASURE",
  3790457270: "IFCELECTRICCURRENTMEASURE",
  2093906313: "IFCELECTRICCONDUCTANCEMEASURE",
  3818826038: "IFCELECTRICCHARGEMEASURE",
  1827137117: "IFCELECTRICCAPACITANCEMEASURE",
  69416015: "IFCDYNAMICVISCOSITYMEASURE",
  524656162: "IFCDOSEEQUIVALENTMEASURE",
  4134073009: "IFCDIMENSIONCOUNT",
  1514641115: "IFCDESCRIPTIVEMEASURE",
  300323983: "IFCDAYLIGHTSAVINGHOUR",
  86635668: "IFCDAYINMONTHNUMBER",
  94842927: "IFCCURVATUREMEASURE",
  1778710042: "IFCCOUNTMEASURE",
  3238673880: "IFCCONTEXTDEPENDENTMEASURE",
  3812528620: "IFCCOMPOUNDPLANEANGLEMEASURE",
  2991860651: "IFCCOMPLEXNUMBER",
  1867003952: "IFCBOXALIGNMENT",
  2735952531: "IFCBOOLEAN",
  2650437152: "IFCAREAMEASURE",
  632304761: "IFCANGULARVELOCITYMEASURE",
  360377573: "IFCAMOUNTOFSUBSTANCEMEASURE",
  4182062534: "IFCACCELERATIONMEASURE",
  3699917729: "IFCABSORBEDDOSEMEASURE",
  1971632696: "IFCGEOSLICE",
  2680139844: "IFCGEOMODEL",
  24726584: "IFCELECTRICFLOWTREATMENTDEVICE",
  3693000487: "IFCDISTRIBUTIONBOARD",
  3460952963: "IFCCONVEYORSEGMENT",
  3999819293: "IFCCAISSONFOUNDATION",
  3314249567: "IFCBOREHOLE",
  4196446775: "IFCBEARING",
  325726236: "IFCALIGNMENT",
  3425753595: "IFCTRACKELEMENT",
  991950508: "IFCSIGNAL",
  3798194928: "IFCREINFORCEDSOIL",
  3290496277: "IFCRAIL",
  1383356374: "IFCPAVEMENT",
  2182337498: "IFCNAVIGATIONELEMENT",
  234836483: "IFCMOORINGDEVICE",
  2078563270: "IFCMOBILETELECOMMUNICATIONSAPPLIANCE",
  1638804497: "IFCLIQUIDTERMINAL",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2696325953: "IFCKERB",
  2713699986: "IFCGEOTECHNICALASSEMBLY",
  2142170206: "IFCELECTRICFLOWTREATMENTDEVICETYPE",
  3376911765: "IFCEARTHWORKSFILL",
  1077100507: "IFCEARTHWORKSELEMENT",
  3071239417: "IFCEARTHWORKSCUT",
  479945903: "IFCDISTRIBUTIONBOARDTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1502416096: "IFCCOURSE",
  2940368186: "IFCCONVEYORSEGMENTTYPE",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  3862327254: "IFCBUILTSYSTEM",
  1876633798: "IFCBUILTELEMENT",
  963979645: "IFCBRIDGEPART",
  644574406: "IFCBRIDGE",
  3649138523: "IFCBEARINGTYPE",
  1662888072: "IFCALIGNMENTVERTICAL",
  317615605: "IFCALIGNMENTSEGMENT",
  1545765605: "IFCALIGNMENTHORIZONTAL",
  4266260250: "IFCALIGNMENTCANT",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  1530820697: "IFCVIBRATIONDAMPER",
  840318589: "IFCVEHICLE",
  1953115116: "IFCTRANSPORTATIONDEVICE",
  618700268: "IFCTRACKELEMENTTYPE",
  2281632017: "IFCTENDONCONDUITTYPE",
  3663046924: "IFCTENDONCONDUIT",
  42703149: "IFCSINESPIRAL",
  1894708472: "IFCSIGNALTYPE",
  3599934289: "IFCSIGNTYPE",
  33720170: "IFCSIGN",
  1027922057: "IFCSEVENTHORDERPOLYNOMIALSPIRAL",
  544395925: "IFCSEGMENTEDREFERENCECURVE",
  3649235739: "IFCSECONDORDERPOLYNOMIALSPIRAL",
  550521510: "IFCROADPART",
  146592293: "IFCROAD",
  3818125796: "IFCRELADHERESTOELEMENT",
  4021432810: "IFCREFERENT",
  1891881377: "IFCRAILWAYPART",
  3992365140: "IFCRAILWAY",
  1763565496: "IFCRAILTYPE",
  1946335990: "IFCPOSITIONINGELEMENT",
  514975943: "IFCPAVEMENTTYPE",
  506776471: "IFCNAVIGATIONELEMENTTYPE",
  710110818: "IFCMOORINGDEVICETYPE",
  1950438474: "IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",
  976884017: "IFCMARINEPART",
  525669439: "IFCMARINEFACILITY",
  1770583370: "IFCLIQUIDTERMINALTYPE",
  2176059722: "IFCLINEARELEMENT",
  679976338: "IFCKERBTYPE",
  3948183225: "IFCIMPACTPROTECTIONDEVICETYPE",
  2568555532: "IFCIMPACTPROTECTIONDEVICE",
  2898700619: "IFCGRADIENTCURVE",
  1594536857: "IFCGEOTECHNICALSTRATUM",
  4230923436: "IFCGEOTECHNICALELEMENT",
  4228831410: "IFCFACILITYPARTCOMMON",
  1310830890: "IFCFACILITYPART",
  24185140: "IFCFACILITY",
  4234616927: "IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  4189326743: "IFCCOURSETYPE",
  2000195564: "IFCCOSINESPIRAL",
  3497074424: "IFCCLOTHOID",
  1626504194: "IFCBUILTELEMENTTYPE",
  3651464721: "IFCVEHICLETYPE",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3665877780: "IFCTRANSPORTATIONDEVICETYPE",
  782932809: "IFCTHIRDORDERPOLYNOMIALSPIRAL",
  2735484536: "IFCSPIRAL",
  1356537516: "IFCSECTIONEDSURFACE",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1862484736: "IFCSECTIONEDSOLID",
  1441486842: "IFCRELPOSITIONS",
  1033248425: "IFCRELASSOCIATESPROFILEDEF",
  3381221214: "IFCPOLYNOMIALCURVE",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  590820931: "IFCOFFSETCURVE",
  3465909080: "IFCINDEXEDPOLYGONALTEXTUREMAP",
  593015953: "IFCDIRECTRIXCURVESWEPTAREASOLID",
  4212018352: "IFCCURVESEGMENT",
  3425423356: "IFCAXIS2PLACEMENTLINEAR",
  823603102: "IFCSEGMENT",
  2165702409: "IFCPOINTBYDISTANCEEXPRESSION",
  182550632: "IFCOPENCROSSPROFILEDEF",
  388784114: "IFCLINEARPLACEMENT",
  536804194: "IFCALIGNMENTHORIZONTALSEGMENT",
  3752311538: "IFCALIGNMENTCANTSEGMENT",
  1010789467: "IFCTEXTURECOORDINATEINDICESWITHVOIDS",
  222769930: "IFCTEXTURECOORDINATEINDICES",
  2691318326: "IFCQUANTITYNUMBER",
  3633395639: "IFCALIGNMENTVERTICALSEGMENT",
  2879124712: "IFCALIGNMENTPARAMETERSEGMENT",
  25142252: "IFCCONTROLLER",
  3087945054: "IFCALARM",
  4288193352: "IFCACTUATOR",
  630975310: "IFCUNITARYCONTROLELEMENT",
  4086658281: "IFCSENSOR",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  182646315: "IFCFLOWINSTRUMENT",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  819412036: "IFCFILTER",
  3415622556: "IFCFAN",
  1003880860: "IFCELECTRICTIMECONTROL",
  402227799: "IFCELECTRICMOTOR",
  264262732: "IFCELECTRICGENERATOR",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  1904799276: "IFCELECTRICAPPLIANCE",
  1360408905: "IFCDUCTSILENCER",
  3518393246: "IFCDUCTSEGMENT",
  342316401: "IFCDUCTFITTING",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  4074379575: "IFCDAMPER",
  3640358203: "IFCCOOLINGTOWER",
  4136498852: "IFCCOOLEDBEAM",
  2272882330: "IFCCONDENSER",
  3571504051: "IFCCOMPRESSOR",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  639361253: "IFCCOIL",
  3902619387: "IFCCHILLER",
  4217484030: "IFCCABLESEGMENT",
  1051757585: "IFCCABLEFITTING",
  3758799889: "IFCCABLECARRIERSEGMENT",
  635142910: "IFCCABLECARRIERFITTING",
  2938176219: "IFCBURNER",
  32344328: "IFCBOILER",
  2906023776: "IFCBEAMSTANDARDCASE",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  177149247: "IFCAIRTERMINALBOX",
  1634111441: "IFCAIRTERMINAL",
  486154966: "IFCWINDOWSTANDARDCASE",
  4237592921: "IFCWASTETERMINAL",
  4156078855: "IFCWALLELEMENTEDCASE",
  4207607924: "IFCVALVE",
  4292641817: "IFCUNITARYEQUIPMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  3026737570: "IFCTUBEBUNDLE",
  3825984169: "IFCTRANSFORMER",
  812556717: "IFCTANK",
  1162798199: "IFCSWITCHINGDEVICE",
  385403989: "IFCSTRUCTURALLOADCASE",
  1404847402: "IFCSTACKTERMINAL",
  1999602285: "IFCSPACEHEATER",
  3420628829: "IFCSOLARDEVICE",
  3027962421: "IFCSLABSTANDARDCASE",
  3127900445: "IFCSLABELEMENTEDCASE",
  1329646415: "IFCSHADINGDEVICE",
  3053780830: "IFCSANITARYTERMINAL",
  2572171363: "IFCREINFORCINGBARTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  90941305: "IFCPUMP",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  738039164: "IFCPROTECTIVEDEVICE",
  1156407060: "IFCPLATESTANDARDCASE",
  3612865200: "IFCPIPESEGMENT",
  310824031: "IFCPIPEFITTING",
  3694346114: "IFCOUTLET",
  144952367: "IFCOUTERBOUNDARYCURVE",
  2474470126: "IFCMOTORCONNECTION",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1437502449: "IFCMEDICALDEVICE",
  629592764: "IFCLIGHTFIXTURE",
  76236018: "IFCLAMP",
  2176052936: "IFCJUNCTIONBOX",
  4175244083: "IFCINTERCEPTOR",
  2068733104: "IFCHUMIDIFIER",
  3319311131: "IFCHEATEXCHANGER",
  2188021234: "IFCFLOWMETER",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  484807127: "IFCEVAPORATOR",
  3747195512: "IFCEVAPORATIVECOOLER",
  2814081492: "IFCENGINE",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3242481149: "IFCDOORSTANDARDCASE",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  905975707: "IFCCOLUMNSTANDARDCASE",
  1677625105: "IFCCIVILELEMENT",
  3296154744: "IFCCHIMNEY",
  2674252688: "IFCCABLEFITTINGTYPE",
  2188180465: "IFCBURNERTYPE",
  1177604601: "IFCBUILDINGSYSTEM",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1136057603: "IFCBOUNDARYCURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4088093105: "IFCWORKCALENDAR",
  4009809668: "IFCWINDOWTYPE",
  926996030: "IFCVOIDINGFEATURE",
  2391383451: "IFCVIBRATIONISOLATOR",
  2415094496: "IFCTENDONTYPE",
  3081323446: "IFCTENDONANCHORTYPE",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  3101698114: "IFCSURFACEFEATURE",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  338393293: "IFCSTAIRTYPE",
  1072016465: "IFCSOLARDEVICETYPE",
  4074543187: "IFCSHADINGDEVICETYPE",
  2157484638: "IFCSEAMCURVE",
  2781568857: "IFCROOFTYPE",
  2310774935: "IFCREINFORCINGMESHTYPE",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  1469900589: "IFCRAMPTYPE",
  2839578677: "IFCPOLYGONALFACESET",
  1158309216: "IFCPILETYPE",
  3079942009: "IFCOPENINGSTANDARDCASE",
  1114901282: "IFCMEDICALDEVICETYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  3946677679: "IFCINTERCEPTORTYPE",
  2571569899: "IFCINDEXEDPOLYCURVE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  1509553395: "IFCFURNITURE",
  1893162501: "IFCFOOTINGTYPE",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  4148101412: "IFCEVENT",
  132023988: "IFCENGINETYPE",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  2323601079: "IFCDOORTYPE",
  1213902940: "IFCCYLINDRICALSURFACE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3893394355: "IFCCIVILELEMENTTYPE",
  2197970202: "IFCCHIMNEYTYPE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  1635779807: "IFCADVANCEDBREP",
  2916149573: "IFCTRIANGULATEDFACESET",
  1935646853: "IFCTOROIDALSURFACE",
  2387106220: "IFCTESSELLATEDFACESET",
  3206491090: "IFCTASKTYPE",
  699246055: "IFCSURFACECURVE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  4015995234: "IFCSPHERICALSURFACE",
  2481509218: "IFCSPATIALZONETYPE",
  463610769: "IFCSPATIALZONE",
  710998568: "IFCSPATIALELEMENTTYPE",
  1412071761: "IFCSPATIALELEMENT",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  427948657: "IFCRELINTERFERESELEMENTS",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  1462361463: "IFCRELDEFINESBYOBJECT",
  2565941209: "IFCRELDECLARES",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  3521284610: "IFCPROPERTYTEMPLATE",
  492091185: "IFCPROPERTYSETTEMPLATE",
  653396225: "IFCPROJECTLIBRARY",
  569719735: "IFCPROCEDURETYPE",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1682466193: "IFCPCURVE",
  428585644: "IFCLABORRESOURCETYPE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  4024345920: "IFCEVENTTYPE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1815067380: "IFCCREWRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  574549367: "IFCCARTESIANPOINTLIST",
  3406155212: "IFCADVANCEDFACE",
  3698973494: "IFCTYPERESOURCE",
  3736923433: "IFCTYPEPROCESS",
  901063453: "IFCTESSELLATEDITEM",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  1042787934: "IFCRESOURCETIME",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  2090586900: "IFCQUANTITYSET",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  2998442950: "IFCMIRROREDPROFILEDEF",
  853536259: "IFCMATERIALRELATIONSHIP",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  3708119e3: "IFCMATERIALCONSTITUENT",
  1585845231: "IFCLAGTIME",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  3570813810: "IFCINDEXEDCOLOURMAP",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  297599258: "IFCEXTENDEDPROPERTIES",
  211053100: "IFCEVENTTIME",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  3285139300: "IFCCOLOURRGBLIST",
  1236880293: "IFCWORKTIME",
  1199560280: "IFCTIMEPERIOD",
  3611470254: "IFCTEXTUREVERTEXLIST",
  2771591690: "IFCTASKTIMERECURRING",
  1549132990: "IFCTASKTIME",
  2043862942: "IFCTABLECOLUMN",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1054537805: "IFCSCHEDULINGTIME",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  2433181523: "IFCREFERENCE",
  3915482550: "IFCRECURRENCEPATTERN",
  986844984: "IFCPROPERTYABSTRACTION",
  3843373140: "IFCPROJECTEDCRS",
  677532197: "IFCPRESENTATIONITEM",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  164193824: "IFCMATERIALPROFILESET",
  2235152071: "IFCMATERIALPROFILE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  760658860: "IFCMATERIALDEFINITION",
  3057273783: "IFCMAPCONVERSION",
  4294318154: "IFCEXTERNALINFORMATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  1785450214: "IFCCOORDINATEOPERATION",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  979691226: "IFCREINFORCINGBAR",
  3700593921: "IFCELECTRICDISTRIBUTIONPOINT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  578613899: "IFCCONTROLLERTYPE",
  2454782716: "IFCCHAMFEREDGEFEATURE",
  753842376: "IFCBEAM",
  3001207471: "IFCALARMTYPE",
  2874132201: "IFCACTUATORTYPE",
  3304561284: "IFCWINDOW",
  3512223829: "IFCWALLSTANDARDCASE",
  2391406946: "IFCWALL",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2347447852: "IFCTENDONANCHOR",
  3824725483: "IFCTENDON",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  4252922144: "IFCSTAIRFLIGHT",
  331165859: "IFCSTAIR",
  1529196076: "IFCSLAB",
  1783015770: "IFCSENSORTYPE",
  1376911519: "IFCROUNDEDEDGEFEATURE",
  2016517767: "IFCROOF",
  2320036040: "IFCREINFORCINGMESH",
  3027567501: "IFCREINFORCINGELEMENT",
  3055160366: "IFCRATIONALBEZIERCURVE",
  3283111854: "IFCRAMPFLIGHT",
  3024970846: "IFCRAMP",
  2262370178: "IFCRAILING",
  3171933400: "IFCPLATE",
  1687234759: "IFCPILE",
  1073191201: "IFCMEMBER",
  900683007: "IFCFOOTING",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  2223149337: "IFCFLOWTERMINAL",
  707683696: "IFCFLOWSTORAGEDEVICE",
  987401354: "IFCFLOWSEGMENT",
  3132237377: "IFCFLOWMOVINGDEVICE",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  4278956645: "IFCFLOWFITTING",
  2058353004: "IFCFLOWCONTROLLER",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  1810631287: "IFCFILTERTYPE",
  346874300: "IFCFANTYPE",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  857184966: "IFCELECTRICALELEMENT",
  1634875225: "IFCELECTRICALCIRCUIT",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1217240411: "IFCELECTRICMOTORTYPE",
  1365060375: "IFCELECTRICHEATERTYPE",
  1534661035: "IFCELECTRICGENERATORTYPE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  855621170: "IFCEDGEFEATURE",
  2030761528: "IFCDUCTSILENCERTYPE",
  3760055223: "IFCDUCTSEGMENTTYPE",
  869906466: "IFCDUCTFITTINGTYPE",
  395920057: "IFCDOOR",
  3041715199: "IFCDISTRIBUTIONPORT",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1335981549: "IFCDISCRETEACCESSORY",
  4147604152: "IFCDIAMETERDIMENSION",
  3961806047: "IFCDAMPERTYPE",
  3495092785: "IFCCURTAINWALL",
  1973544240: "IFCCOVERING",
  2954562838: "IFCCOOLINGTOWERTYPE",
  335055490: "IFCCOOLEDBEAMTYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  1163958913: "IFCCONDITIONCRITERION",
  2188551683: "IFCCONDITION",
  2816379211: "IFCCONDENSERTYPE",
  3850581409: "IFCCOMPRESSORTYPE",
  843113511: "IFCCOLUMN",
  2301859152: "IFCCOILTYPE",
  2611217952: "IFCCIRCLE",
  2951183804: "IFCCHILLERTYPE",
  1285652485: "IFCCABLESEGMENTTYPE",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  2979338954: "IFCBUILDINGELEMENTPART",
  52481810: "IFCBUILDINGELEMENTCOMPONENT",
  3299480353: "IFCBUILDINGELEMENT",
  231477066: "IFCBOILERTYPE",
  1916977116: "IFCBEZIERCURVE",
  819618141: "IFCBEAMTYPE",
  1967976161: "IFCBSPLINECURVE",
  3460190687: "IFCASSET",
  2470393545: "IFCANGULARDIMENSION",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3821786052: "IFCACTIONREQUEST",
  1213861670: "IFC2DCOMPOSITECURVE",
  1033361043: "IFCZONE",
  3342526732: "IFCWORKSCHEDULE",
  4218914973: "IFCWORKPLAN",
  1028945134: "IFCWORKCONTROL",
  1133259667: "IFCWASTETERMINALTYPE",
  1898987631: "IFCWALLTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  728799441: "IFCVALVETYPE",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  1600972822: "IFCTUBEBUNDLETYPE",
  3593883385: "IFCTRIMMEDCURVE",
  1620046519: "IFCTRANSPORTELEMENT",
  1692211062: "IFCTRANSFORMERTYPE",
  1637806684: "IFCTIMESERIESSCHEDULE",
  5716631: "IFCTANKTYPE",
  2254336722: "IFCSYSTEM",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  148013059: "IFCSUBCONTRACTRESOURCE",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  3987759626: "IFCSTRUCTURALPLANARACTIONVARYING",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1721250024: "IFCSTRUCTURALLINEARACTIONVARYING",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  1179482911: "IFCSTRUCTURALCONNECTION",
  682877961: "IFCSTRUCTURALACTION",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  3112655638: "IFCSTACKTERMINALTYPE",
  3812236995: "IFCSPACETYPE",
  652456506: "IFCSPACEPROGRAM",
  1305183839: "IFCSPACEHEATERTYPE",
  3856911033: "IFCSPACE",
  2533589738: "IFCSLABTYPE",
  4097777520: "IFCSITE",
  4105383287: "IFCSERVICELIFE",
  3517283431: "IFCSCHEDULETIMECONTROL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  2863920197: "IFCRELASSIGNSTASKS",
  160246688: "IFCRELAGGREGATES",
  2324767716: "IFCRAMPFLIGHTTYPE",
  2893384427: "IFCRAILINGTYPE",
  3248260540: "IFCRADIUSDIMENSION",
  2250791053: "IFCPUMPTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3651124850: "IFCPROJECTIONELEMENT",
  3642467123: "IFCPROJECTORDERRECORD",
  2904328755: "IFCPROJECTORDER",
  2744685151: "IFCPROCEDURE",
  3740093272: "IFCPORT",
  3724593414: "IFCPOLYLINE",
  4017108033: "IFCPLATETYPE",
  4231323485: "IFCPIPESEGMENTTYPE",
  804291784: "IFCPIPEFITTINGTYPE",
  3327091369: "IFCPERMIT",
  2382730787: "IFCPERFORMANCEHISTORY",
  2837617999: "IFCOUTLETTYPE",
  3425660407: "IFCORDERACTION",
  3588315303: "IFCOPENINGELEMENT",
  4143007308: "IFCOCCUPANT",
  1916936684: "IFCMOVE",
  977012517: "IFCMOTORCONNECTIONTYPE",
  3181161470: "IFCMEMBERTYPE",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  377706215: "IFCMECHANICALFASTENER",
  2506943328: "IFCLINEARDIMENSION",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1051575348: "IFCLAMPTYPE",
  3827777499: "IFCLABORRESOURCE",
  4288270099: "IFCJUNCTIONBOXTYPE",
  2391368822: "IFCINVENTORY",
  1806887404: "IFCHUMIDIFIERTYPE",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2706460486: "IFCGROUP",
  3009204131: "IFCGRID",
  200128114: "IFCGASTERMINALTYPE",
  814719939: "IFCFURNITURESTANDARD",
  263784265: "IFCFURNISHINGELEMENT",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  2297155007: "IFCFLOWTERMINALTYPE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  1834744321: "IFCFLOWSEGMENTTYPE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  3815607619: "IFCFLOWMETERTYPE",
  3198132628: "IFCFLOWFITTINGTYPE",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  2143335405: "IFCFEATUREELEMENTADDITION",
  2827207264: "IFCFEATUREELEMENT",
  2489546625: "IFCFASTENERTYPE",
  647756555: "IFCFASTENER",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  807026263: "IFCFACETEDBREP",
  3390157468: "IFCEVAPORATORTYPE",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  3272907226: "IFCEQUIPMENTSTANDARD",
  1962604670: "IFCEQUIPMENTELEMENT",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  1704287377: "IFCELLIPSE",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  4123344466: "IFCELEMENTASSEMBLY",
  1758889154: "IFCELEMENT",
  360485395: "IFCELECTRICALBASEPROPERTIES",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  681481545: "IFCDIMENSIONCURVEDIRECTEDCALLOUT",
  1457835157: "IFCCURTAINWALLTYPE",
  3295246426: "IFCCREWRESOURCE",
  1916426348: "IFCCOVERINGTYPE",
  1419761937: "IFCCOSTSCHEDULE",
  3895139033: "IFCCOSTITEM",
  3293443760: "IFCCONTROL",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2510884976: "IFCCONIC",
  3732776249: "IFCCOMPOSITECURVE",
  300633059: "IFCCOLUMNTYPE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  3124254112: "IFCBUILDINGSTOREY",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  4031249490: "IFCBUILDING",
  1260505505: "IFCBOUNDEDCURVE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  1334484129: "IFCBLOCK",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  1674181508: "IFCANNOTATION",
  2296667514: "IFCACTOR",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  3473067441: "IFCTASK",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  4070609034: "IFCSTRUCTUREDDIMENSIONCALLOUT",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  3689010777: "IFCSTRUCTURALREACTION",
  530289379: "IFCSTRUCTURALMEMBER",
  3136571912: "IFCSTRUCTURALITEM",
  3544373492: "IFCSTRUCTURALACTIVITY",
  451544542: "IFCSPHERE",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  4158566097: "IFCRIGHTCIRCULARCONE",
  1856042241: "IFCREVOLVEDAREASOLID",
  2914609552: "IFCRESOURCE",
  1401173127: "IFCRELVOIDSELEMENT",
  3451746338: "IFCRELSPACEBOUNDARY",
  366585022: "IFCRELSERVICESBUILDINGS",
  4122056220: "IFCRELSEQUENCE",
  1058617721: "IFCRELSCHEDULESCOSTITEMS",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  750771296: "IFCRELPROJECTSELEMENT",
  202636808: "IFCRELOVERRIDESPROPERTIES",
  2051452291: "IFCRELOCCUPIESSPACES",
  3268803585: "IFCRELNESTS",
  4189434867: "IFCRELINTERACTIONREQUIREMENTS",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  3940055652: "IFCRELFILLSELEMENT",
  781010003: "IFCRELDEFINESBYTYPE",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  693640335: "IFCRELDEFINES",
  2551354335: "IFCRELDECOMPOSES",
  2802773753: "IFCRELCOVERSSPACES",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  3912681535: "IFCRELCONNECTSSTRUCTURALELEMENT",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  3190031847: "IFCRELCONNECTSPORTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  826625072: "IFCRELCONNECTS",
  2851387026: "IFCRELASSOCIATESPROFILEPROPERTIES",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  1327628568: "IFCRELASSOCIATESAPPLIEDVALUE",
  1865459582: "IFCRELASSOCIATES",
  205026976: "IFCRELASSIGNSTORESOURCE",
  3372526763: "IFCRELASSIGNSTOPROJECTORDER",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  1307041759: "IFCRELASSIGNSTOGROUP",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1683148259: "IFCRELASSIGNSTOACTOR",
  3939117080: "IFCRELASSIGNS",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  2798486643: "IFCRECTANGULARPYRAMID",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3219374653: "IFCPROXY",
  1451395588: "IFCPROPERTYSET",
  4194566429: "IFCPROJECTIONCURVE",
  103090709: "IFCPROJECT",
  4208778838: "IFCPRODUCT",
  2945172077: "IFCPROCESS",
  220341763: "IFCPLANE",
  603570806: "IFCPLANARBOX",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3505215534: "IFCOFFSETCURVE3D",
  3388369263: "IFCOFFSETCURVE2D",
  3888040117: "IFCOBJECT",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  1281925730: "IFCLINE",
  572779678: "IFCLSHAPEPROFILEDEF",
  1484403080: "IFCISHAPEPROFILEDEF",
  987898635: "IFCGEOMETRICCURVESET",
  1268542332: "IFCFURNITURETYPE",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  3455213021: "IFCFLUIDFLOWPROPERTIES",
  315944413: "IFCFILLAREASTYLETILES",
  4203026998: "IFCFILLAREASTYLETILESYMBOLWITHSTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  477187591: "IFCEXTRUDEDAREASOLID",
  80994333: "IFCENERGYPROPERTIES",
  2835456948: "IFCELLIPSEPROFILEDEF",
  2777663545: "IFCELEMENTARYSURFACE",
  339256511: "IFCELEMENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  1472233963: "IFCEDGELOOP",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  3073041342: "IFCDRAUGHTINGCALLOUT",
  526551008: "IFCDOORSTYLE",
  1714330368: "IFCDOORPANELPROPERTIES",
  2963535650: "IFCDOORLININGPROPERTIES",
  32440307: "IFCDIRECTION",
  4054601972: "IFCDIMENSIONCURVETERMINATOR",
  606661476: "IFCDIMENSIONCURVE",
  693772133: "IFCDEFINEDSYMBOL",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2601014836: "IFCCURVE",
  2147822146: "IFCCSGSOLID",
  2506170314: "IFCCSGPRIMITIVE3D",
  194851669: "IFCCRANERAILFSHAPEPROFILEDEF",
  4133800736: "IFCCRANERAILASHAPEPROFILEDEF",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  2205249479: "IFCCLOSEDSHELL",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  1123145078: "IFCCARTESIANPOINT",
  2898889636: "IFCCSHAPEPROFILEDEF",
  2713105998: "IFCBOXEDHALFSPACE",
  2581212453: "IFCBOUNDINGBOX",
  4182860854: "IFCBOUNDEDSURFACE",
  2736907675: "IFCBOOLEANRESULT",
  2740243338: "IFCAXIS2PLACEMENT3D",
  3125803723: "IFCAXIS2PLACEMENT2D",
  4261334040: "IFCAXIS1PLACEMENT",
  1302238472: "IFCANNOTATIONSURFACE",
  2265737646: "IFCANNOTATIONFILLAREAOCCURRENCE",
  669184980: "IFCANNOTATIONFILLAREA",
  3288037868: "IFCANNOTATIONCURVEOCCURRENCE",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1299126871: "IFCWINDOWSTYLE",
  512836454: "IFCWINDOWPANELPROPERTIES",
  336235671: "IFCWINDOWLININGPROPERTIES",
  2759199220: "IFCVERTEXLOOP",
  1417489154: "IFCVECTOR",
  427810014: "IFCUSHAPEPROFILEDEF",
  2347495698: "IFCTYPEPRODUCT",
  1628702193: "IFCTYPEOBJECT",
  1345879162: "IFCTWODIRECTIONREPEATFACTOR",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  4282788508: "IFCTEXTLITERAL",
  3028897424: "IFCTERMINATORSYMBOL",
  3071757647: "IFCTSHAPEPROFILEDEF",
  230924584: "IFCSWEPTSURFACE",
  1260650574: "IFCSWEPTDISKSOLID",
  2247615214: "IFCSWEPTAREASOLID",
  1878645084: "IFCSURFACESTYLERENDERING",
  2513912981: "IFCSURFACE",
  2233826070: "IFCSUBEDGE",
  3653947884: "IFCSTRUCTURALSTEELPROFILEPROPERTIES",
  3843319758: "IFCSTRUCTURALPROFILEPROPERTIES",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  390701378: "IFCSPACETHERMALLOADPROPERTIES",
  1202362311: "IFCSOUNDVALUE",
  2485662743: "IFCSOUNDPROPERTIES",
  723233188: "IFCSOLIDMODEL",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  2411513650: "IFCSERVICELIFEFACTOR",
  1509187699: "IFCSECTIONEDSPINE",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  478536968: "IFCRELATIONSHIP",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  3413951693: "IFCREGULARTIMESERIES",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  110355661: "IFCPROPERTYTABLEVALUE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  3357820518: "IFCPROPERTYSETDEFINITION",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  2752243245: "IFCPROPERTYLISTVALUE",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  179317114: "IFCPREDEFINEDPOINTMARKERSYMBOL",
  433424934: "IFCPREDEFINEDDIMENSIONSYMBOL",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  759155922: "IFCPREDEFINEDCOLOUR",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2924175390: "IFCPOLYLOOP",
  1423911732: "IFCPOINTONSURFACE",
  4022376103: "IFCPOINTONCURVE",
  2067069095: "IFCPOINT",
  1663979128: "IFCPLANAREXTENT",
  2004835150: "IFCPLACEMENT",
  597895409: "IFCPIXELTEXTURE",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2519244187: "IFCPATH",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  1029017970: "IFCORIENTEDEDGE",
  2665983363: "IFCOPENSHELL",
  2833995503: "IFCONEDIRECTIONREPEATFACTOR",
  219451334: "IFCOBJECTDEFINITION",
  1430189142: "IFCMECHANICALCONCRETEMATERIALPROPERTIES",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  2347385850: "IFCMAPPEDITEM",
  1008929658: "IFCLOOP",
  2624227202: "IFCLOCALPLACEMENT",
  3422422726: "IFCLIGHTSOURCESPOT",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  1402838566: "IFCLIGHTSOURCE",
  3741457305: "IFCIRREGULARTIMESERIES",
  3905492369: "IFCIMAGETEXTURE",
  2445078500: "IFCHYGROSCOPICMATERIALPROPERTIES",
  812098782: "IFCHALFSPACESOLID",
  178086475: "IFCGRIDPLACEMENT",
  3590301190: "IFCGEOMETRICSET",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  1446786286: "IFCGENERALPROFILEPROPERTIES",
  803998398: "IFCGENERALMATERIALPROPERTIES",
  3857492461: "IFCFUELPROPERTIES",
  738692330: "IFCFILLAREASTYLE",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3008276851: "IFCFACESURFACE",
  803316827: "IFCFACEOUTERBOUND",
  1809719519: "IFCFACEBOUND",
  2556980723: "IFCFACE",
  1860660968: "IFCEXTENDEDMATERIALPROPERTIES",
  476780140: "IFCEDGECURVE",
  3900360178: "IFCEDGE",
  4170525392: "IFCDRAUGHTINGPREDEFINEDTEXTFONT",
  3732053477: "IFCDOCUMENTREFERENCE",
  1694125774: "IFCDIMENSIONPAIR",
  2273265877: "IFCDIMENSIONCALLOUTRELATIONSHIP",
  3632507154: "IFCDERIVEDPROFILEDEF",
  3800577675: "IFCCURVESTYLE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  370225590: "IFCCONNECTEDFACESET",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  2542286263: "IFCCOMPLEXPROPERTY",
  776857604: "IFCCOLOURRGB",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  616511568: "IFCBLOBTEXTURE",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  2297822566: "IFCANNOTATIONTEXTOCCURRENCE",
  3612888222: "IFCANNOTATIONSYMBOLOCCURRENCE",
  962685235: "IFCANNOTATIONSURFACEOCCURRENCE",
  2442683028: "IFCANNOTATIONOCCURRENCE",
  1065908215: "IFCWATERPROPERTIES",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  1907098498: "IFCVERTEXPOINT",
  3304826586: "IFCVERTEXBASEDTEXTUREMAP",
  2799835756: "IFCVERTEX",
  180925521: "IFCUNITASSIGNMENT",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  581633288: "IFCTIMESERIESVALUE",
  1718945513: "IFCTIMESERIESREFERENCERELATIONSHIP",
  3101149627: "IFCTIMESERIES",
  3317419933: "IFCTHERMALMATERIALPROPERTIES",
  1210645708: "IFCTEXTUREVERTEX",
  2552916305: "IFCTEXTUREMAP",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  280115917: "IFCTEXTURECOORDINATE",
  1484833681: "IFCTEXTSTYLEWITHBOXCHARACTERISTICS",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  1447204868: "IFCTEXTSTYLE",
  912023232: "IFCTELECOMADDRESS",
  531007025: "IFCTABLEROW",
  985171141: "IFCTABLE",
  1290481447: "IFCSYMBOLSTYLE",
  626085974: "IFCSURFACETEXTURE",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  846575682: "IFCSURFACESTYLESHADING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1300840506: "IFCSURFACESTYLE",
  3049322572: "IFCSTYLEDREPRESENTATION",
  3958052878: "IFCSTYLEDITEM",
  2830218821: "IFCSTYLEMODEL",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  2162789131: "IFCSTRUCTURALLOAD",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  3692461612: "IFCSIMPLEPROPERTY",
  4240577450: "IFCSHAPEREPRESENTATION",
  3982875396: "IFCSHAPEMODEL",
  867548509: "IFCSHAPEASPECT",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  2042790032: "IFCSECTIONPROPERTIES",
  448429030: "IFCSIUNIT",
  2341007311: "IFCROOT",
  3679540991: "IFCRIBPLATEPROFILEPROPERTIES",
  1660063152: "IFCREPRESENTATIONMAP",
  3008791417: "IFCREPRESENTATIONITEM",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  1076942058: "IFCREPRESENTATION",
  1222501353: "IFCRELAXATION",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  2692823254: "IFCREFERENCESVALUEDOCUMENT",
  825690147: "IFCQUANTITYWEIGHT",
  2405470396: "IFCQUANTITYVOLUME",
  3252649465: "IFCQUANTITYTIME",
  931644368: "IFCQUANTITYLENGTH",
  2093928680: "IFCQUANTITYCOUNT",
  2044713172: "IFCQUANTITYAREA",
  3710013099: "IFCPROPERTYENUMERATION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  3896028662: "IFCPROPERTYCONSTRAINTRELATIONSHIP",
  2598011224: "IFCPROPERTY",
  2802850158: "IFCPROFILEPROPERTIES",
  3958567839: "IFCPROFILEDEF",
  2267347899: "IFCPRODUCTSOFCOMBUSTIONPROPERTIES",
  2095639259: "IFCPRODUCTREPRESENTATION",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  3119450353: "IFCPRESENTATIONSTYLE",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  3213052703: "IFCPREDEFINEDTERMINATORSYMBOL",
  990879717: "IFCPREDEFINEDSYMBOL",
  3727388367: "IFCPREDEFINEDITEM",
  3355820592: "IFCPOSTALADDRESS",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  101040310: "IFCPERSONANDORGANIZATION",
  2077209135: "IFCPERSON",
  1207048766: "IFCOWNERHISTORY",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  4251960020: "IFCORGANIZATION",
  1227763645: "IFCOPTICALMATERIALPROPERTIES",
  2251480897: "IFCOBJECTIVE",
  3701648758: "IFCOBJECTPLACEMENT",
  1918398963: "IFCNAMEDUNIT",
  2706619895: "IFCMONETARYUNIT",
  3368373690: "IFCMETRIC",
  677618848: "IFCMECHANICALSTEELMATERIALPROPERTIES",
  4256014907: "IFCMECHANICALMATERIALPROPERTIES",
  2597039031: "IFCMEASUREWITHUNIT",
  3265635763: "IFCMATERIALPROPERTIES",
  2199411900: "IFCMATERIALLIST",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  3303938423: "IFCMATERIALLAYERSET",
  248100487: "IFCMATERIALLAYER",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  1838606355: "IFCMATERIAL",
  30780891: "IFCLOCALTIME",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  3452421091: "IFCLIBRARYREFERENCE",
  2655187982: "IFCLIBRARYINFORMATION",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  852622518: "IFCGRIDAXIS",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  3207319532: "IFCEXTERNALLYDEFINEDSYMBOL",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  3200245327: "IFCEXTERNALREFERENCE",
  1648886627: "IFCENVIRONMENTALIMPACTVALUE",
  3796139169: "IFCDRAUGHTINGCALLOUTRELATIONSHIP",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  1154170062: "IFCDOCUMENTINFORMATION",
  1376555844: "IFCDOCUMENTELECTRONICFORMAT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  1045800335: "IFCDERIVEDUNITELEMENT",
  1765591967: "IFCDERIVEDUNIT",
  1072939445: "IFCDATEANDTIME",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  1105321065: "IFCCURVESTYLEFONT",
  539742890: "IFCCURRENCYRELATIONSHIP",
  602808272: "IFCCOSTVALUE",
  1065062679: "IFCCOORDINATEDUNIVERSALTIMEOFFSET",
  347226245: "IFCCONSTRAINTRELATIONSHIP",
  613356794: "IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",
  1658513725: "IFCCONSTRAINTAGGREGATIONRELATIONSHIP",
  1959218052: "IFCCONSTRAINT",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  4257277454: "IFCCONNECTIONPORTGEOMETRY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  3264961684: "IFCCOLOURSPECIFICATION",
  3639012971: "IFCCLASSIFICATIONNOTATIONFACET",
  938368621: "IFCCLASSIFICATIONNOTATION",
  1098599126: "IFCCLASSIFICATIONITEMRELATIONSHIP",
  1767535486: "IFCCLASSIFICATIONITEM",
  747523909: "IFCCLASSIFICATION",
  622194075: "IFCCALENDARDATE",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1387855156: "IFCBOUNDARYNODECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  4037036970: "IFCBOUNDARYCONDITION",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  390851274: "IFCAPPROVALPROPERTYRELATIONSHIP",
  2080292479: "IFCAPPROVALACTORRELATIONSHIP",
  130549933: "IFCAPPROVAL",
  1110488051: "IFCAPPLIEDVALUERELATIONSHIP",
  411424972: "IFCAPPLIEDVALUE",
  639542469: "IFCAPPLICATION",
  618182010: "IFCADDRESS",
  3630933823: "IFCACTORROLE",
  599546466: "FILE_DESCRIPTION",
  1390159747: "FILE_NAME",
  1109904537: "FILE_SCHEMA"
};
var Kt = class _Kt {
  static async getUnits(s) {
    var n, r, a;
    const { IFCUNITASSIGNMENT: t } = web_ifc_api_exports, e = await s.getAllPropertiesOfType(t);
    if (!e)
      return 1;
    const i = Object.keys(e), o = e[parseInt(i[0], 10)];
    for (const c of o.Units) {
      if (c.value === void 0 || c.value === null)
        continue;
      const h = await s.getProperties(c.value);
      if (!h || !h.UnitType || !h.UnitType.value || h.UnitType.value !== "LENGTHUNIT")
        continue;
      let E = 1, u = 1;
      return h.Name.value === "METRE" && (u = 1), h.Name.value === "FOOT" && (u = 0.3048), ((n = h.Prefix) == null ? void 0 : n.value) === "MILLI" ? E = 1e-3 : ((r = h.Prefix) == null ? void 0 : r.value) === "CENTI" ? E = 0.01 : ((a = h.Prefix) == null ? void 0 : a.value) === "DECI" && (E = 0.1), u * E;
    }
    return 1;
  }
  static async findItemByGuid(s, t) {
    var i;
    const e = s.getAllPropertiesIDs();
    for (const o of e) {
      const n = await s.getProperties(o);
      if (n && ((i = n.GlobalId) == null ? void 0 : i.value) === t)
        return n;
    }
    return null;
  }
  static async getRelationMap(s, t, e) {
    var a;
    const o = e ?? (async () => {
    }), n = {}, r = s.getAllPropertiesIDs();
    for (const c of r) {
      const h = await s.getProperties(c);
      if (!h)
        continue;
      const d = h.type === t, E = Object.keys(h).find(
        (C) => C.startsWith("Relating")
      ), u = Object.keys(h).find(
        (C) => C.startsWith("Related")
      );
      if (!(d && E && u))
        continue;
      const f = await s.getProperties((a = h[E]) == null ? void 0 : a.value), T = h[u];
      if (!f || !T || !(T && Array.isArray(T)))
        continue;
      const R = T.map((C) => C.value);
      await o(f.expressID, R), n[f.expressID] = R;
    }
    return n;
  }
  static async getQsetQuantities(s, t, e) {
    const o = e ?? (() => {
    }), n = await s.getProperties(t);
    return !n || n.type !== IFCELEMENTQUANTITY ? null : (n.Quantities ?? [{}]).map((c) => (c.value && o(c.value), c.value)).filter((c) => c !== null);
  }
  static async getPsetProps(s, t, e) {
    const o = e ?? (() => {
    }), n = await s.getProperties(t);
    return !n || n.type !== IFCPROPERTYSET ? null : (n.HasProperties ?? [{}]).map((c) => (c.value && o(c.value), c.value)).filter((c) => c !== null);
  }
  static async getPsetRel(s, t) {
    var r;
    if (!await s.getProperties(t))
      return null;
    const i = await s.getAllPropertiesOfType(
      IFCRELDEFINESBYPROPERTIES
    );
    if (!i)
      return null;
    const o = Object.values(i);
    let n = null;
    for (const a of o)
      ((r = a.RelatingPropertyDefinition) == null ? void 0 : r.value) === t && (n = a.expressID);
    return n;
  }
  static async getQsetRel(s, t) {
    return _Kt.getPsetRel(s, t);
  }
  static async getEntityName(s, t) {
    var n;
    const e = await s.getProperties(t);
    if (!e)
      return { key: null, name: null };
    const i = Object.keys(e).find((r) => r.endsWith("Name")) ?? null, o = i ? (n = e[i]) == null ? void 0 : n.value : null;
    return { key: i, name: o };
  }
  static async getQuantityValue(s, t) {
    const e = await s.getProperties(t);
    if (!e)
      return { key: null, value: null };
    const i = Object.keys(e).find((n) => n.endsWith("Value")) ?? null;
    let o;
    return i === null || e[i] === void 0 || e[i] === null ? o = null : o = e[i].value, { key: i, value: o };
  }
  static isRel(s) {
    return Bn[s].startsWith("IFCREL");
  }
  static async attributeExists(s, t, e) {
    const i = await s.getProperties(t);
    return i ? Object.keys(i).includes(e) : false;
  }
  static async groupEntitiesByType(s, t) {
    var i;
    const e = /* @__PURE__ */ new Map();
    for (const o of t) {
      const n = await s.getProperties(o);
      if (!n)
        continue;
      const r = n.type;
      e.get(r) || e.set(r, /* @__PURE__ */ new Set()), (i = e.get(r)) == null || i.add(o);
    }
    return e;
  }
  // static getPropertyUnits(properties: IfcProperties, expressID: number) {
  //   const entity = properties[expressID];
  //   if (!entity) return null;
  //   const propertyInstance =
  //     entity instanceof WEBIFC.IFC2X3.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4X3.IfcProperty;
  //   if (!propertyInstance) return null;
  //   const { key: valueKey } = IfcPropertiesUtils.getQuantityValue(
  //     properties,
  //     expressID
  //   );
  //   if (!valueKey) return null;
  //   // @ts-ignore
  //   const measureName = entity[valueKey].constructor.name as string;
  //   const isMeasureAttribute = measureName.endsWith("Measure");
  //   if (!isMeasureAttribute) return null;
  //   const measureType = measureName.slice(3, measureName.length - 7);
  //   return propertyInstance;
  // }
};
var jr = class {
  constructor() {
    I(this, "factor", 1);
    I(this, "complement", 1);
  }
  apply(s) {
    const e = this.getScaleMatrix().multiply(s);
    s.copy(e);
  }
  setUp(s) {
    var o, n, r;
    this.factor = 1;
    const t = this.getLengthUnits(s);
    if (!t)
      return;
    const e = t == null, i = t.Name === void 0 || t.Name === null;
    e || i || (t.Name.value === "FOOT" && (this.factor = 0.3048), ((o = t.Prefix) == null ? void 0 : o.value) === "MILLI" ? this.complement = 1e-3 : ((n = t.Prefix) == null ? void 0 : n.value) === "CENTI" ? this.complement = 0.01 : ((r = t.Prefix) == null ? void 0 : r.value) === "DECI" && (this.complement = 0.01));
  }
  getLengthUnits(s) {
    try {
      const e = s.GetLineIDsWithType(
        0,
        IFCUNITASSIGNMENT
      ).get(0), i = s.GetLine(0, e);
      for (const o of i.Units) {
        if (!o || o.value === null || o.value === void 0)
          continue;
        const n = s.GetLine(0, o.value);
        if (n.UnitType && n.UnitType.value === "LENGTHUNIT")
          return n;
      }
      return null;
    } catch {
      return console.log("Could not get units"), null;
    }
  }
  getScaleMatrix() {
    const s = this.factor;
    return new Matrix4().fromArray([
      s,
      0,
      0,
      0,
      0,
      s,
      0,
      0,
      0,
      0,
      s,
      0,
      0,
      0,
      0,
      1
    ]);
  }
};
var Yn = class {
  constructor() {
    I(this, "itemsByFloor", {});
    I(this, "_units", new jr());
  }
  // TODO: Maybe make this more flexible so that it also support more exotic spatial structures?
  setUp(s) {
    this._units.setUp(s), this.cleanUp();
    try {
      const t = s.GetLineIDsWithType(
        0,
        IFCRELCONTAINEDINSPATIALSTRUCTURE
      ), e = /* @__PURE__ */ new Set(), i = s.GetLineIDsWithType(0, IFCSPACE);
      for (let c = 0; c < i.size(); c++)
        e.add(i.get(c));
      const o = s.GetLineIDsWithType(0, IFCRELAGGREGATES), n = o.size();
      for (let c = 0; c < n; c++) {
        const h = o.get(c), d = s.GetLine(0, h);
        if (!d || !d.RelatingObject || !d.RelatedObjects)
          continue;
        const E = d.RelatingObject.value, u = d.RelatedObjects;
        for (const f of u) {
          const T = f.value;
          e.has(T) && (this.itemsByFloor[T] = E);
        }
      }
      const r = {}, a = t.size();
      for (let c = 0; c < a; c++) {
        const h = t.get(c), d = s.GetLine(0, h);
        if (!d || !d.RelatingStructure || !d.RelatedElements)
          continue;
        const E = d.RelatingStructure.value, u = d.RelatedElements;
        if (e.has(E))
          for (const f of u) {
            r[E] || (r[E] = []);
            const T = f.value;
            r[E].push(T);
          }
        else
          for (const f of u) {
            const T = f.value;
            this.itemsByFloor[T] = E;
          }
      }
      for (const c in r) {
        const h = this.itemsByFloor[c];
        if (h !== void 0) {
          const d = r[c];
          for (const E of d)
            this.itemsByFloor[E] = h;
        }
      }
      for (let c = 0; c < n; c++) {
        const h = o.get(c), d = s.GetLine(0, h);
        if (!d || !d.RelatingObject || !d.RelatedObjects)
          continue;
        const E = d.RelatingObject.value, u = d.RelatedObjects;
        for (const f of u) {
          const T = f.value, R = this.itemsByFloor[E];
          R !== void 0 && (this.itemsByFloor[T] = R);
        }
      }
    } catch {
      console.log("Could not get floors.");
    }
  }
  cleanUp() {
    this.itemsByFloor = {};
  }
};
var yi = class {
  constructor() {
    I(this, "includeProperties", true);
    I(this, "optionalCategories", [IFCSPACE]);
    I(this, "coordinate", true);
    I(this, "wasm", {
      path: "",
      absolute: false,
      logLevel: LogLevel.LOG_LEVEL_OFF
    });
    I(this, "excludedCategories", /* @__PURE__ */ new Set());
    I(this, "saveLocations", false);
    I(this, "webIfc", {
      COORDINATE_TO_ORIGIN: true
      // OPTIMIZE_PROFILES: true,
    });
    I(this, "autoSetWasm", true);
    I(this, "customLocateFileHandler", null);
  }
};
var Vn = class {
  constructor() {
    I(this, "defLineMat", new LineBasicMaterial({ color: 16777215 }));
  }
  read(s) {
    const t = s.GetAllAlignments(0), e = s.GetAllCrossSections2D(0), i = s.GetAllCrossSections3D(0), o = {
      IfcAlignment: t,
      IfcCrossSection2D: e,
      IfcCrossSection3D: i
    };
    return this.get(o);
  }
  get(s) {
    if (s.IfcAlignment) {
      const t = /* @__PURE__ */ new Map();
      for (const e of s.IfcAlignment) {
        const i = new ke();
        i.absolute = this.getCurves(e.curve3D, i), i.horizontal = this.getCurves(e.horizontal, i), i.vertical = this.getCurves(e.vertical, i), t.set(t.size, i);
      }
      return { alignments: t, coordinationMatrix: new Matrix4() };
    }
  }
  getCurves(s, t) {
    const e = [];
    let i = 0;
    for (const o of s) {
      const n = {};
      if (o.data)
        for (const E of o.data) {
          const [u, f] = E.split(": "), T = parseFloat(f);
          n[u] = T || f;
        }
      const { points: r } = o, a = new Float32Array(r.length * 3);
      for (let E = 0; E < r.length; E++) {
        const { x: u, y: f, z: T } = r[E];
        a[E * 3] = u, a[E * 3 + 1] = f, a[E * 3 + 2] = T || 0;
      }
      const c = new BufferAttribute(a, 3), h = new EdgesGeometry();
      h.setAttribute("position", c);
      const d = new qe(
        i,
        n,
        t,
        h,
        this.defLineMat
      );
      e.push(d.curve), i++;
    }
    return e;
  }
};
var Gn = class {
  getNameInfo(s) {
    var d;
    const t = {}, { arguments: e } = s.GetHeaderLine(0, FILE_NAME) || {};
    if (!e)
      return t;
    const [
      i,
      o,
      n,
      r,
      a,
      c,
      h
    ] = e;
    if (i != null && i.value && (t.name = i.value), o != null && o.value && (t.creationDate = new Date(o.value)), n) {
      t.author = {};
      const [E, u] = n;
      E != null && E.value && (t.author.name = E.value), u != null && u.value && (t.author.email = u.value);
    }
    return (d = r[0]) != null && d.value && (t.organization = r[0].value), a != null && a.value && (t.preprocessorVersion = a == null ? void 0 : a.value), c != null && c.value && (t.originatingSystem = c == null ? void 0 : c.value), h != null && h.value && (t.authorization = h == null ? void 0 : h.value), t;
  }
  getDescriptionInfo(s) {
    var n;
    const t = {}, { arguments: e } = s.GetHeaderLine(0, FILE_DESCRIPTION) || {};
    if (!e)
      return t;
    const [i, o] = e;
    if ((n = i[0]) != null && n.value) {
      const r = i[0].value.match(/\[([^\]]+)\]/);
      r && r[1] && (t.viewDefinition = r[1]);
    }
    return o != null && o.value && (t.implementationLevel = o.value), t;
  }
};
var zn = class {
  static get(s, t) {
    const e = [
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE,
      IFCROAD,
      IFCFACILITY,
      IFCFACILITYPART,
      IFCBRIDGE
    ], i = s.data;
    for (const o of e) {
      const n = t.GetLineIDsWithType(0, o), r = n.size();
      for (let a = 0; a < r; a++) {
        const c = n.get(a);
        i.has(c) || i.set(c, [[], [0, o]]);
      }
    }
  }
};
var Ge = class Ge2 extends et {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "onIfcStartedLoading", new D());
    I(this, "onSetup", new D());
    I(this, "settings", new yi());
    I(this, "webIfc", new IfcAPI2());
    I(this, "enabled", true);
    I(this, "_material", new MeshLambertMaterial());
    I(this, "_spatialTree", new Yn());
    I(this, "_metaData", new Gn());
    I(this, "_fragmentInstances", /* @__PURE__ */ new Map());
    I(this, "_civil", new Vn());
    I(this, "_visitedFragments", /* @__PURE__ */ new Map());
    I(this, "_materialT", new MeshLambertMaterial({
      transparent: true,
      opacity: 0.5
    }));
    this.components.add(Ge2.uuid, this), this.settings.excludedCategories.add(IFCOPENINGELEMENT);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.webIfc = null, this.onDisposed.trigger(Ge2.uuid), this.onDisposed.reset();
  }
  /**
   * Sets up the IfcLoader component with the provided configuration.
   *
   * @param config - Optional configuration settings for the IfcLoader.
   * If not provided, the existing settings will be used.
   *
   * @returns A Promise that resolves when the setup process is completed.
   *
   * @remarks
   * If the `autoSetWasm` option is enabled in the configuration,
   * the method will automatically set the WASM paths for the Web-IFC library.
   *
   * @example
   * ```typescript
   * const ifcLoader = new IfcLoader(components);
   * await ifcLoader.setup({ autoSetWasm: true });
   * ```
   */
  async setup(t) {
    this.settings = { ...this.settings, ...t }, this.settings.autoSetWasm && await this.autoSetWasm(), this.onSetup.trigger();
  }
  /**
   * Loads an IFC file and processes it for 3D visualization.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @param coordinate - Optional boolean indicating whether to coordinate the loaded IFC data. Default is true.
   *
   * @returns A Promise that resolves to the FragmentsGroup containing the loaded and processed IFC data.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * const group = await ifcLoader.load(ifcData);
   * ```
   */
  async load(t, e = true) {
    const i = performance.now();
    this.onIfcStartedLoading.trigger(), await this.readIfcFile(t);
    const o = await this.getAllGeometries(), r = await this.components.get(mi).export(this.webIfc, 0);
    o.setLocalProperties(r);
    const a = this.components.get(ht);
    a.groups.set(o.uuid, o);
    for (const c of o.items)
      a.list.set(c.id, c), c.mesh.uuid = c.id, c.group = o;
    a.onFragmentsLoaded.trigger(o), e && a.coordinate([o]);
    for (const [c] of o.data) {
      const h = r[c];
      if (!h || !h.GlobalId)
        continue;
      const d = h.GlobalId.value || h.GlobalId;
      o.globalToExpressIDs.set(d, c);
    }
    return zn.get(o, this.webIfc), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - i} ms!`), o;
  }
  /**
   * Reads an IFC file and initializes the Web-IFC library.
   *
   * @param data - The Uint8Array containing the IFC file data.
   *
   * @returns A Promise that resolves when the IFC file is opened and initialized.
   *
   * @remarks
   * This method sets the WASM path and initializes the Web-IFC library based on the provided settings.
   * It also opens the IFC model using the provided data and settings.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * await ifcLoader.readIfcFile(ifcData);
   * ```
   */
  async readIfcFile(t) {
    const { path: e, absolute: i, logLevel: o } = this.settings.wasm;
    return this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  /**
   * Cleans up the IfcLoader component by resetting the Web-IFC library,
   * clearing the visited fragments and fragment instances maps, and creating a new instance of the Web-IFC library.
   *
   * @remarks
   * This method is called automatically after using the .load() method, so usually you don't need to use it manually.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * ifcLoader.cleanUp();
   * ```
   */
  cleanUp() {
    this.webIfc.Dispose(), this.webIfc = null, this.webIfc = new IfcAPI2(), this._visitedFragments.clear(), this._fragmentInstances.clear();
  }
  async getAllGeometries() {
    this._spatialTree.setUp(this.webIfc);
    const t = this.webIfc.GetIfcEntityList(0), e = new Ms();
    e.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    const i = [];
    for (const n of t) {
      if (!this.webIfc.IsIfcElement(n) && n !== IFCSPACE || this.settings.excludedCategories.has(n))
        continue;
      const r = this.webIfc.GetLineIDsWithType(0, n), a = r.size();
      for (let c = 0; c < a; c++) {
        const h = r.get(c);
        i.push(h);
        const d = this._spatialTree.itemsByFloor[h] || 0;
        e.data.set(h, [[], [d, n]]);
      }
    }
    this._spatialTree.cleanUp(), this.webIfc.StreamMeshes(0, i, (n) => {
      this.getMesh(n, e);
    });
    for (const n of this._visitedFragments) {
      const { index: r, fragment: a } = n[1];
      e.keyFragments.set(r, a.id);
    }
    for (const n of e.items) {
      const r = this._fragmentInstances.get(n.id);
      if (!r)
        throw new Error("Fragment not found!");
      const a = [];
      for (const [c, h] of r)
        a.push(h);
      n.add(a);
    }
    const o = this.webIfc.GetCoordinationMatrix(0);
    return e.coordinationMatrix.fromArray(o), e.civilData = this._civil.read(this.webIfc), e;
  }
  getMesh(t, e) {
    const i = t.geometries.size(), o = t.expressID;
    for (let n = 0; n < i; n++) {
      const r = t.geometries.get(n), { x: a, y: c, z: h, w: d } = r.color, E = d !== 1, { geometryExpressID: u } = r, f = `${u}-${E}`;
      if (!this._visitedFragments.has(f)) {
        const m = this.getGeometry(this.webIfc, u), g = E ? this._materialT : this._material, S = new Ee(m, g, 1);
        e.add(S.mesh), e.items.push(S);
        const _ = this._visitedFragments.size;
        this._visitedFragments.set(f, { index: _, fragment: S });
      }
      const T = new Color().setRGB(a, c, h, "srgb"), R = new Matrix4();
      R.fromArray(r.flatTransformation);
      const C = this._visitedFragments.get(f);
      if (C === void 0)
        throw new Error("Error getting geometry data for streaming!");
      const A = e.data.get(o);
      if (!A)
        throw new Error("Data not found!");
      A[0].push(C.index);
      const { fragment: F } = C;
      this._fragmentInstances.has(F.id) || this._fragmentInstances.set(F.id, /* @__PURE__ */ new Map());
      const p = this._fragmentInstances.get(F.id);
      if (!p)
        throw new Error("Instances not found!");
      if (p.has(o)) {
        const m = p.get(o);
        if (!m)
          throw new Error("Instance not found!");
        m.transforms.push(R), m.colors && m.colors.push(T);
      } else
        p.set(o, { id: o, transforms: [R], colors: [T] });
    }
  }
  getGeometry(t, e) {
    const i = t.GetGeometry(0, e), o = t.GetIndexArray(
      i.GetIndexData(),
      i.GetIndexDataSize()
    ), n = t.GetVertexArray(
      i.GetVertexData(),
      i.GetVertexDataSize()
    ), r = new Float32Array(n.length / 2), a = new Float32Array(n.length / 2);
    for (let E = 0; E < n.length; E += 6)
      r[E / 2] = n[E], r[E / 2 + 1] = n[E + 1], r[E / 2 + 2] = n[E + 2], a[E / 2] = n[E + 3], a[E / 2 + 1] = n[E + 4], a[E / 2 + 2] = n[E + 5];
    const c = new BufferGeometry(), h = new BufferAttribute(r, 3), d = new BufferAttribute(a, 3);
    return c.setAttribute("position", h), c.setAttribute("normal", d), c.setIndex(Array.from(o)), i.delete(), c;
  }
  async autoSetWasm() {
    const t = await fetch(
      `https://unpkg.com/@thatopen/components@${pi.release}/package.json`
    );
    if (!t.ok) {
      console.warn(
        "Couldn't get openbim-components package.json. Set wasm settings manually."
      );
      return;
    }
    const e = await t.json();
    if (!("web-ifc" in e.peerDependencies))
      console.warn(
        "Couldn't get web-ifc from peer dependencies in openbim-components. Set wasm settings manually."
      );
    else {
      const i = e.peerDependencies["web-ifc"];
      this.settings.wasm.path = `https://unpkg.com/web-ifc@${i}/`, this.settings.wasm.absolute = true;
    }
  }
};
I(Ge, "uuid", "a659add7-1418-4771-a0d6-7d4d438e4624");
var Ri = Ge;
var Bt = class Bt2 extends et {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "onRequestFile", new D());
    I(this, "ifcToExport", null);
    I(this, "onElementToPset", new D());
    I(this, "onPropToPset", new D());
    I(this, "onPsetRemoved", new D());
    I(this, "onDataChanged", new D());
    I(this, "wasm", {
      path: "/",
      absolute: false
    });
    I(this, "enabled", true);
    I(this, "attributeListeners", {});
    I(this, "selectedModel");
    I(this, "changeMap", {});
    this.components.add(Bt2.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.selectedModel = void 0, this.attributeListeners = {}, this.changeMap = {}, this.onElementToPset.reset(), this.onPropToPset.reset(), this.onPsetRemoved.reset(), this.onDataChanged.reset(), this.onDisposed.trigger(Bt2.uuid), this.onDisposed.reset();
  }
  /**
   * Static method to retrieve the IFC schema from a given model.
   *
   * @param model - The FragmentsGroup model from which to retrieve the IFC schema.
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @returns The IFC schema associated with the given model.
   */
  static getIFCSchema(t) {
    const e = t.ifcMetadata.schema;
    if (!e)
      throw new Error("IFC Schema not found");
    return e.startsWith("IFC2X3") ? "IFC2X3" : e.startsWith("IFC4") && e.replace("IFC4", "") === "" ? "IFC4" : e.startsWith("IFC4X3") ? "IFC4X3" : e;
  }
  /**
   * Method to set properties data in the model.
   *
   * @param model - The FragmentsGroup model in which to set the properties.
   * @param dataToSave - An array of objects representing the properties to be saved.
   * Each object must have an `expressID` property, which is the express ID of the entity in the model.
   * The rest of the properties will be set as the properties of the entity.
   *
   * @returns A promise that resolves when all the properties have been set.
   *
   * @throws Will throw an error if any of the `expressID` properties are missing in the `dataToSave` array.
   */
  async setData(t, ...e) {
    for (const i of e) {
      const o = i.expressID;
      o && (await t.setProperties(o, i), this.registerChange(t, o));
    }
  }
  /**
   * Creates a new Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the Pset.
   * @param name - The name of the Pset.
   * @param description - (Optional) The description of the Pset.
   *
   * @returns A promise that resolves with an object containing the newly created Pset and its relation.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  async newPset(t, e, i) {
    const o = Bt2.getIFCSchema(t), { ownerHistoryHandle: n } = await this.getOwnerHistory(t), r = this.newGUID(t), a = new web_ifc_api_exports[o].IfcLabel(e), c = i ? new web_ifc_api_exports[o].IfcText(i) : null, h = new web_ifc_api_exports[o].IfcPropertySet(
      r,
      n,
      a,
      c,
      []
    );
    h.expressID = this.increaseMaxID(t);
    const d = this.newGUID(t), E = new web_ifc_api_exports[o].IfcRelDefinesByProperties(
      d,
      n,
      null,
      null,
      [],
      new Handle(h.expressID)
    );
    return E.expressID = this.increaseMaxID(t), await this.setData(t, h, E), { pset: h, rel: E };
  }
  /**
   * Removes a Property Set (Pset) from the given model.
   *
   * @param model - The FragmentsGroup model from which to remove the Pset.
   * @param psetID - The express IDs of the Psets to be removed.
   *
   * @returns A promise that resolves when all the Psets have been removed.
   *
   * @throws Will throw an error if any of the `expressID` properties are missing in the `psetID` array.
   * @throws Will throw an error if the Pset to be removed is not of type `IFCPROPERTYSET`.
   * @throws Will throw an error if no relation is found between the Pset and the model.
   */
  async removePset(t, ...e) {
    for (const i of e) {
      const o = await t.getProperties(i);
      if ((o == null ? void 0 : o.type) !== IFCPROPERTYSET)
        continue;
      const n = await Kt.getPsetRel(t, i);
      if (n && (await t.setProperties(n, null), this.registerChange(t, n)), o) {
        for (const r of o.HasProperties)
          await t.setProperties(r.value, null);
        await t.setProperties(i, null), this.onPsetRemoved.trigger({ model: t, psetID: i }), this.registerChange(t, i);
      }
    }
  }
  /**
   * Creates a new single-value property of type string in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a string property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a string.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleStringProperty(t, e, i, o) {
    return this.newSingleProperty(t, e, i, o);
  }
  /**
   * Creates a new single-value property of type numeric in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a numeric property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a number.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleNumericProperty(t, e, i, o) {
    return this.newSingleProperty(t, e, i, o);
  }
  /**
   * Creates a new single-value property of type boolean in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a boolean property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a boolean.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleBooleanProperty(t, e, i, o) {
    return this.newSingleProperty(t, e, i, o);
  }
  /**
   * Removes a property from a Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model from which to remove the property.
   * @param psetID - The express ID of the Pset from which to remove the property.
   * @param propID - The express ID of the property to be removed.
   *
   * @returns A promise that resolves when the property has been removed.
   *
   * @throws Will throw an error if the Pset or the property to be removed are not found in the model.
   * @throws Will throw an error if the Pset to be removed is not of type `IFCPROPERTYSET`.
   */
  async removePsetProp(t, e, i) {
    const o = await t.getProperties(e), n = await t.getProperties(i);
    !o || !n || o.type === IFCPROPERTYSET && n && (o.HasProperties = o.HasProperties.filter((r) => r.value !== i), await t.setProperties(i, null), this.registerChange(t, e, i));
  }
  async addElementToPset(t, e, ...i) {
    const o = await Kt.getPsetRel(t, e);
    if (!o)
      return;
    const n = await t.getProperties(o);
    if (!n)
      return;
    for (const a of i) {
      const c = new Handle(a);
      n.RelatedObjects.push(c), this.onElementToPset.trigger({
        model: t,
        psetID: e,
        elementID: a
      });
    }
    this.registerChange(t, e);
    const r = this.components.get(pe);
    for (const a of i)
      r.addEntityRelations(t, a, "IsDefinedBy", e);
  }
  /**
   * Adds elements to a Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model in which to add the elements.
   * @param psetID - The express ID of the Pset to which to add the elements.
   * @param elementID - The express IDs of the elements to be added.
   *
   * @returns A promise that resolves when all the elements have been added.
   *
   * @throws Will throw an error if the Pset or the elements to be added are not found in the model.
   * @throws Will throw an error if the Pset to be added to is not of type `IFCPROPERTYSET`.
   * @throws Will throw an error if no relation is found between the Pset and the model.
   */
  async addPropToPset(t, e, ...i) {
    const o = await t.getProperties(e);
    if (o) {
      for (const n of i) {
        if (o.HasProperties.includes(n))
          continue;
        const r = new Handle(n);
        o.HasProperties.push(r), this.onPropToPset.trigger({ model: t, psetID: e, propID: n });
      }
      this.registerChange(t, e);
    }
  }
  /**
   * Saves the changes made to the model to a new IFC file.
   *
   * @param model - The FragmentsGroup model from which to save the changes.
   * @param ifcToSaveOn - The Uint8Array representing the original IFC file.
   *
   * @returns A promise that resolves with the modified IFC data as a Uint8Array.
   *
   * @throws Will throw an error if any issues occur during the saving process.
   */
  async saveToIfc(t, e) {
    const i = this.components.get(Ri), o = i.webIfc, n = await i.readIfcFile(e), r = this.changeMap[t.uuid] ?? [];
    for (const c of r) {
      const h = await t.getProperties(c);
      if (h)
        try {
          o.WriteLine(n, h);
        } catch {
        }
      else
        try {
          o.DeleteLine(n, c);
        } catch {
        }
    }
    const a = o.SaveModel(n);
    return i.webIfc.CloseModel(n), i.cleanUp(), a;
  }
  /**
   * Sets an attribute listener for a specific attribute of an entity in the model.
   * The listener will trigger an event whenever the attribute's value changes.
   *
   * @param model - The FragmentsGroup model in which to set the attribute listener.
   * @param expressID - The express ID of the entity for which to set the listener.
   * @param attributeName - The name of the attribute for which to set the listener.
   *
   * @returns The event that will be triggered when the attribute's value changes.
   *
   * @throws Will throw an error if the entity with the given expressID doesn't exist.
   * @throws Will throw an error if the attribute is an array or null, and it can't have a listener.
   * @throws Will throw an error if the attribute has a badly defined handle.
   */
  async setAttributeListener(t, e, i) {
    this.attributeListeners[t.uuid] || (this.attributeListeners[t.uuid] = {});
    const o = this.attributeListeners[t.uuid][e] ? this.attributeListeners[t.uuid][e][i] : null;
    if (o)
      return o;
    const n = await t.getProperties(e);
    if (!n)
      throw new Error(`Entity with expressID ${e} doesn't exists.`);
    const r = n[i];
    if (Array.isArray(r) || !r)
      throw new Error(
        `Attribute ${i} is array or null, and it can't have a listener.`
      );
    const a = r.value;
    if (a === void 0 || a == null)
      throw new Error(`Attribute ${i} has a badly defined handle.`);
    const c = new D();
    return Object.defineProperty(n[i], "value", {
      get() {
        return this._value;
      },
      async set(h) {
        this._value = h, c.trigger(h);
      }
    }), n[i].value = a, this.attributeListeners[t.uuid][e] || (this.attributeListeners[t.uuid][e] = {}), this.attributeListeners[t.uuid][e][i] = c, c;
  }
  increaseMaxID(t) {
    return t.ifcMetadata.maxExpressID++, t.ifcMetadata.maxExpressID;
  }
  newGUID(t) {
    const e = Bt2.getIFCSchema(t);
    return new web_ifc_api_exports[e].IfcGloballyUniqueId(ze.create());
  }
  async getOwnerHistory(t) {
    const e = await t.getAllPropertiesOfType(
      IFCOWNERHISTORY
    );
    if (!e)
      throw new Error("No OwnerHistory was found.");
    const i = Object.keys(e).map((r) => parseInt(r, 10)), o = e[i[0]], n = new Handle(o.expressID);
    return { ownerHistory: o, ownerHistoryHandle: n };
  }
  registerChange(t, ...e) {
    this.changeMap[t.uuid] || (this.changeMap[t.uuid] = /* @__PURE__ */ new Set());
    for (const i of e)
      this.changeMap[t.uuid].add(i), this.onDataChanged.trigger({ model: t, expressID: i });
  }
  async newSingleProperty(t, e, i, o) {
    const n = Bt2.getIFCSchema(t), r = new web_ifc_api_exports[n].IfcIdentifier(i), a = new web_ifc_api_exports[n][e](o), c = new web_ifc_api_exports[n].IfcPropertySingleValue(
      r,
      null,
      a,
      null
    );
    return c.expressID = this.increaseMaxID(t), await this.setData(t, c), c;
  }
};
I(Bt, "uuid", "58c2d9f0-183c-48d6-a402-dfcf5b9a34df");
var gn = Bt;
var ys = class ys2 extends et {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    I(this, "list", {});
    I(this, "onDisposed", new D());
    I(this, "onFragmentsDisposed", (t2) => {
      const { groupID: e, fragmentIDs: i } = t2;
      for (const o in this.list) {
        const n = this.list[o], r = Object.keys(n);
        if (r.includes(e))
          delete n[e], Object.values(n).length === 0 && delete this.list[o];
        else
          for (const a of r) {
            const c = n[a];
            for (const h of i)
              delete c.map[h];
            Object.values(c).length === 0 && delete n[a];
          }
      }
    });
    t.add(ys2.uuid, this), t.get(ht).onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list = {}, this.components.get(ht).onFragmentsDisposed.remove(this.onFragmentsDisposed), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Removes a fragment from the classification based on its unique identifier (guid).
   * This method iterates through all classification systems and classes, and deletes the fragment with the specified guid from the respective group.
   *
   * @param guid - The unique identifier of the fragment to be removed.
   */
  remove(t) {
    for (const e in this.list) {
      const i = this.list[e];
      for (const o in i) {
        const n = i[o];
        delete n.map[t];
      }
    }
  }
  /**
   * Finds and returns fragments based on the provided filter criteria.
   * If no filter is provided, it returns all fragments.
   *
   * @param filter - An optional object containing filter criteria.
   * The keys of the object represent the classification system names,
   * and the values are arrays of class names to match.
   *
   * @returns A map of fragment GUIDs to their respective express IDs,
   * where the express IDs are filtered based on the provided filter criteria.
   *
   * @throws Will throw an error if the fragments map is malformed.
   */
  find(t) {
    const e = this.components.get(ht);
    if (!t) {
      const r = {};
      for (const [a, c] of e.list)
        r[a] = new Set(c.ids);
      return r;
    }
    const i = Object.keys(t).length, o = {};
    for (const r in t) {
      const a = t[r];
      if (!this.list[r]) {
        console.warn(`Classification ${r} does not exist.`);
        continue;
      }
      for (const c of a) {
        const h = this.list[r][c];
        if (h)
          for (const d in h.map) {
            o[d] || (o[d] = /* @__PURE__ */ new Map());
            for (const E of h.map[d]) {
              const u = o[d].get(E);
              u === void 0 ? o[d].set(E, 1) : o[d].set(E, u + 1);
            }
          }
      }
    }
    const n = {};
    for (const r in o) {
      const a = o[r];
      for (const [c, h] of a) {
        if (h === void 0)
          throw new Error("Malformed fragments map!");
        h === i && (n[r] || (n[r] = /* @__PURE__ */ new Set()), n[r].add(c));
      }
    }
    return n;
  }
  /**
   * Classifies fragments based on their modelID.
   *
   * @param modelID - The unique identifier of the model to classify fragments by.
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the fragments in the provided group,
   * and classifies them based on their modelID.
   * The classification is stored in the `list.models` property,
   * with the modelID as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   */
  byModel(t, e) {
    this.list.models || (this.list.models = {});
    const i = this.list.models;
    i[t] || (i[t] = { map: {}, id: null, name: t });
    const o = i[t];
    for (const [n, r] of e.data) {
      const a = r[0];
      for (const c of a) {
        const h = e.keyFragments.get(c);
        h && (o.map[h] || (o.map[h] = /* @__PURE__ */ new Set()), o.map[h].add(n));
      }
    }
  }
  /**
   * Classifies fragments based on their PredefinedType property.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the properties of the fragments in the provided group,
   * and classifies them based on their PredefinedType property.
   * The classification is stored in the `list.predefinedTypes` property,
   * with the PredefinedType as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found.
   */
  async byPredefinedType(t) {
    var o;
    this.list.predefinedTypes || (this.list.predefinedTypes = {});
    const e = this.list.predefinedTypes, i = t.getAllPropertiesIDs();
    for (const n of i) {
      const r = await t.getProperties(n);
      if (!r)
        continue;
      const a = String((o = r.PredefinedType) == null ? void 0 : o.value).toUpperCase();
      e[a] || (e[a] = {
        map: {},
        id: null,
        name: a
      });
      const c = e[a];
      for (const [h, d] of t.data) {
        const E = d[0];
        for (const u of E) {
          const f = t.keyFragments.get(u);
          if (!f)
            throw new Error("Fragment ID not found!");
          c.map[f] || (c.map[f] = /* @__PURE__ */ new Set()), c.map[f].add(r.expressID);
        }
      }
    }
  }
  /**
   * Classifies fragments based on their entity type.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on their entity type.
   * The classification is stored in the `list.entities` property,
   * with the entity type as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found.
   */
  byEntity(t) {
    this.list.entities || (this.list.entities = {});
    for (const [e, i] of t.data) {
      const n = i[1][1], r = Bn[n];
      this.saveItem(t, "entities", r, e);
    }
  }
  /**
   * Classifies fragments based on a specific IFC relationship.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   * @param ifcRel - The IFC relationship number to classify fragments by.
   * @param systemName - The name of the classification system to store the classification.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on the specified IFC relationship.
   * The classification is stored in the `list` property under the specified system name,
   * with the relationship name as the class name and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found or if the IFC relationship is not valid.
   */
  async byIfcRel(t, e, i) {
    Kt.isRel(e) && await Kt.getRelationMap(
      t,
      e,
      async (o, n) => {
        const { name: r } = await Kt.getEntityName(
          t,
          o
        );
        for (const a of n)
          this.saveItem(
            t,
            i,
            r ?? "NO REL NAME",
            a
          );
      }
    );
  }
  /**
   * Classifies fragments based on their spatial structure in the IFC model.
   *
   * @param model - The FragmentsGroup containing the fragments to be classified.
   * @param config - The configuration for the classifier. It includes "useProperties", which is true by default
   * (if false, the classification will use the expressIDs instead of the names), and "isolate", which will make
   * the classifier just pick the WEBIFC categories provided.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on their spatial structure in the IFC model.
   * The classification is stored in the `list` property under the system name "spatialStructures",
   * with the relationship name as the class name and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found or if the model relations do not exist.
   */
  async bySpatialStructure(t, e = {}) {
    var c, h;
    const i = this.components.get(pe), o = i.relationMaps[t.uuid];
    if (!o)
      throw new Error(
        `Classifier: model relations of ${t.name || t.uuid} have to exists to group by spatial structure.`
      );
    const n = "spatialStructures", a = e.useProperties === void 0 || e.useProperties;
    for (const [d] of o) {
      if (e.isolate) {
        const T = t.data.get(d);
        if (!T)
          continue;
        const R = T[1][1];
        if (R === void 0 || !e.isolate.has(R))
          continue;
      }
      const E = i.getEntityRelations(
        t,
        d,
        "Decomposes"
      );
      if (E)
        for (const T of E) {
          let R = T.toString();
          if (a) {
            const C = await t.getProperties(T);
            if (!C)
              continue;
            R = (c = C.Name) == null ? void 0 : c.value;
          }
          this.saveItem(t, n, R, d, T);
        }
      const u = i.getEntityRelations(
        t,
        d,
        "ContainsElements"
      );
      if (!u)
        continue;
      let f = d.toString();
      if (a) {
        const T = await t.getProperties(d);
        if (!T)
          continue;
        f = (h = T.Name) == null ? void 0 : h.value;
      }
      for (const T of u) {
        this.saveItem(t, n, f, T, d);
        const R = i.getEntityRelations(
          t,
          Number(T),
          "IsDecomposedBy"
        );
        if (R)
          for (const C of R)
            this.saveItem(t, n, f, C, d);
      }
    }
  }
  /**
   * Sets the color of the specified fragments.
   *
   * @param items - A map of fragment IDs to their respective express IDs.
   * @param color - The color to set for the fragments.
   * @param override - A boolean indicating whether to override the existing color of the fragments.
   *
   * @remarks
   * This method iterates through the provided fragment IDs, retrieves the corresponding fragments,
   * and sets their color using the `setColor` method of the FragmentsGroup class.
   *
   * @throws Will throw an error if the fragment with the specified ID is not found.
   */
  setColor(t, e, i = false) {
    const o = this.components.get(ht);
    for (const n in t) {
      const r = o.list.get(n);
      if (!r)
        continue;
      const a = t[n];
      r.setColor(e, a, i);
    }
  }
  /**
   * Resets the color of the specified fragments to their original color.
   *
   * @param items - A map of fragment IDs to their respective express IDs.
   *
   * @remarks
   * This method iterates through the provided fragment IDs, retrieves the corresponding fragments,
   * and resets their color using the `resetColor` method of the FragmentsGroup class.
   *
   * @throws Will throw an error if the fragment with the specified ID is not found.
   */
  resetColor(t) {
    const e = this.components.get(ht);
    for (const i in t) {
      const o = e.list.get(i);
      if (!o)
        continue;
      const n = t[i];
      o.resetColor(n);
    }
  }
  saveItem(t, e, i, o, n = null) {
    this.list[e] || (this.list[e] = {});
    const r = t.data.get(o);
    if (r)
      for (const a of r[0]) {
        const c = t.keyFragments.get(a);
        if (c) {
          const h = this.list[e];
          h[i] || (h[i] = { map: {}, id: n, name: i }), h[i].map[c] || (h[i].map[c] = /* @__PURE__ */ new Set()), h[i].map[c].add(o);
        }
      }
  }
};
I(ys, "uuid", "e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7");
var Ai = ys;
var Ls = class Ls2 extends et {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "enabled", true);
    I(this, "height", 10);
    I(this, "groupName", "spatialStructures");
    I(this, "list", /* @__PURE__ */ new Set());
    t.add(Ls2.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Sets the explosion state of the fragments.
   *
   * @param active - A boolean indicating whether to activate or deactivate the explosion.
   *
   * @remarks
   * This method applies a vertical transformation to the fragments based on the `active` parameter.
   * If `active` is true, the fragments are moved upwards by a distance determined by the `height` property.
   * If `active` is false, the fragments are moved back to their original position.
   *
   * The method also keeps track of the exploded items using the `list` set.
   *
   * @throws Will throw an error if the `Classifier` or `FragmentsManager` components are not found in the `components` system.
   */
  set(t) {
    if (!this.enabled)
      return;
    const e = this.components.get(Ai), i = this.components.get(ht), o = t ? 1 : -1;
    let n = 0;
    const r = e.list[this.groupName], a = new Matrix4();
    for (const c in r) {
      a.elements[13] = n * o * this.height;
      for (const h in r[c].map) {
        const d = i.list.get(h), E = c + h, u = this.list.has(E);
        if (!d || t && u || !t && !u)
          continue;
        t ? this.list.add(E) : this.list.delete(E);
        const f = r[c].map[h];
        d.applyTransform(f, a), d.mesh.computeBoundingSphere(), d.mesh.computeBoundingBox();
      }
      n++;
    }
  }
};
I(Ls, "uuid", "d260618b-ce88-4c7d-826c-6debb91de3e2");
var On = Ls;
var Ms2 = class Ms3 extends et {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    this.components.add(Ms3.uuid, this);
  }
  /**
   * Sets the visibility of fragments within the 3D scene.
   * If no `items` parameter is provided, all fragments will be set to the specified visibility.
   * If `items` is provided, only the specified fragments will be affected.
   *
   * @param visible - The visibility state to set for the fragments.
   * @param items - An optional map of fragment IDs and their corresponding sub-fragment IDs to be affected.
   * If not provided, all fragments will be affected.
   *
   * @returns {void}
   */
  set(t, e) {
    const i = this.components.get(ht);
    if (!e) {
      for (const [o, n] of i.list)
        n && (n.setVisibility(t), this.updateCulledVisibility(n));
      return;
    }
    for (const o in e) {
      const n = e[o], r = i.list.get(o);
      r && (r.setVisibility(t, n), this.updateCulledVisibility(r));
    }
  }
  /**
   * Isolates fragments within the 3D scene by hiding all other fragments and showing only the specified ones.
   * It calls the `set` method twice: first to hide all fragments, and then to show only the specified ones.
   *
   * @param items - A map of fragment IDs and their corresponding sub-fragment IDs to be isolated.
   * If not provided, all fragments will be isolated.
   *
   * @returns {void}
   */
  isolate(t) {
    this.set(false), this.set(true, t);
  }
  updateCulledVisibility(t) {
    const e = this.components.get(Ti);
    for (const [i, o] of e.list) {
      const n = o.colorMeshes.get(t.id);
      n && (n.count = t.mesh.count);
    }
  }
};
I(Ms2, "uuid", "dd9ccf2d-8a21-4821-b7f6-2949add16a29");
var Sn = Ms2;
var qr = class extends yi {
  constructor() {
    super(...arguments);
    I(this, "minGeometrySize", 10);
    I(this, "minAssetsSize", 1e3);
  }
};
var ws = class ws2 extends et {
  constructor(t) {
    super(t);
    I(this, "onGeometryStreamed", new D());
    I(this, "onAssetStreamed", new D());
    I(this, "onProgress", new D());
    I(this, "onIfcLoaded", new D());
    I(this, "onDisposed", new D());
    I(this, "settings", new qr());
    I(this, "enabled", true);
    I(this, "webIfc", new IfcAPI2());
    I(this, "_spatialTree", new Yn());
    I(this, "_metaData", new Gn());
    I(this, "_visitedGeometries", /* @__PURE__ */ new Map());
    I(this, "_streamSerializer", new ln());
    I(this, "_geometries", /* @__PURE__ */ new Map());
    I(this, "_geometryCount", 0);
    I(this, "_civil", new Vn());
    I(this, "_groupSerializer", new fn());
    I(this, "_assets", []);
    I(this, "_meshesWithHoles", /* @__PURE__ */ new Set());
    this.components.add(ws2.uuid, this), this.settings.excludedCategories.add(IFCOPENINGELEMENT);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onIfcLoaded.reset(), this.onGeometryStreamed.reset(), this.onAssetStreamed.reset(), this.webIfc = null, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * This method streams the IFC file from a given buffer.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   *
   * @remarks
   * This method cleans up any resources after the streaming process is complete.
   *
   * @example
   * ```typescript
   * const ifcData = await fetch('path/to/ifc/file.ifc');
   * const rawBuffer = await response.arrayBuffer();
   * const ifcBuffer = new Uint8Array(rawBuffer);
   * await ifcGeometryTiler.streamFromBuffer(ifcBuffer);
   * ```
   */
  async streamFromBuffer(t) {
    await this.readIfcFile(t), await this.streamAllGeometries(), this.cleanUp();
  }
  /**
   * This method streams the IFC file from a given callback.
   *
   * @param loadCallback - The callback function that will be used to load the IFC file.
   * @returns A Promise that resolves when the streaming process is complete.
   *
   * @remarks
   * This method cleans up any resources after the streaming process is complete.
   *
   */
  async streamFromCallBack(t) {
    await this.streamIfcFile(t), await this.streamAllGeometries(), this.cleanUp();
  }
  async readIfcFile(t) {
    const { path: e, absolute: i, logLevel: o } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: e, absolute: i, logLevel: o } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllGeometries() {
    const { minGeometrySize: t, minAssetsSize: e } = this.settings;
    this._spatialTree.setUp(this.webIfc);
    const i = this.webIfc.GetIfcEntityList(0), o = [[]], n = new Ms();
    n.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    let r = 0, a = 0;
    for (const T of i) {
      if (!this.webIfc.IsIfcElement(T) && T !== IFCSPACE || this.settings.excludedCategories.has(T))
        continue;
      const R = this.webIfc.GetLineIDsWithType(0, T), C = R.size();
      for (let A = 0; A < C; A++) {
        r > t && (r = 0, a++, o.push([]));
        const F = R.get(A);
        o[a].push(F);
        const p = this.webIfc.GetLine(0, F);
        if (p.GlobalId) {
          const g = (p == null ? void 0 : p.GlobalId.value) || (p == null ? void 0 : p.GlobalId);
          n.globalToExpressIDs.set(g, F);
        }
        const m = this._spatialTree.itemsByFloor[F] || 0;
        n.data.set(F, [[], [m, T]]), r++;
      }
    }
    this._spatialTree.cleanUp();
    let c = 0.01, h = 0;
    for (const T of o) {
      h++, this.webIfc.StreamMeshes(0, T, (C) => {
        this.getMesh(this.webIfc, C, n);
      }), this._geometryCount > t && await this.streamGeometries(), this._assets.length > e && await this.streamAssets();
      const R = h / o.length;
      R > c && (c += 0.01, c = Math.max(c, R), this.onProgress.trigger(Math.round(c * 100) / 100));
    }
    this._geometryCount && await this.streamGeometries(), this._assets.length && await this.streamAssets();
    const { opaque: d, transparent: E } = n.geometryIDs;
    for (const [T, { index: R, uuid: C }] of this._visitedGeometries)
      n.keyFragments.set(R, C), (T > 1 ? d : E).set(T, R);
    zn.get(n, this.webIfc);
    const u = this.webIfc.GetCoordinationMatrix(0);
    n.coordinationMatrix.fromArray(u), n.civilData = this._civil.read(this.webIfc);
    const f = this._groupSerializer.export(n);
    this.onIfcLoaded.trigger(f), n.dispose(true);
  }
  cleanUp() {
    this.webIfc.Dispose(), this.webIfc = null, this.webIfc = new IfcAPI2(), this._visitedGeometries.clear(), this._geometries.clear(), this._assets = [], this._meshesWithHoles.clear();
  }
  getMesh(t, e, i) {
    const o = e.geometries.size(), n = e.expressID, r = { id: n, geometries: [] };
    for (let a = 0; a < o; a++) {
      const c = e.geometries.get(a), h = c.geometryExpressID, d = c.color.w === 1 ? 1 : -1, E = h * d;
      if (!this._visitedGeometries.has(E)) {
        this._visitedGeometries.has(h) || this.getGeometry(t, h);
        const m = this._visitedGeometries.size, g = MathUtils.generateUUID();
        this._visitedGeometries.set(E, { uuid: g, index: m });
      }
      const u = this._visitedGeometries.get(E);
      if (u === void 0)
        throw new Error("Error getting geometry data for streaming!");
      const f = i.data.get(n);
      if (!f)
        throw new Error("Data not found!");
      f[0].push(u.index);
      const { x: T, y: R, z: C, w: A } = c.color, F = [T, R, C, A], p = c.flatTransformation;
      r.geometries.push({ color: F, geometryID: h, transformation: p });
    }
    this._assets.push(r);
  }
  getGeometry(t, e) {
    const i = t.GetGeometry(0, e), o = t.GetIndexArray(
      i.GetIndexData(),
      i.GetIndexDataSize()
    ), n = t.GetVertexArray(
      i.GetVertexData(),
      i.GetVertexDataSize()
    ), r = new Float32Array(n.length / 2), a = new Float32Array(n.length / 2);
    for (let u = 0; u < n.length; u += 6)
      r[u / 2] = n[u], r[u / 2 + 1] = n[u + 1], r[u / 2 + 2] = n[u + 2], a[u / 2] = n[u + 3], a[u / 2 + 1] = n[u + 4], a[u / 2 + 2] = n[u + 5];
    const c = mr(r), h = new Float32Array(c.transformation.elements), d = [c.center.x, c.center.y, c.center.z];
    let E = false;
    for (let u = 0; u < r.length - 2; u += 3) {
      const f = r[u], T = r[u + 1], R = r[u + 2], C = a[u], A = a[u + 1], F = a[u + 2];
      if (Rr(d, [f, T, R], [C, A, F])) {
        E = true;
        break;
      }
    }
    this._geometries.set(e, {
      position: r,
      normal: a,
      index: o,
      boundingBox: h,
      hasHoles: E
    }), i.delete(), this._geometryCount++;
  }
  async streamAssets() {
    await this.onAssetStreamed.trigger(this._assets), this._assets = null, this._assets = [];
  }
  async streamGeometries() {
    let t = this._streamSerializer.export(this._geometries), e = {};
    for (const [i, { boundingBox: o, hasHoles: n }] of this._geometries)
      e[i] = { boundingBox: o, hasHoles: n };
    this.onGeometryStreamed.trigger({ data: e, buffer: t }), e = null, t = null, this._geometries.clear(), this._geometryCount = 0;
  }
};
I(ws, "uuid", "d9999a00-e1f5-4d3f-8cfe-c56e08609764");
var _n = ws;
var Kr = class extends yi {
  constructor() {
    super(...arguments);
    I(this, "propertiesSize", 100);
  }
};
var $r = class extends et {
  constructor() {
    super(...arguments);
    I(this, "onPropertiesStreamed", new Ts());
    I(this, "onProgress", new Ts());
    I(this, "onIndicesStreamed", new Ts());
    I(this, "onDisposed", new D());
    I(this, "enabled", true);
    I(this, "settings", new Kr());
    I(this, "webIfc", new IfcAPI2());
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.onIndicesStreamed.reset(), this.onPropertiesStreamed.reset(), this.webIfc = null, this.onDisposed.reset();
  }
  /**
   * This method converts properties from an IFC file to tiles given its data as a Uint8Array.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   */
  async streamFromBuffer(t) {
    await this.readIfcFile(t), await this.streamAllProperties(), this.cleanUp();
  }
  /**
   * This method converts properties from an IFC file to tiles using a given callback function to read the file.
   *
   * @param loadCallback - A callback function that loads the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   */
  async streamFromCallBack(t) {
    await this.streamIfcFile(t), await this.streamAllProperties(), this.cleanUp();
  }
  async readIfcFile(t) {
    const { path: e, absolute: i, logLevel: o } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: e, absolute: i, logLevel: o } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllProperties() {
    const { propertiesSize: t } = this.settings, e = new Set(this.webIfc.GetIfcEntityList(0)), i = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const c of i)
      e.add(c);
    let o = 0.01, n = 0;
    for (const c of e) {
      if (n++, vn.has(c))
        continue;
      const h = i.has(c), d = this.webIfc.GetLineIDsWithType(0, c), E = d.size();
      let u = 0;
      for (let T = 0; T < E - t; T += t) {
        const R = {};
        for (let C = 0; C < t; C++) {
          u++;
          const A = d.get(T + C);
          try {
            const F = this.webIfc.GetLine(0, A, h);
            R[F.expressID] = F;
          } catch {
            console.log(`Could not get property: ${A}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: c, data: R });
      }
      if (u !== E) {
        const T = {};
        for (let R = u; R < E; R++) {
          const C = d.get(R);
          try {
            const A = this.webIfc.GetLine(0, C, h);
            T[A.expressID] = A;
          } catch {
            console.log(`Could not get property: ${C}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: c, data: T });
      }
      n / e.size > o && (o = Math.round(o * 100) / 100, await this.onProgress.trigger(o), o += 0.01);
    }
    await this.onProgress.trigger(1);
    const a = await this.components.get(pe).processFromWebIfc(this.webIfc, 0);
    await this.onIndicesStreamed.trigger(a);
  }
  cleanUp() {
    this.webIfc.Dispose(), this.webIfc = null, this.webIfc = new IfcAPI2();
  }
};
I($r, "uuid", "88d2c89c-ce32-47d7-8cb6-d51e4b311a0b");
var Ds = class Ds2 extends et {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    t.add(Ds2.uuid, this);
  }
  /**
   * Utility method to calculate the distance from a point to a line segment.
   *
   * @param point - The point from which to calculate the distance.
   * @param lineStart - The start point of the line segment.
   * @param lineEnd - The end point of the line segment.
   * @param clamp - If true, the distance will be clamped to the line segment's length.
   * @returns The distance from the point to the line segment.
   */
  static distanceFromPointToLine(t, e, i, o = false) {
    const n = new Line3(), r = new Vector3();
    return n.set(e, i), n.closestPointToPoint(t, o, r), r.distanceTo(t);
  }
  /**
   * Method to get the face of a mesh that contains a given triangle index.
   * It also returns the edges of the found face and their indices.
   *
   * @param mesh - The mesh to get the face from. It must be indexed.
   * @param triangleIndex - The index of the triangle within the mesh.
   * @param instance - The instance of the mesh (optional).
   * @returns An object containing the edges of the found face and their indices, or null if no face was found.
   */
  getFace(t, e, i) {
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const o = /* @__PURE__ */ new Map(), n = t.geometry.index.array, { plane: r } = this.getFaceData(
      e,
      i,
      t
    ), a = [];
    for (let E = 0; E < n.length / 3; E++) {
      const { plane: u, edges: f } = this.getFaceData(E, i, t);
      if (u.equals(r)) {
        a.push({ index: E, edges: f });
        for (const { id: T, points: R, distance: C } of f)
          o.set(T, { points: R, distance: C });
      }
    }
    let c = 0;
    const h = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map();
    for (const { index: E, edges: u } of a) {
      const f = /* @__PURE__ */ new Map();
      for (const { id: m } of u)
        if (h.has(m)) {
          const g = h.get(m);
          f.set(m, g);
        }
      const T = u.map((m) => m.id);
      if (!f.size) {
        const m = c++;
        for (const { id: g } of u)
          h.set(g, m);
        d.set(m, {
          edges: new Set(T),
          indices: /* @__PURE__ */ new Set([E])
        });
        continue;
      }
      let R = null;
      const C = /* @__PURE__ */ new Set(), A = new Set(T);
      for (const [m, g] of f) {
        R === null ? R = g : g !== R && C.add(g), h.delete(m);
        const { edges: S } = d.get(g);
        S.delete(m), A.delete(m);
      }
      if (R === null)
        throw new Error("Error computing face!");
      const F = d.get(R), { indices: p } = F;
      p.add(E);
      for (const m of A) {
        h.set(m, R);
        const { edges: g } = F;
        g.add(m);
      }
      for (const m of C) {
        const g = d.get(m), { edges: S, indices: _ } = g, N = d.get(R), { edges: y, indices: w } = N;
        for (const L of S)
          y.add(L), h.set(L, R);
        for (const L of _)
          w.add(L);
        d.delete(m);
      }
    }
    for (const [E, { indices: u, edges: f }] of d)
      if (u.has(e)) {
        const T = [];
        for (const R of f) {
          const C = o.get(R);
          T.push(C);
        }
        return { edges: T, indices: u };
      }
    return null;
  }
  /**
   * Method to get the vertices and normal of a mesh face at a given index.
   * It also applies instance transformation if provided.
   *
   * @param mesh - The mesh to get the face from. It must be indexed.
   * @param faceIndex - The index of the face within the mesh.
   * @param instance - The instance of the mesh (optional).
   * @returns An object containing the vertices and normal of the face.
   * @throws Will throw an error if the geometry is not indexed.
   */
  getVerticesAndNormal(t, e, i) {
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const o = t.geometry.index.array, n = t.geometry.attributes.position.array, r = t.geometry.attributes.normal.array, a = o[e * 3] * 3, c = o[e * 3 + 1] * 3, h = o[e * 3 + 2] * 3, d = new Vector3(n[a], n[a + 1], n[a + 2]), E = new Vector3(n[c], n[c + 1], n[c + 2]), u = new Vector3(n[h], n[h + 1], n[h + 2]), f = new Vector3(r[a], r[a + 1], r[a + 2]), T = new Vector3(r[c], r[c + 1], r[c + 2]), R = new Vector3(r[h], r[h + 1], r[h + 2]), C = (f.x + T.x + R.x) / 3, A = (f.y + T.y + R.y) / 3, F = (f.z + T.z + R.z) / 3, p = new Vector3(C, A, F);
    if (i !== void 0 && t instanceof InstancedMesh) {
      const m = new Matrix4();
      t.getMatrixAt(i, m);
      const g = new Matrix4();
      g.extractRotation(m), p.applyMatrix4(g), d.applyMatrix4(m), E.applyMatrix4(m), u.applyMatrix4(m);
    }
    return { p1: d, p2: E, p3: u, faceNormal: p };
  }
  /**
   * Method to round the vector's components to a specified number of decimal places.
   * This is used to ensure numerical precision in edge detection.
   *
   * @param vector - The vector to round.
   * @returns The vector with rounded components.
   */
  round(t) {
    t.x = Math.trunc(t.x * 1e3) / 1e3, t.y = Math.trunc(t.y * 1e3) / 1e3, t.z = Math.trunc(t.z * 1e3) / 1e3;
  }
  /**
   * Calculates the volume of a set of fragments.
   *
   * @param frags - A map of fragment IDs to their corresponding item IDs.
   * @returns The total volume of the fragments and the bounding sphere.
   *
   * @remarks
   * This method creates a set of instanced meshes from the given fragments and item IDs.
   * It then calculates the volume of each mesh and returns the total volume and its bounding sphere.
   *
   * @throws Will throw an error if the geometry of the meshes is not indexed.
   * @throws Will throw an error if the fragment manager is not available.
   */
  getVolumeFromFragments(t) {
    const e = this.components.get(ht), i = new Matrix4(), o = [];
    for (const r in t) {
      const a = e.list.get(r);
      if (!a)
        continue;
      const c = t[r];
      let h = 0;
      for (const u of c) {
        const f = a.getInstancesIDs(u);
        f && (h += f.size);
      }
      const d = new InstancedMesh(
        a.mesh.geometry,
        void 0,
        h
      );
      let E = 0;
      for (const u of c) {
        const f = a.getInstancesIDs(u);
        if (f)
          for (const T of f)
            a.mesh.getMatrixAt(T, i), d.setMatrixAt(E++, i);
      }
      o.push(d);
    }
    const n = this.getVolumeFromMeshes(o);
    for (const r of o)
      r.geometry = null, r.material = [], r.dispose();
    return n;
  }
  /**
   * Calculates the total volume of a set of meshes.
   *
   * @param meshes - An array of meshes or instanced meshes to calculate the volume from.
   * @returns The total volume of the meshes and the bounding sphere.
   *
   * @remarks
   * This method calculates the volume of each mesh in the provided array and returns the total volume
   * and its bounding sphere.
   *
   */
  getVolumeFromMeshes(t) {
    let e = 0;
    for (const i of t)
      e += this.getVolumeOfMesh(i);
    return e;
  }
  getFaceData(t, e, i) {
    const o = this.getVerticesAndNormal(i, t, e), { p1: n, p2: r, p3: a, faceNormal: c } = o;
    this.round(n), this.round(r), this.round(a), this.round(c);
    const h = [
      { id: `${n.x}|${n.y}|${n.z}`, value: n },
      { id: `${r.x}|${r.y}|${r.z}`, value: r },
      { id: `${a.x}|${a.y}|${a.z}`, value: a }
    ];
    h.sort((F, p) => F.id < p.id ? -1 : F.id > p.id ? 1 : 0);
    const [
      { id: d, value: E },
      { id: u, value: f },
      { id: T, value: R }
    ] = h, C = [
      {
        id: `${d}|${u}`,
        distance: E.distanceTo(f),
        points: [E, f]
      },
      {
        id: `${u}|${T}`,
        distance: f.distanceTo(R),
        points: [f, R]
      },
      {
        id: `${d}|${T}`,
        distance: E.distanceTo(R),
        points: [E, R]
      }
    ], A = new Plane();
    return A.setFromNormalAndCoplanarPoint(c, n), A.constant = Math.round(A.constant * 10) / 10, { plane: A, edges: C };
  }
  // https://stackoverflow.com/a/1568551
  getVolumeOfMesh(t) {
    let e = 0;
    const i = new Vector3(), o = new Vector3(), n = new Vector3(), { index: r } = t.geometry, a = t.geometry.attributes.position.array;
    if (!r)
      return console.warn("Geometry must be indexed to compute its volume!"), 0;
    const c = [];
    if (t instanceof InstancedMesh)
      for (let d = 0; d < t.count; d++) {
        const E = new Matrix4();
        t.getMatrixAt(d, E), c.push(E);
      }
    else
      c.push(new Matrix4().identity());
    const { matrixWorld: h } = t;
    for (let d = 0; d < r.array.length - 2; d += 3)
      for (const E of c) {
        const u = E.multiply(h), f = r.array[d] * 3, T = r.array[d + 1] * 3, R = r.array[d + 2] * 3;
        i.set(a[f], a[f + 1], a[f + 2]).applyMatrix4(u), o.set(a[T], a[T + 1], a[T + 2]).applyMatrix4(u), n.set(a[R], a[R + 1], a[R + 2]).applyMatrix4(u), e += this.getSignedVolumeOfTriangle(i, o, n);
      }
    return Math.abs(e);
  }
  getSignedVolumeOfTriangle(t, e, i) {
    const o = i.x * e.y * t.z, n = e.x * i.y * t.z, r = i.x * t.y * e.z, a = t.x * i.y * e.z, c = e.x * t.y * i.z, h = t.x * e.y * i.z;
    return 1 / 6 * (-o + n + r - a - c + h);
  }
};
I(Ds, "uuid", "267ca032-672f-4cb0-afa9-d24e904f39d6");
var Nn = Ds;

export {
  D,
  Ts,
  _i,
  et,
  Ni,
  cr,
  lr,
  zt,
  hr,
  mr,
  Rr,
  sn,
  ze,
  sa,
  pi,
  Ar,
  Fr,
  He,
  gr,
  ia,
  na,
  We,
  Ci,
  Pr,
  dn,
  Pi,
  Rn,
  Yr,
  Vr,
  Gr,
  Ti,
  zr,
  An,
  Hr,
  Wr,
  kr,
  Xr,
  oa,
  pe,
  ht,
  Fn,
  vn,
  mi,
  Qr,
  ra,
  Bn,
  Kt,
  yi,
  Ri,
  gn,
  Ai,
  On,
  Sn,
  qr,
  _n,
  Kr,
  $r,
  Nn
};
/*! Bundled license information:

@thatopen/components/dist/index.mjs:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=chunk-4YFKYMHQ.js.map
