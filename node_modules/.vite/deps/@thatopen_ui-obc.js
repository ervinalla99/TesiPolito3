import {
  Ai,
  Bn,
  Ci,
  Ri,
  Sn,
  dn,
  gn,
  gr,
  ht,
  ia,
  oa,
  pe
} from "./chunk-4YFKYMHQ.js";
import {
  Bf,
  Sa,
  Sc
} from "./chunk-32LXAOR2.js";
import {
  IFCCLASSIFICATIONREFERENCE,
  IFCELEMENTQUANTITY,
  IFCMATERIAL,
  IFCMATERIALLAYER,
  IFCMATERIALLAYERSET,
  IFCMATERIALLAYERSETUSAGE,
  IFCMATERIALLIST,
  IFCPROJECT,
  IFCPROPERTYSET,
  REF
} from "./chunk-HIYPURBP.js";
import {
  AmbientLight,
  BufferAttribute,
  BufferGeometry,
  Color,
  DirectionalLight,
  Frustum,
  Group,
  Light,
  LineBasicMaterial,
  LineSegments,
  Matrix4,
  Object3D,
  PerspectiveCamera,
  Vector2,
  Vector3
} from "./chunk-D5NTCM2J.js";
import "./chunk-4337NVKS.js";

// node_modules/@thatopen/ui-obc/dist/index.js
var po = Object.defineProperty;
var fo = (i, t, e) => t in i ? po(i, t, { enumerable: true, configurable: true, writable: true, value: e }) : i[t] = e;
var Ot = (i, t, e) => (fo(i, typeof t != "symbol" ? t + "" : t, e), e);
var qt = Math.min;
var rt = Math.max;
var ti = Math.round;
var vt = (i) => ({
  x: i,
  y: i
});
var mo = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var bo = {
  start: "end",
  end: "start"
};
function $n(i, t, e) {
  return rt(i, qt(t, e));
}
function Pe(i, t) {
  return typeof i == "function" ? i(t) : i;
}
function at(i) {
  return i.split("-")[0];
}
function di(i) {
  return i.split("-")[1];
}
function ws(i) {
  return i === "x" ? "y" : "x";
}
function $s(i) {
  return i === "y" ? "height" : "width";
}
function Mt(i) {
  return ["top", "bottom"].includes(at(i)) ? "y" : "x";
}
function Cs(i) {
  return ws(Mt(i));
}
function go(i, t, e) {
  e === void 0 && (e = false);
  const s = di(i), n = Cs(i), r = $s(n);
  let o = n === "x" ? s === (e ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
  return t.reference[r] > t.floating[r] && (o = ei(o)), [o, ei(o)];
}
function vo(i) {
  const t = ei(i);
  return [Hi(i), t, Hi(t)];
}
function Hi(i) {
  return i.replace(/start|end/g, (t) => bo[t]);
}
function yo(i, t, e) {
  const s = ["left", "right"], n = ["right", "left"], r = ["top", "bottom"], o = ["bottom", "top"];
  switch (i) {
    case "top":
    case "bottom":
      return e ? t ? n : s : t ? s : n;
    case "left":
    case "right":
      return t ? r : o;
    default:
      return [];
  }
}
function _o(i, t, e, s) {
  const n = di(i);
  let r = yo(at(i), e === "start", s);
  return n && (r = r.map((o) => o + "-" + n), t && (r = r.concat(r.map(Hi)))), r;
}
function ei(i) {
  return i.replace(/left|right|bottom|top/g, (t) => mo[t]);
}
function xo(i) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...i
  };
}
function Es(i) {
  return typeof i != "number" ? xo(i) : {
    top: i,
    right: i,
    bottom: i,
    left: i
  };
}
function Yt(i) {
  const {
    x: t,
    y: e,
    width: s,
    height: n
  } = i;
  return {
    width: s,
    height: n,
    top: e,
    left: t,
    right: t + s,
    bottom: e + n,
    x: t,
    y: e
  };
}
function Cn(i, t, e) {
  let {
    reference: s,
    floating: n
  } = i;
  const r = Mt(t), o = Cs(t), a = $s(o), l = at(t), u = r === "y", h = s.x + s.width / 2 - n.width / 2, d = s.y + s.height / 2 - n.height / 2, c = s[a] / 2 - n[a] / 2;
  let p;
  switch (l) {
    case "top":
      p = {
        x: h,
        y: s.y - n.height
      };
      break;
    case "bottom":
      p = {
        x: h,
        y: s.y + s.height
      };
      break;
    case "right":
      p = {
        x: s.x + s.width,
        y: d
      };
      break;
    case "left":
      p = {
        x: s.x - n.width,
        y: d
      };
      break;
    default:
      p = {
        x: s.x,
        y: s.y
      };
  }
  switch (di(t)) {
    case "start":
      p[o] -= c * (e && u ? -1 : 1);
      break;
    case "end":
      p[o] += c * (e && u ? -1 : 1);
      break;
  }
  return p;
}
var wo = async (i, t, e) => {
  const {
    placement: s = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o
  } = e, a = r.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let u = await o.getElementRects({
    reference: i,
    floating: t,
    strategy: n
  }), {
    x: h,
    y: d
  } = Cn(u, s, l), c = s, p = {}, v = 0;
  for (let x = 0; x < a.length; x++) {
    const {
      name: _,
      fn: w
    } = a[x], {
      x: f,
      y: b,
      data: g,
      reset: $
    } = await w({
      x: h,
      y: d,
      initialPlacement: s,
      placement: c,
      strategy: n,
      middlewareData: p,
      rects: u,
      platform: o,
      elements: {
        reference: i,
        floating: t
      }
    });
    h = f ?? h, d = b ?? d, p = {
      ...p,
      [_]: {
        ...p[_],
        ...g
      }
    }, $ && v <= 50 && (v++, typeof $ == "object" && ($.placement && (c = $.placement), $.rects && (u = $.rects === true ? await o.getElementRects({
      reference: i,
      floating: t,
      strategy: n
    }) : $.rects), {
      x: h,
      y: d
    } = Cn(u, c, l)), x = -1);
  }
  return {
    x: h,
    y: d,
    placement: c,
    strategy: n,
    middlewareData: p
  };
};
async function sn(i, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: s,
    y: n,
    platform: r,
    rects: o,
    elements: a,
    strategy: l
  } = i, {
    boundary: u = "clippingAncestors",
    rootBoundary: h = "viewport",
    elementContext: d = "floating",
    altBoundary: c = false,
    padding: p = 0
  } = Pe(t, i), v = Es(p), x = a[c ? d === "floating" ? "reference" : "floating" : d], _ = Yt(await r.getClippingRect({
    element: (e = await (r.isElement == null ? void 0 : r.isElement(x))) == null || e ? x : x.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(a.floating)),
    boundary: u,
    rootBoundary: h,
    strategy: l
  })), w = d === "floating" ? {
    x: s,
    y: n,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, f = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(a.floating)), b = await (r.isElement == null ? void 0 : r.isElement(f)) ? await (r.getScale == null ? void 0 : r.getScale(f)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, g = Yt(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: w,
    offsetParent: f,
    strategy: l
  }) : w);
  return {
    top: (_.top - g.top + v.top) / b.y,
    bottom: (g.bottom - _.bottom + v.bottom) / b.y,
    left: (_.left - g.left + v.left) / b.x,
    right: (g.right - _.right + v.right) / b.x
  };
}
var $o = function(i) {
  return i === void 0 && (i = {}), {
    name: "flip",
    options: i,
    async fn(t) {
      var e, s;
      const {
        placement: n,
        middlewareData: r,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: u
      } = t, {
        mainAxis: h = true,
        crossAxis: d = true,
        fallbackPlacements: c,
        fallbackStrategy: p = "bestFit",
        fallbackAxisSideDirection: v = "none",
        flipAlignment: x = true,
        ..._
      } = Pe(i, t);
      if ((e = r.arrow) != null && e.alignmentOffset)
        return {};
      const w = at(n), f = Mt(a), b = at(a) === a, g = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), $ = c || (b || !x ? [ei(a)] : vo(a)), C = v !== "none";
      !c && C && $.push(..._o(a, x, v, g));
      const A = [a, ...$], E = await sn(t, _), j = [];
      let O = ((s = r.flip) == null ? void 0 : s.overflows) || [];
      if (h && j.push(E[w]), d) {
        const U = go(n, o, g);
        j.push(E[U[0]], E[U[1]]);
      }
      if (O = [...O, {
        placement: n,
        overflows: j
      }], !j.every((U) => U <= 0)) {
        var Q, kt;
        const U = (((Q = r.flip) == null ? void 0 : Q.index) || 0) + 1, dt = A[U];
        if (dt)
          return {
            data: {
              index: U,
              overflows: O
            },
            reset: {
              placement: dt
            }
          };
        let H = (kt = O.filter((K) => K.overflows[0] <= 0).sort((K, q) => K.overflows[1] - q.overflows[1])[0]) == null ? void 0 : kt.placement;
        if (!H)
          switch (p) {
            case "bestFit": {
              var ht2;
              const K = (ht2 = O.filter((q) => {
                if (C) {
                  const et = Mt(q.placement);
                  return et === f || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  et === "y";
                }
                return true;
              }).map((q) => [q.placement, q.overflows.filter((et) => et > 0).reduce((et, Ei) => et + Ei, 0)]).sort((q, et) => q[1] - et[1])[0]) == null ? void 0 : ht2[0];
              K && (H = K);
              break;
            }
            case "initialPlacement":
              H = a;
              break;
          }
        if (n !== H)
          return {
            reset: {
              placement: H
            }
          };
      }
      return {};
    }
  };
};
function As(i) {
  const t = qt(...i.map((r) => r.left)), e = qt(...i.map((r) => r.top)), s = rt(...i.map((r) => r.right)), n = rt(...i.map((r) => r.bottom));
  return {
    x: t,
    y: e,
    width: s - t,
    height: n - e
  };
}
function Co(i) {
  const t = i.slice().sort((n, r) => n.y - r.y), e = [];
  let s = null;
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    !s || r.y - s.y > s.height / 2 ? e.push([r]) : e[e.length - 1].push(r), s = r;
  }
  return e.map((n) => Yt(As(n)));
}
var Eo = function(i) {
  return i === void 0 && (i = {}), {
    name: "inline",
    options: i,
    async fn(t) {
      const {
        placement: e,
        elements: s,
        rects: n,
        platform: r,
        strategy: o
      } = t, {
        padding: a = 2,
        x: l,
        y: u
      } = Pe(i, t), h = Array.from(await (r.getClientRects == null ? void 0 : r.getClientRects(s.reference)) || []), d = Co(h), c = Yt(As(h)), p = Es(a);
      function v() {
        if (d.length === 2 && d[0].left > d[1].right && l != null && u != null)
          return d.find((_) => l > _.left - p.left && l < _.right + p.right && u > _.top - p.top && u < _.bottom + p.bottom) || c;
        if (d.length >= 2) {
          if (Mt(e) === "y") {
            const O = d[0], Q = d[d.length - 1], kt = at(e) === "top", ht2 = O.top, U = Q.bottom, dt = kt ? O.left : Q.left, H = kt ? O.right : Q.right, K = H - dt, q = U - ht2;
            return {
              top: ht2,
              bottom: U,
              left: dt,
              right: H,
              width: K,
              height: q,
              x: dt,
              y: ht2
            };
          }
          const _ = at(e) === "left", w = rt(...d.map((O) => O.right)), f = qt(...d.map((O) => O.left)), b = d.filter((O) => _ ? O.left === f : O.right === w), g = b[0].top, $ = b[b.length - 1].bottom, C = f, A = w, E = A - C, j = $ - g;
          return {
            top: g,
            bottom: $,
            left: C,
            right: A,
            width: E,
            height: j,
            x: C,
            y: g
          };
        }
        return c;
      }
      const x = await r.getElementRects({
        reference: {
          getBoundingClientRect: v
        },
        floating: s.floating,
        strategy: o
      });
      return n.reference.x !== x.reference.x || n.reference.y !== x.reference.y || n.reference.width !== x.reference.width || n.reference.height !== x.reference.height ? {
        reset: {
          rects: x
        }
      } : {};
    }
  };
};
async function Ao(i, t) {
  const {
    placement: e,
    platform: s,
    elements: n
  } = i, r = await (s.isRTL == null ? void 0 : s.isRTL(n.floating)), o = at(e), a = di(e), l = Mt(e) === "y", u = ["left", "top"].includes(o) ? -1 : 1, h = r && l ? -1 : 1, d = Pe(t, i);
  let {
    mainAxis: c,
    crossAxis: p,
    alignmentAxis: v
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...d
  };
  return a && typeof v == "number" && (p = a === "end" ? v * -1 : v), l ? {
    x: p * h,
    y: c * u
  } : {
    x: c * u,
    y: p * h
  };
}
var Ss = function(i) {
  return {
    name: "offset",
    options: i,
    async fn(t) {
      var e, s;
      const {
        x: n,
        y: r,
        placement: o,
        middlewareData: a
      } = t, l = await Ao(t, i);
      return o === ((e = a.offset) == null ? void 0 : e.placement) && (s = a.arrow) != null && s.alignmentOffset ? {} : {
        x: n + l.x,
        y: r + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
};
var So = function(i) {
  return i === void 0 && (i = {}), {
    name: "shift",
    options: i,
    async fn(t) {
      const {
        x: e,
        y: s,
        placement: n
      } = t, {
        mainAxis: r = true,
        crossAxis: o = false,
        limiter: a = {
          fn: (_) => {
            let {
              x: w,
              y: f
            } = _;
            return {
              x: w,
              y: f
            };
          }
        },
        ...l
      } = Pe(i, t), u = {
        x: e,
        y: s
      }, h = await sn(t, l), d = Mt(at(n)), c = ws(d);
      let p = u[c], v = u[d];
      if (r) {
        const _ = c === "y" ? "top" : "left", w = c === "y" ? "bottom" : "right", f = p + h[_], b = p - h[w];
        p = $n(f, p, b);
      }
      if (o) {
        const _ = d === "y" ? "top" : "left", w = d === "y" ? "bottom" : "right", f = v + h[_], b = v - h[w];
        v = $n(f, v, b);
      }
      const x = a.fn({
        ...t,
        [c]: p,
        [d]: v
      });
      return {
        ...x,
        data: {
          x: x.x - e,
          y: x.y - s
        }
      };
    }
  };
};
function yt(i) {
  return ks(i) ? (i.nodeName || "").toLowerCase() : "#document";
}
function V(i) {
  var t;
  return (i == null || (t = i.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function wt(i) {
  var t;
  return (t = (ks(i) ? i.ownerDocument : i.document) || window.document) == null ? void 0 : t.documentElement;
}
function ks(i) {
  return i instanceof Node || i instanceof V(i).Node;
}
function lt(i) {
  return i instanceof Element || i instanceof V(i).Element;
}
function it(i) {
  return i instanceof HTMLElement || i instanceof V(i).HTMLElement;
}
function En(i) {
  return typeof ShadowRoot > "u" ? false : i instanceof ShadowRoot || i instanceof V(i).ShadowRoot;
}
function Re(i) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: s,
    display: n
  } = X(i);
  return /auto|scroll|overlay|hidden|clip/.test(t + s + e) && !["inline", "contents"].includes(n);
}
function ko(i) {
  return ["table", "td", "th"].includes(yt(i));
}
function Oo(i) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return i.matches(t);
    } catch {
      return false;
    }
  });
}
function rn(i) {
  const t = on(), e = X(i);
  return e.transform !== "none" || e.perspective !== "none" || (e.containerType ? e.containerType !== "normal" : false) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : false) || !t && (e.filter ? e.filter !== "none" : false) || ["transform", "perspective", "filter"].some((s) => (e.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some((s) => (e.contain || "").includes(s));
}
function To(i) {
  let t = Xt(i);
  for (; it(t) && !pi(t); ) {
    if (Oo(t))
      return null;
    if (rn(t))
      return t;
    t = Xt(t);
  }
  return null;
}
function on() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
function pi(i) {
  return ["html", "body", "#document"].includes(yt(i));
}
function X(i) {
  return V(i).getComputedStyle(i);
}
function fi(i) {
  return lt(i) ? {
    scrollLeft: i.scrollLeft,
    scrollTop: i.scrollTop
  } : {
    scrollLeft: i.pageXOffset,
    scrollTop: i.pageYOffset
  };
}
function Xt(i) {
  if (yt(i) === "html")
    return i;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    i.assignedSlot || // DOM Element detected.
    i.parentNode || // ShadowRoot detected.
    En(i) && i.host || // Fallback.
    wt(i)
  );
  return En(t) ? t.host : t;
}
function Os(i) {
  const t = Xt(i);
  return pi(t) ? i.ownerDocument ? i.ownerDocument.body : i.body : it(t) && Re(t) ? t : Os(t);
}
function Fi(i, t, e) {
  var s;
  t === void 0 && (t = []), e === void 0 && (e = true);
  const n = Os(i), r = n === ((s = i.ownerDocument) == null ? void 0 : s.body), o = V(n);
  return r ? t.concat(o, o.visualViewport || [], Re(n) ? n : [], o.frameElement && e ? Fi(o.frameElement) : []) : t.concat(n, Fi(n, [], e));
}
function Ts(i) {
  const t = X(i);
  let e = parseFloat(t.width) || 0, s = parseFloat(t.height) || 0;
  const n = it(i), r = n ? i.offsetWidth : e, o = n ? i.offsetHeight : s, a = ti(e) !== r || ti(s) !== o;
  return a && (e = r, s = o), {
    width: e,
    height: s,
    $: a
  };
}
function Is(i) {
  return lt(i) ? i : i.contextElement;
}
function Vt(i) {
  const t = Is(i);
  if (!it(t))
    return vt(1);
  const e = t.getBoundingClientRect(), {
    width: s,
    height: n,
    $: r
  } = Ts(t);
  let o = (r ? ti(e.width) : e.width) / s, a = (r ? ti(e.height) : e.height) / n;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
var Io = vt(0);
function Ps(i) {
  const t = V(i);
  return !on() || !t.visualViewport ? Io : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Po(i, t, e) {
  return t === void 0 && (t = false), !e || t && e !== V(i) ? false : t;
}
function we(i, t, e, s) {
  t === void 0 && (t = false), e === void 0 && (e = false);
  const n = i.getBoundingClientRect(), r = Is(i);
  let o = vt(1);
  t && (s ? lt(s) && (o = Vt(s)) : o = Vt(i));
  const a = Po(r, e, s) ? Ps(r) : vt(0);
  let l = (n.left + a.x) / o.x, u = (n.top + a.y) / o.y, h = n.width / o.x, d = n.height / o.y;
  if (r) {
    const c = V(r), p = s && lt(s) ? V(s) : s;
    let v = c, x = v.frameElement;
    for (; x && s && p !== v; ) {
      const _ = Vt(x), w = x.getBoundingClientRect(), f = X(x), b = w.left + (x.clientLeft + parseFloat(f.paddingLeft)) * _.x, g = w.top + (x.clientTop + parseFloat(f.paddingTop)) * _.y;
      l *= _.x, u *= _.y, h *= _.x, d *= _.y, l += b, u += g, v = V(x), x = v.frameElement;
    }
  }
  return Yt({
    width: h,
    height: d,
    x: l,
    y: u
  });
}
var Ro = [":popover-open", ":modal"];
function Rs(i) {
  return Ro.some((t) => {
    try {
      return i.matches(t);
    } catch {
      return false;
    }
  });
}
function No(i) {
  let {
    elements: t,
    rect: e,
    offsetParent: s,
    strategy: n
  } = i;
  const r = n === "fixed", o = wt(s), a = t ? Rs(t.floating) : false;
  if (s === o || a && r)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = vt(1);
  const h = vt(0), d = it(s);
  if ((d || !d && !r) && ((yt(s) !== "body" || Re(o)) && (l = fi(s)), it(s))) {
    const c = we(s);
    u = Vt(s), h.x = c.x + s.clientLeft, h.y = c.y + s.clientTop;
  }
  return {
    width: e.width * u.x,
    height: e.height * u.y,
    x: e.x * u.x - l.scrollLeft * u.x + h.x,
    y: e.y * u.y - l.scrollTop * u.y + h.y
  };
}
function Mo(i) {
  return Array.from(i.getClientRects());
}
function Ns(i) {
  return we(wt(i)).left + fi(i).scrollLeft;
}
function Lo(i) {
  const t = wt(i), e = fi(i), s = i.ownerDocument.body, n = rt(t.scrollWidth, t.clientWidth, s.scrollWidth, s.clientWidth), r = rt(t.scrollHeight, t.clientHeight, s.scrollHeight, s.clientHeight);
  let o = -e.scrollLeft + Ns(i);
  const a = -e.scrollTop;
  return X(s).direction === "rtl" && (o += rt(t.clientWidth, s.clientWidth) - n), {
    width: n,
    height: r,
    x: o,
    y: a
  };
}
function zo(i, t) {
  const e = V(i), s = wt(i), n = e.visualViewport;
  let r = s.clientWidth, o = s.clientHeight, a = 0, l = 0;
  if (n) {
    r = n.width, o = n.height;
    const u = on();
    (!u || u && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: r,
    height: o,
    x: a,
    y: l
  };
}
function Do(i, t) {
  const e = we(i, true, t === "fixed"), s = e.top + i.clientTop, n = e.left + i.clientLeft, r = it(i) ? Vt(i) : vt(1), o = i.clientWidth * r.x, a = i.clientHeight * r.y, l = n * r.x, u = s * r.y;
  return {
    width: o,
    height: a,
    x: l,
    y: u
  };
}
function An(i, t, e) {
  let s;
  if (t === "viewport")
    s = zo(i, e);
  else if (t === "document")
    s = Lo(wt(i));
  else if (lt(t))
    s = Do(t, e);
  else {
    const n = Ps(i);
    s = {
      ...t,
      x: t.x - n.x,
      y: t.y - n.y
    };
  }
  return Yt(s);
}
function Ms(i, t) {
  const e = Xt(i);
  return e === t || !lt(e) || pi(e) ? false : X(e).position === "fixed" || Ms(e, t);
}
function jo(i, t) {
  const e = t.get(i);
  if (e)
    return e;
  let s = Fi(i, [], false).filter((a) => lt(a) && yt(a) !== "body"), n = null;
  const r = X(i).position === "fixed";
  let o = r ? Xt(i) : i;
  for (; lt(o) && !pi(o); ) {
    const a = X(o), l = rn(o);
    !l && a.position === "fixed" && (n = null), (r ? !l && !n : !l && a.position === "static" && n && ["absolute", "fixed"].includes(n.position) || Re(o) && !l && Ms(i, o)) ? s = s.filter((u) => u !== o) : n = a, o = Xt(o);
  }
  return t.set(i, s), s;
}
function Ho(i) {
  let {
    element: t,
    boundary: e,
    rootBoundary: s,
    strategy: n
  } = i;
  const r = [...e === "clippingAncestors" ? jo(t, this._c) : [].concat(e), s], o = r[0], a = r.reduce((l, u) => {
    const h = An(t, u, n);
    return l.top = rt(h.top, l.top), l.right = qt(h.right, l.right), l.bottom = qt(h.bottom, l.bottom), l.left = rt(h.left, l.left), l;
  }, An(t, o, n));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function Fo(i) {
  const {
    width: t,
    height: e
  } = Ts(i);
  return {
    width: t,
    height: e
  };
}
function Bo(i, t, e) {
  const s = it(t), n = wt(t), r = e === "fixed", o = we(i, true, r, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = vt(0);
  if (s || !s && !r)
    if ((yt(t) !== "body" || Re(n)) && (a = fi(t)), s) {
      const d = we(t, true, r, t);
      l.x = d.x + t.clientLeft, l.y = d.y + t.clientTop;
    } else
      n && (l.x = Ns(n));
  const u = o.left + a.scrollLeft - l.x, h = o.top + a.scrollTop - l.y;
  return {
    x: u,
    y: h,
    width: o.width,
    height: o.height
  };
}
function Sn2(i, t) {
  return !it(i) || X(i).position === "fixed" ? null : t ? t(i) : i.offsetParent;
}
function Ls(i, t) {
  const e = V(i);
  if (!it(i) || Rs(i))
    return e;
  let s = Sn2(i, t);
  for (; s && ko(s) && X(s).position === "static"; )
    s = Sn2(s, t);
  return s && (yt(s) === "html" || yt(s) === "body" && X(s).position === "static" && !rn(s)) ? e : s || To(i) || e;
}
var Uo = async function(i) {
  const t = this.getOffsetParent || Ls, e = this.getDimensions;
  return {
    reference: Bo(i.reference, await t(i.floating), i.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await e(i.floating)
    }
  };
};
function Vo(i) {
  return X(i).direction === "rtl";
}
var Wo = {
  convertOffsetParentRelativeRectToViewportRelativeRect: No,
  getDocumentElement: wt,
  getClippingRect: Ho,
  getOffsetParent: Ls,
  getElementRects: Uo,
  getClientRects: Mo,
  getDimensions: Fo,
  getScale: Vt,
  isElement: lt,
  isRTL: Vo
};
var zs = So;
var Ds = $o;
var js = Eo;
var Hs = (i, t, e) => {
  const s = /* @__PURE__ */ new Map(), n = {
    platform: Wo,
    ...e
  }, r = {
    ...n.platform,
    _c: s
  };
  return wo(i, t, {
    ...n,
    platform: r
  });
};
var Je = globalThis;
var an = Je.ShadowRoot && (Je.ShadyCSS === void 0 || Je.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var ln = Symbol();
var kn = /* @__PURE__ */ new WeakMap();
var Fs = class {
  constructor(i, t, e) {
    if (this._$cssResult$ = true, e !== ln)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = i, this.t = t;
  }
  get styleSheet() {
    let i = this.o;
    const t = this.t;
    if (an && i === void 0) {
      const e = t !== void 0 && t.length === 1;
      e && (i = kn.get(t)), i === void 0 && ((this.o = i = new CSSStyleSheet()).replaceSync(this.cssText), e && kn.set(t, i));
    }
    return i;
  }
  toString() {
    return this.cssText;
  }
};
var Go = (i) => new Fs(typeof i == "string" ? i : i + "", void 0, ln);
var T = (i, ...t) => {
  const e = i.length === 1 ? i[0] : t.reduce((s, n, r) => s + ((o) => {
    if (o._$cssResult$ === true)
      return o.cssText;
    if (typeof o == "number")
      return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(n) + i[r + 1], i[0]);
  return new Fs(e, i, ln);
};
var qo = (i, t) => {
  if (an)
    i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else
    for (const e of t) {
      const s = document.createElement("style"), n = Je.litNonce;
      n !== void 0 && s.setAttribute("nonce", n), s.textContent = e.cssText, i.appendChild(s);
    }
};
var On = an ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const s of t.cssRules)
    e += s.cssText;
  return Go(e);
})(i) : i;
var { is: Yo, defineProperty: Xo, getOwnPropertyDescriptor: Jo, getOwnPropertyNames: Qo, getOwnPropertySymbols: Ko, getPrototypeOf: Zo } = Object;
var Jt = globalThis;
var Tn = Jt.trustedTypes;
var ta = Tn ? Tn.emptyScript : "";
var In = Jt.reactiveElementPolyfillSupport;
var be = (i, t) => i;
var ii = { toAttribute(i, t) {
  switch (t) {
    case Boolean:
      i = i ? ta : null;
      break;
    case Object:
    case Array:
      i = i == null ? i : JSON.stringify(i);
  }
  return i;
}, fromAttribute(i, t) {
  let e = i;
  switch (t) {
    case Boolean:
      e = i !== null;
      break;
    case Number:
      e = i === null ? null : Number(i);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(i);
      } catch {
        e = null;
      }
  }
  return e;
} };
var cn = (i, t) => !Yo(i, t);
var Pn = { attribute: true, type: String, converter: ii, reflect: false, hasChanged: cn };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), Jt.litPropertyMetadata ?? (Jt.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
var Bt = class extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = Pn) {
    if (e.state && (e.attribute = false), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {
      const s = Symbol(), n = this.getPropertyDescriptor(t, s, e);
      n !== void 0 && Xo(this.prototype, t, n);
    }
  }
  static getPropertyDescriptor(t, e, s) {
    const { get: n, set: r } = Jo(this.prototype, t) ?? { get() {
      return this[e];
    }, set(o) {
      this[e] = o;
    } };
    return { get() {
      return n == null ? void 0 : n.call(this);
    }, set(o) {
      const a = n == null ? void 0 : n.call(this);
      r.call(this, o), this.requestUpdate(t, a, s);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? Pn;
  }
  static _$Ei() {
    if (this.hasOwnProperty(be("elementProperties")))
      return;
    const t = Zo(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(be("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(be("properties"))) {
      const e = this.properties, s = [...Qo(e), ...Ko(e)];
      for (const n of s)
        this.createProperty(n, e[n]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0)
        for (const [s, n] of e)
          this.elementProperties.set(s, n);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, s] of this.elementProperties) {
      const n = this._$Eu(e, s);
      n !== void 0 && this._$Eh.set(n, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const s = new Set(t.flat(1 / 0).reverse());
      for (const n of s)
        e.unshift(On(n));
    } else
      t !== void 0 && e.push(On(t));
    return e;
  }
  static _$Eu(t, e) {
    const s = e.attribute;
    return s === false ? void 0 : typeof s == "string" ? s : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
  }
  addController(t) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$EO) == null || e.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const s of e.keys())
      this.hasOwnProperty(s) && (t.set(s, this[s]), delete this[s]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return qo(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t = this._$EO) == null || t.forEach((e) => {
      var s;
      return (s = e.hostConnected) == null ? void 0 : s.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var s;
      return (s = e.hostDisconnected) == null ? void 0 : s.call(e);
    });
  }
  attributeChangedCallback(t, e, s) {
    this._$AK(t, s);
  }
  _$EC(t, e) {
    var s;
    const n = this.constructor.elementProperties.get(t), r = this.constructor._$Eu(t, n);
    if (r !== void 0 && n.reflect === true) {
      const o = (((s = n.converter) == null ? void 0 : s.toAttribute) !== void 0 ? n.converter : ii).toAttribute(e, n.type);
      this._$Em = t, o == null ? this.removeAttribute(r) : this.setAttribute(r, o), this._$Em = null;
    }
  }
  _$AK(t, e) {
    var s;
    const n = this.constructor, r = n._$Eh.get(t);
    if (r !== void 0 && this._$Em !== r) {
      const o = n.getPropertyOptions(r), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((s = o.converter) == null ? void 0 : s.fromAttribute) !== void 0 ? o.converter : ii;
      this._$Em = r, this[r] = a.fromAttribute(e, o.type), this._$Em = null;
    }
  }
  requestUpdate(t, e, s) {
    if (t !== void 0) {
      if (s ?? (s = this.constructor.getPropertyOptions(t)), !(s.hasChanged ?? cn)(this[t], e))
        return;
      this.P(t, e, s);
    }
    this.isUpdatePending === false && (this._$ES = this._$ET());
  }
  P(t, e, s) {
    this._$AL.has(t) || this._$AL.set(t, e), s.reflect === true && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [r, o] of this._$Ep)
          this[r] = o;
        this._$Ep = void 0;
      }
      const n = this.constructor.elementProperties;
      if (n.size > 0)
        for (const [r, o] of n)
          o.wrapped !== true || this._$AL.has(r) || this[r] === void 0 || this.P(r, this[r], o);
    }
    let e = false;
    const s = this._$AL;
    try {
      e = this.shouldUpdate(s), e ? (this.willUpdate(s), (t = this._$EO) == null || t.forEach((n) => {
        var r;
        return (r = n.hostUpdate) == null ? void 0 : r.call(n);
      }), this.update(s)) : this._$EU();
    } catch (n) {
      throw e = false, this._$EU(), n;
    }
    e && this._$AE(s);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$EO) == null || e.forEach((s) => {
      var n;
      return (n = s.hostUpdated) == null ? void 0 : n.call(s);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t)), this.updated(t);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return true;
  }
  update(t) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
Bt.elementStyles = [], Bt.shadowRootOptions = { mode: "open" }, Bt[be("elementProperties")] = /* @__PURE__ */ new Map(), Bt[be("finalized")] = /* @__PURE__ */ new Map(), In == null || In({ ReactiveElement: Bt }), (Jt.reactiveElementVersions ?? (Jt.reactiveElementVersions = [])).push("2.0.4");
var ni = globalThis;
var si = ni.trustedTypes;
var Rn = si ? si.createPolicy("lit-html", { createHTML: (i) => i }) : void 0;
var Bs = "$lit$";
var mt = `lit$${Math.random().toFixed(9).slice(2)}$`;
var Us = "?" + mt;
var ea = `<${Us}>`;
var Lt = document;
var $e = () => Lt.createComment("");
var Ce = (i) => i === null || typeof i != "object" && typeof i != "function";
var Vs = Array.isArray;
var ia2 = (i) => Vs(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == "function";
var Ti = `[ 	
\f\r]`;
var pe2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var Nn = /-->/g;
var Mn = />/g;
var Tt = RegExp(`>|${Ti}(?:([^\\s"'>=/]+)(${Ti}*=${Ti}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var Ln = /'/g;
var zn = /"/g;
var Ws = /^(?:script|style|textarea|title)$/i;
var na = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e });
var y = na(1);
var Qt = Symbol.for("lit-noChange");
var M = Symbol.for("lit-nothing");
var Dn = /* @__PURE__ */ new WeakMap();
var Pt = Lt.createTreeWalker(Lt, 129);
function Gs(i, t) {
  if (!Array.isArray(i) || !i.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return Rn !== void 0 ? Rn.createHTML(t) : t;
}
var sa = (i, t) => {
  const e = i.length - 1, s = [];
  let n, r = t === 2 ? "<svg>" : "", o = pe2;
  for (let a = 0; a < e; a++) {
    const l = i[a];
    let u, h, d = -1, c = 0;
    for (; c < l.length && (o.lastIndex = c, h = o.exec(l), h !== null); )
      c = o.lastIndex, o === pe2 ? h[1] === "!--" ? o = Nn : h[1] !== void 0 ? o = Mn : h[2] !== void 0 ? (Ws.test(h[2]) && (n = RegExp("</" + h[2], "g")), o = Tt) : h[3] !== void 0 && (o = Tt) : o === Tt ? h[0] === ">" ? (o = n ?? pe2, d = -1) : h[1] === void 0 ? d = -2 : (d = o.lastIndex - h[2].length, u = h[1], o = h[3] === void 0 ? Tt : h[3] === '"' ? zn : Ln) : o === zn || o === Ln ? o = Tt : o === Nn || o === Mn ? o = pe2 : (o = Tt, n = void 0);
    const p = o === Tt && i[a + 1].startsWith("/>") ? " " : "";
    r += o === pe2 ? l + ea : d >= 0 ? (s.push(u), l.slice(0, d) + Bs + l.slice(d) + mt + p) : l + mt + (d === -2 ? a : p);
  }
  return [Gs(i, r + (i[e] || "<?>") + (t === 2 ? "</svg>" : "")), s];
};
var Ee = class _Ee {
  constructor({ strings: t, _$litType$: e }, s) {
    let n;
    this.parts = [];
    let r = 0, o = 0;
    const a = t.length - 1, l = this.parts, [u, h] = sa(t, e);
    if (this.el = _Ee.createElement(u, s), Pt.currentNode = this.el.content, e === 2) {
      const d = this.el.content.firstChild;
      d.replaceWith(...d.childNodes);
    }
    for (; (n = Pt.nextNode()) !== null && l.length < a; ) {
      if (n.nodeType === 1) {
        if (n.hasAttributes())
          for (const d of n.getAttributeNames())
            if (d.endsWith(Bs)) {
              const c = h[o++], p = n.getAttribute(d).split(mt), v = /([.?@])?(.*)/.exec(c);
              l.push({ type: 1, index: r, name: v[2], strings: p, ctor: v[1] === "." ? oa2 : v[1] === "?" ? aa : v[1] === "@" ? la : mi }), n.removeAttribute(d);
            } else
              d.startsWith(mt) && (l.push({ type: 6, index: r }), n.removeAttribute(d));
        if (Ws.test(n.tagName)) {
          const d = n.textContent.split(mt), c = d.length - 1;
          if (c > 0) {
            n.textContent = si ? si.emptyScript : "";
            for (let p = 0; p < c; p++)
              n.append(d[p], $e()), Pt.nextNode(), l.push({ type: 2, index: ++r });
            n.append(d[c], $e());
          }
        }
      } else if (n.nodeType === 8)
        if (n.data === Us)
          l.push({ type: 2, index: r });
        else {
          let d = -1;
          for (; (d = n.data.indexOf(mt, d + 1)) !== -1; )
            l.push({ type: 7, index: r }), d += mt.length - 1;
        }
      r++;
    }
  }
  static createElement(t, e) {
    const s = Lt.createElement("template");
    return s.innerHTML = t, s;
  }
};
function Kt(i, t, e = i, s) {
  var n, r;
  if (t === Qt)
    return t;
  let o = s !== void 0 ? (n = e._$Co) == null ? void 0 : n[s] : e._$Cl;
  const a = Ce(t) ? void 0 : t._$litDirective$;
  return (o == null ? void 0 : o.constructor) !== a && ((r = o == null ? void 0 : o._$AO) == null || r.call(o, false), a === void 0 ? o = void 0 : (o = new a(i), o._$AT(i, e, s)), s !== void 0 ? (e._$Co ?? (e._$Co = []))[s] = o : e._$Cl = o), o !== void 0 && (t = Kt(i, o._$AS(i, t.values), o, s)), t;
}
var ra = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: s } = this._$AD, n = ((t == null ? void 0 : t.creationScope) ?? Lt).importNode(e, true);
    Pt.currentNode = n;
    let r = Pt.nextNode(), o = 0, a = 0, l = s[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let u;
        l.type === 2 ? u = new Ne(r, r.nextSibling, this, t) : l.type === 1 ? u = new l.ctor(r, l.name, l.strings, this, t) : l.type === 6 && (u = new ca(r, this, t)), this._$AV.push(u), l = s[++a];
      }
      o !== (l == null ? void 0 : l.index) && (r = Pt.nextNode(), o++);
    }
    return Pt.currentNode = Lt, n;
  }
  p(t) {
    let e = 0;
    for (const s of this._$AV)
      s !== void 0 && (s.strings !== void 0 ? (s._$AI(t, s, e), e += s.strings.length - 2) : s._$AI(t[e])), e++;
  }
};
var Ne = class _Ne {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
  }
  constructor(t, e, s, n) {
    this.type = 2, this._$AH = M, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = s, this.options = n, this._$Cv = (n == null ? void 0 : n.isConnected) ?? true;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = Kt(this, t, e), Ce(t) ? t === M || t == null || t === "" ? (this._$AH !== M && this._$AR(), this._$AH = M) : t !== this._$AH && t !== Qt && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : ia2(t) ? this.k(t) : this._(t);
  }
  S(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.S(t));
  }
  _(t) {
    this._$AH !== M && Ce(this._$AH) ? this._$AA.nextSibling.data = t : this.T(Lt.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var e;
    const { values: s, _$litType$: n } = t, r = typeof n == "number" ? this._$AC(t) : (n.el === void 0 && (n.el = Ee.createElement(Gs(n.h, n.h[0]), this.options)), n);
    if (((e = this._$AH) == null ? void 0 : e._$AD) === r)
      this._$AH.p(s);
    else {
      const o = new ra(r, this), a = o.u(this.options);
      o.p(s), this.T(a), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = Dn.get(t.strings);
    return e === void 0 && Dn.set(t.strings, e = new Ee(t)), e;
  }
  k(t) {
    Vs(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let s, n = 0;
    for (const r of t)
      n === e.length ? e.push(s = new _Ne(this.S($e()), this.S($e()), this, this.options)) : s = e[n], s._$AI(r), n++;
    n < e.length && (this._$AR(s && s._$AB.nextSibling, n), e.length = n);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var s;
    for ((s = this._$AP) == null ? void 0 : s.call(this, false, true, e); t && t !== this._$AB; ) {
      const n = t.nextSibling;
      t.remove(), t = n;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));
  }
};
var mi = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, s, n, r) {
    this.type = 1, this._$AH = M, this._$AN = void 0, this.element = t, this.name = e, this._$AM = n, this.options = r, s.length > 2 || s[0] !== "" || s[1] !== "" ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = M;
  }
  _$AI(t, e = this, s, n) {
    const r = this.strings;
    let o = false;
    if (r === void 0)
      t = Kt(this, t, e, 0), o = !Ce(t) || t !== this._$AH && t !== Qt, o && (this._$AH = t);
    else {
      const a = t;
      let l, u;
      for (t = r[0], l = 0; l < r.length - 1; l++)
        u = Kt(this, a[s + l], e, l), u === Qt && (u = this._$AH[l]), o || (o = !Ce(u) || u !== this._$AH[l]), u === M ? t = M : t !== M && (t += (u ?? "") + r[l + 1]), this._$AH[l] = u;
    }
    o && !n && this.j(t);
  }
  j(t) {
    t === M ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
};
var oa2 = class extends mi {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === M ? void 0 : t;
  }
};
var aa = class extends mi {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== M);
  }
};
var la = class extends mi {
  constructor(t, e, s, n, r) {
    super(t, e, s, n, r), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = Kt(this, t, e, 0) ?? M) === Qt)
      return;
    const s = this._$AH, n = t === M && s !== M || t.capture !== s.capture || t.once !== s.once || t.passive !== s.passive, r = t !== M && (s === M || n);
    n && this.element.removeEventListener(this.name, this, s), r && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
};
var ca = class {
  constructor(t, e, s) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = s;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Kt(this, t);
  }
};
var jn = ni.litHtmlPolyfillSupport;
jn == null || jn(Ee, Ne), (ni.litHtmlVersions ?? (ni.litHtmlVersions = [])).push("3.1.4");
var Zt = (i, t, e) => {
  const s = (e == null ? void 0 : e.renderBefore) ?? t;
  let n = s._$litPart$;
  if (n === void 0) {
    const r = (e == null ? void 0 : e.renderBefore) ?? null;
    s._$litPart$ = n = new Ne(t.insertBefore($e(), r), r, void 0, e ?? {});
  }
  return n._$AI(i), n;
};
var k = class extends Bt {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t;
    const e = super.createRenderRoot();
    return (t = this.renderOptions).renderBefore ?? (t.renderBefore = e.firstChild), e;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = Zt(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(true);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(false);
  }
  render() {
    return Qt;
  }
};
var Hn;
k._$litElement$ = true, k.finalized = true, (Hn = globalThis.litElementHydrateSupport) == null || Hn.call(globalThis, { LitElement: k });
var Fn = globalThis.litElementPolyfillSupport;
Fn == null || Fn({ LitElement: k });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.6");
var ua = { attribute: true, type: String, converter: ii, reflect: false, hasChanged: cn };
var ha = (i = ua, t, e) => {
  const { kind: s, metadata: n } = e;
  let r = globalThis.litPropertyMetadata.get(n);
  if (r === void 0 && globalThis.litPropertyMetadata.set(n, r = /* @__PURE__ */ new Map()), r.set(e.name, i), s === "accessor") {
    const { name: o } = e;
    return { set(a) {
      const l = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(o, l, i);
    }, init(a) {
      return a !== void 0 && this.P(o, void 0, i), a;
    } };
  }
  if (s === "setter") {
    const { name: o } = e;
    return function(a) {
      const l = this[o];
      t.call(this, a), this.requestUpdate(o, l, i);
    };
  }
  throw Error("Unsupported decorator location: " + s);
};
function m(i) {
  return (t, e) => typeof e == "object" ? ha(i, t, e) : ((s, n, r) => {
    const o = n.hasOwnProperty(r);
    return n.constructor.createProperty(r, o ? { ...s, wrapped: true } : s), o ? Object.getOwnPropertyDescriptor(n, r) : void 0;
  })(i, t, e);
}
function Me(i) {
  return m({ ...i, state: true, attribute: false });
}
var da = (i) => i.strings === void 0;
var pa = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var fa = (i) => (...t) => ({ _$litDirective$: i, values: t });
var ma = class {
  constructor(i) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(i, t, e) {
    this._$Ct = i, this._$AM = t, this._$Ci = e;
  }
  _$AS(i, t) {
    return this.update(i, t);
  }
  update(i, t) {
    return this.render(...t);
  }
};
var ge = (i, t) => {
  var e;
  const s = i._$AN;
  if (s === void 0)
    return false;
  for (const n of s)
    (e = n._$AO) == null || e.call(n, t, false), ge(n, t);
  return true;
};
var ri = (i) => {
  let t, e;
  do {
    if ((t = i._$AM) === void 0)
      break;
    e = t._$AN, e.delete(i), i = t;
  } while ((e == null ? void 0 : e.size) === 0);
};
var qs = (i) => {
  for (let t; t = i._$AM; i = t) {
    let e = t._$AN;
    if (e === void 0)
      t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(i))
      break;
    e.add(i), va(t);
  }
};
function ba(i) {
  this._$AN !== void 0 ? (ri(this), this._$AM = i, qs(this)) : this._$AM = i;
}
function ga(i, t = false, e = 0) {
  const s = this._$AH, n = this._$AN;
  if (n !== void 0 && n.size !== 0)
    if (t)
      if (Array.isArray(s))
        for (let r = e; r < s.length; r++)
          ge(s[r], false), ri(s[r]);
      else
        s != null && (ge(s, false), ri(s));
    else
      ge(this, i);
}
var va = (i) => {
  i.type == pa.CHILD && (i._$AP ?? (i._$AP = ga), i._$AQ ?? (i._$AQ = ba));
};
var ya = class extends ma {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, s) {
    super._$AT(t, e, s), qs(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = true) {
    var s, n;
    t !== this.isConnected && (this.isConnected = t, t ? (s = this.reconnected) == null || s.call(this) : (n = this.disconnected) == null || n.call(this)), e && (ge(this, t), ri(this));
  }
  setValue(t) {
    if (da(this._$Ct))
      this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
var Wt = () => new _a();
var _a = class {
};
var Ii = /* @__PURE__ */ new WeakMap();
var ot = fa(class extends ya {
  render(i) {
    return M;
  }
  update(i, [t]) {
    var e;
    const s = t !== this.Y;
    return s && this.Y !== void 0 && this.rt(void 0), (s || this.lt !== this.ct) && (this.Y = t, this.ht = (e = i.options) == null ? void 0 : e.host, this.rt(this.ct = i.element)), M;
  }
  rt(i) {
    if (this.isConnected || (i = void 0), typeof this.Y == "function") {
      const t = this.ht ?? globalThis;
      let e = Ii.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), Ii.set(t, e)), e.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), e.set(this.Y, i), i !== void 0 && this.Y.call(this.ht, i);
    } else
      this.Y.value = i;
  }
  get lt() {
    var i, t;
    return typeof this.Y == "function" ? (i = Ii.get(this.ht ?? globalThis)) == null ? void 0 : i.get(this.Y) : (t = this.Y) == null ? void 0 : t.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
var Ys = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
var oi = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
var Le = Object.freeze({
  ...Ys,
  ...oi
});
var Bi = Object.freeze({
  ...Le,
  body: "",
  hidden: false
});
var xa = Object.freeze({
  width: null,
  height: null
});
var Xs = Object.freeze({
  // Dimensions
  ...xa,
  // Transformations
  ...oi
});
function wa(i, t = 0) {
  const e = i.replace(/^-?[0-9.]*/, "");
  function s(n) {
    for (; n < 0; )
      n += 4;
    return n % 4;
  }
  if (e === "") {
    const n = parseInt(i);
    return isNaN(n) ? 0 : s(n);
  } else if (e !== i) {
    let n = 0;
    switch (e) {
      case "%":
        n = 25;
        break;
      case "deg":
        n = 90;
    }
    if (n) {
      let r = parseFloat(i.slice(0, i.length - e.length));
      return isNaN(r) ? 0 : (r = r / n, r % 1 === 0 ? s(r) : 0);
    }
  }
  return t;
}
var $a = /[\s,]+/;
function Ca(i, t) {
  t.split($a).forEach((e) => {
    switch (e.trim()) {
      case "horizontal":
        i.hFlip = true;
        break;
      case "vertical":
        i.vFlip = true;
        break;
    }
  });
}
var Js = {
  ...Xs,
  preserveAspectRatio: ""
};
function Bn2(i) {
  const t = {
    ...Js
  }, e = (s, n) => i.getAttribute(s) || n;
  return t.width = e("width", null), t.height = e("height", null), t.rotate = wa(e("rotate", "")), Ca(t, e("flip", "")), t.preserveAspectRatio = e("preserveAspectRatio", e("preserveaspectratio", "")), t;
}
function Ea(i, t) {
  for (const e in Js)
    if (i[e] !== t[e])
      return true;
  return false;
}
var ve = /^[a-z0-9]+(-[a-z0-9]+)*$/;
var ze = (i, t, e, s = "") => {
  const n = i.split(":");
  if (i.slice(0, 1) === "@") {
    if (n.length < 2 || n.length > 3)
      return null;
    s = n.shift().slice(1);
  }
  if (n.length > 3 || !n.length)
    return null;
  if (n.length > 1) {
    const a = n.pop(), l = n.pop(), u = {
      // Allow provider without '@': "provider:prefix:name"
      provider: n.length > 0 ? n[0] : s,
      prefix: l,
      name: a
    };
    return t && !Qe(u) ? null : u;
  }
  const r = n[0], o = r.split("-");
  if (o.length > 1) {
    const a = {
      provider: s,
      prefix: o.shift(),
      name: o.join("-")
    };
    return t && !Qe(a) ? null : a;
  }
  if (e && s === "") {
    const a = {
      provider: s,
      prefix: "",
      name: r
    };
    return t && !Qe(a, e) ? null : a;
  }
  return null;
};
var Qe = (i, t) => i ? !!((i.provider === "" || i.provider.match(ve)) && (t && i.prefix === "" || i.prefix.match(ve)) && i.name.match(ve)) : false;
function Aa(i, t) {
  const e = {};
  !i.hFlip != !t.hFlip && (e.hFlip = true), !i.vFlip != !t.vFlip && (e.vFlip = true);
  const s = ((i.rotate || 0) + (t.rotate || 0)) % 4;
  return s && (e.rotate = s), e;
}
function Un(i, t) {
  const e = Aa(i, t);
  for (const s in Bi)
    s in oi ? s in i && !(s in e) && (e[s] = oi[s]) : s in t ? e[s] = t[s] : s in i && (e[s] = i[s]);
  return e;
}
function Sa2(i, t) {
  const e = i.icons, s = i.aliases || /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  function r(o) {
    if (e[o])
      return n[o] = [];
    if (!(o in n)) {
      n[o] = null;
      const a = s[o] && s[o].parent, l = a && r(a);
      l && (n[o] = [a].concat(l));
    }
    return n[o];
  }
  return Object.keys(e).concat(Object.keys(s)).forEach(r), n;
}
function ka(i, t, e) {
  const s = i.icons, n = i.aliases || /* @__PURE__ */ Object.create(null);
  let r = {};
  function o(a) {
    r = Un(
      s[a] || n[a],
      r
    );
  }
  return o(t), e.forEach(o), Un(i, r);
}
function Qs(i, t) {
  const e = [];
  if (typeof i != "object" || typeof i.icons != "object")
    return e;
  i.not_found instanceof Array && i.not_found.forEach((n) => {
    t(n, null), e.push(n);
  });
  const s = Sa2(i);
  for (const n in s) {
    const r = s[n];
    r && (t(n, ka(i, n, r)), e.push(n));
  }
  return e;
}
var Oa = {
  provider: "",
  aliases: {},
  not_found: {},
  ...Ys
};
function Pi(i, t) {
  for (const e in t)
    if (e in i && typeof i[e] != typeof t[e])
      return false;
  return true;
}
function Ks(i) {
  if (typeof i != "object" || i === null)
    return null;
  const t = i;
  if (typeof t.prefix != "string" || !i.icons || typeof i.icons != "object" || !Pi(i, Oa))
    return null;
  const e = t.icons;
  for (const n in e) {
    const r = e[n];
    if (!n.match(ve) || typeof r.body != "string" || !Pi(
      r,
      Bi
    ))
      return null;
  }
  const s = t.aliases || /* @__PURE__ */ Object.create(null);
  for (const n in s) {
    const r = s[n], o = r.parent;
    if (!n.match(ve) || typeof o != "string" || !e[o] && !s[o] || !Pi(
      r,
      Bi
    ))
      return null;
  }
  return t;
}
var ai = /* @__PURE__ */ Object.create(null);
function Ta(i, t) {
  return {
    provider: i,
    prefix: t,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function _t(i, t) {
  const e = ai[i] || (ai[i] = /* @__PURE__ */ Object.create(null));
  return e[t] || (e[t] = Ta(i, t));
}
function un(i, t) {
  return Ks(t) ? Qs(t, (e, s) => {
    s ? i.icons[e] = s : i.missing.add(e);
  }) : [];
}
function Ia(i, t, e) {
  try {
    if (typeof e.body == "string")
      return i.icons[t] = { ...e }, true;
  } catch {
  }
  return false;
}
function Pa(i, t) {
  let e = [];
  return (typeof i == "string" ? [i] : Object.keys(ai)).forEach((s) => {
    (typeof s == "string" && typeof t == "string" ? [t] : Object.keys(ai[s] || {})).forEach((n) => {
      const r = _t(s, n);
      e = e.concat(
        Object.keys(r.icons).map(
          (o) => (s !== "" ? "@" + s + ":" : "") + n + ":" + o
        )
      );
    });
  }), e;
}
var Ae = false;
function Zs(i) {
  return typeof i == "boolean" && (Ae = i), Ae;
}
function Se(i) {
  const t = typeof i == "string" ? ze(i, true, Ae) : i;
  if (t) {
    const e = _t(t.provider, t.prefix), s = t.name;
    return e.icons[s] || (e.missing.has(s) ? null : void 0);
  }
}
function tr(i, t) {
  const e = ze(i, true, Ae);
  if (!e)
    return false;
  const s = _t(e.provider, e.prefix);
  return Ia(s, e.name, t);
}
function Vn(i, t) {
  if (typeof i != "object")
    return false;
  if (typeof t != "string" && (t = i.provider || ""), Ae && !t && !i.prefix) {
    let n = false;
    return Ks(i) && (i.prefix = "", Qs(i, (r, o) => {
      o && tr(r, o) && (n = true);
    })), n;
  }
  const e = i.prefix;
  if (!Qe({
    provider: t,
    prefix: e,
    name: "a"
  }))
    return false;
  const s = _t(t, e);
  return !!un(s, i);
}
function Wn(i) {
  return !!Se(i);
}
function Ra(i) {
  const t = Se(i);
  return t ? {
    ...Le,
    ...t
  } : null;
}
function Na(i) {
  const t = {
    loaded: [],
    missing: [],
    pending: []
  }, e = /* @__PURE__ */ Object.create(null);
  i.sort((n, r) => n.provider !== r.provider ? n.provider.localeCompare(r.provider) : n.prefix !== r.prefix ? n.prefix.localeCompare(r.prefix) : n.name.localeCompare(r.name));
  let s = {
    provider: "",
    prefix: "",
    name: ""
  };
  return i.forEach((n) => {
    if (s.name === n.name && s.prefix === n.prefix && s.provider === n.provider)
      return;
    s = n;
    const r = n.provider, o = n.prefix, a = n.name, l = e[r] || (e[r] = /* @__PURE__ */ Object.create(null)), u = l[o] || (l[o] = _t(r, o));
    let h;
    a in u.icons ? h = t.loaded : o === "" || u.missing.has(a) ? h = t.missing : h = t.pending;
    const d = {
      provider: r,
      prefix: o,
      name: a
    };
    h.push(d);
  }), t;
}
function er(i, t) {
  i.forEach((e) => {
    const s = e.loaderCallbacks;
    s && (e.loaderCallbacks = s.filter((n) => n.id !== t));
  });
}
function Ma(i) {
  i.pendingCallbacksFlag || (i.pendingCallbacksFlag = true, setTimeout(() => {
    i.pendingCallbacksFlag = false;
    const t = i.loaderCallbacks ? i.loaderCallbacks.slice(0) : [];
    if (!t.length)
      return;
    let e = false;
    const s = i.provider, n = i.prefix;
    t.forEach((r) => {
      const o = r.icons, a = o.pending.length;
      o.pending = o.pending.filter((l) => {
        if (l.prefix !== n)
          return true;
        const u = l.name;
        if (i.icons[u])
          o.loaded.push({
            provider: s,
            prefix: n,
            name: u
          });
        else if (i.missing.has(u))
          o.missing.push({
            provider: s,
            prefix: n,
            name: u
          });
        else
          return e = true, true;
        return false;
      }), o.pending.length !== a && (e || er([i], r.id), r.callback(
        o.loaded.slice(0),
        o.missing.slice(0),
        o.pending.slice(0),
        r.abort
      ));
    });
  }));
}
var La = 0;
function za(i, t, e) {
  const s = La++, n = er.bind(null, e, s);
  if (!t.pending.length)
    return n;
  const r = {
    id: s,
    icons: t,
    callback: i,
    abort: n
  };
  return e.forEach((o) => {
    (o.loaderCallbacks || (o.loaderCallbacks = [])).push(r);
  }), n;
}
var Ui = /* @__PURE__ */ Object.create(null);
function Gn(i, t) {
  Ui[i] = t;
}
function Vi(i) {
  return Ui[i] || Ui[""];
}
function Da(i, t = true, e = false) {
  const s = [];
  return i.forEach((n) => {
    const r = typeof n == "string" ? ze(n, t, e) : n;
    r && s.push(r);
  }), s;
}
var ja = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function Ha(i, t, e, s) {
  const n = i.resources.length, r = i.random ? Math.floor(Math.random() * n) : i.index;
  let o;
  if (i.random) {
    let C = i.resources.slice(0);
    for (o = []; C.length > 1; ) {
      const A = Math.floor(Math.random() * C.length);
      o.push(C[A]), C = C.slice(0, A).concat(C.slice(A + 1));
    }
    o = o.concat(C);
  } else
    o = i.resources.slice(r).concat(i.resources.slice(0, r));
  const a = Date.now();
  let l = "pending", u = 0, h, d = null, c = [], p = [];
  typeof s == "function" && p.push(s);
  function v() {
    d && (clearTimeout(d), d = null);
  }
  function x() {
    l === "pending" && (l = "aborted"), v(), c.forEach((C) => {
      C.status === "pending" && (C.status = "aborted");
    }), c = [];
  }
  function _(C, A) {
    A && (p = []), typeof C == "function" && p.push(C);
  }
  function w() {
    return {
      startTime: a,
      payload: t,
      status: l,
      queriesSent: u,
      queriesPending: c.length,
      subscribe: _,
      abort: x
    };
  }
  function f() {
    l = "failed", p.forEach((C) => {
      C(void 0, h);
    });
  }
  function b() {
    c.forEach((C) => {
      C.status === "pending" && (C.status = "aborted");
    }), c = [];
  }
  function g(C, A, E) {
    const j = A !== "success";
    switch (c = c.filter((O) => O !== C), l) {
      case "pending":
        break;
      case "failed":
        if (j || !i.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (A === "abort") {
      h = E, f();
      return;
    }
    if (j) {
      h = E, c.length || (o.length ? $() : f());
      return;
    }
    if (v(), b(), !i.random) {
      const O = i.resources.indexOf(C.resource);
      O !== -1 && O !== i.index && (i.index = O);
    }
    l = "completed", p.forEach((O) => {
      O(E);
    });
  }
  function $() {
    if (l !== "pending")
      return;
    v();
    const C = o.shift();
    if (C === void 0) {
      if (c.length) {
        d = setTimeout(() => {
          v(), l === "pending" && (b(), f());
        }, i.timeout);
        return;
      }
      f();
      return;
    }
    const A = {
      status: "pending",
      resource: C,
      callback: (E, j) => {
        g(A, E, j);
      }
    };
    c.push(A), u++, d = setTimeout($, i.rotate), e(C, t, A.callback);
  }
  return setTimeout($), w;
}
function ir(i) {
  const t = {
    ...ja,
    ...i
  };
  let e = [];
  function s() {
    e = e.filter((o) => o().status === "pending");
  }
  function n(o, a, l) {
    const u = Ha(
      t,
      o,
      a,
      (h, d) => {
        s(), l && l(h, d);
      }
    );
    return e.push(u), u;
  }
  function r(o) {
    return e.find((a) => o(a)) || null;
  }
  return {
    query: n,
    find: r,
    setIndex: (o) => {
      t.index = o;
    },
    getIndex: () => t.index,
    cleanup: s
  };
}
function hn(i) {
  let t;
  if (typeof i.resources == "string")
    t = [i.resources];
  else if (t = i.resources, !(t instanceof Array) || !t.length)
    return null;
  return {
    // API hosts
    resources: t,
    // Root path
    path: i.path || "/",
    // URL length limit
    maxURL: i.maxURL || 500,
    // Timeout before next host is used.
    rotate: i.rotate || 750,
    // Timeout before failing query.
    timeout: i.timeout || 5e3,
    // Randomise default API end point.
    random: i.random === true,
    // Start index
    index: i.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: i.dataAfterTimeout !== false
  };
}
var bi = /* @__PURE__ */ Object.create(null);
var qe = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
var Wi = [];
for (; qe.length > 0; )
  qe.length === 1 || Math.random() > 0.5 ? Wi.push(qe.shift()) : Wi.push(qe.pop());
bi[""] = hn({
  resources: ["https://api.iconify.design"].concat(Wi)
});
function qn(i, t) {
  const e = hn(t);
  return e === null ? false : (bi[i] = e, true);
}
function gi(i) {
  return bi[i];
}
function Fa() {
  return Object.keys(bi);
}
function Yn() {
}
var Ri2 = /* @__PURE__ */ Object.create(null);
function Ba(i) {
  if (!Ri2[i]) {
    const t = gi(i);
    if (!t)
      return;
    const e = ir(t), s = {
      config: t,
      redundancy: e
    };
    Ri2[i] = s;
  }
  return Ri2[i];
}
function nr(i, t, e) {
  let s, n;
  if (typeof i == "string") {
    const r = Vi(i);
    if (!r)
      return e(void 0, 424), Yn;
    n = r.send;
    const o = Ba(i);
    o && (s = o.redundancy);
  } else {
    const r = hn(i);
    if (r) {
      s = ir(r);
      const o = i.resources ? i.resources[0] : "", a = Vi(o);
      a && (n = a.send);
    }
  }
  return !s || !n ? (e(void 0, 424), Yn) : s.query(t, n, e)().abort;
}
var Xn = "iconify2";
var ke = "iconify";
var sr = ke + "-count";
var Jn = ke + "-version";
var rr = 36e5;
var Ua = 168;
var Va = 50;
function Gi(i, t) {
  try {
    return i.getItem(t);
  } catch {
  }
}
function dn2(i, t, e) {
  try {
    return i.setItem(t, e), true;
  } catch {
  }
}
function Qn(i, t) {
  try {
    i.removeItem(t);
  } catch {
  }
}
function qi(i, t) {
  return dn2(i, sr, t.toString());
}
function Yi(i) {
  return parseInt(Gi(i, sr)) || 0;
}
var Nt = {
  local: true,
  session: true
};
var or = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
var pn = false;
function Wa(i) {
  pn = i;
}
var Ye = typeof window > "u" ? {} : window;
function ar(i) {
  const t = i + "Storage";
  try {
    if (Ye && Ye[t] && typeof Ye[t].length == "number")
      return Ye[t];
  } catch {
  }
  Nt[i] = false;
}
function lr(i, t) {
  const e = ar(i);
  if (!e)
    return;
  const s = Gi(e, Jn);
  if (s !== Xn) {
    if (s) {
      const a = Yi(e);
      for (let l = 0; l < a; l++)
        Qn(e, ke + l.toString());
    }
    dn2(e, Jn, Xn), qi(e, 0);
    return;
  }
  const n = Math.floor(Date.now() / rr) - Ua, r = (a) => {
    const l = ke + a.toString(), u = Gi(e, l);
    if (typeof u == "string") {
      try {
        const h = JSON.parse(u);
        if (typeof h == "object" && typeof h.cached == "number" && h.cached > n && typeof h.provider == "string" && typeof h.data == "object" && typeof h.data.prefix == "string" && // Valid item: run callback
        t(h, a))
          return true;
      } catch {
      }
      Qn(e, l);
    }
  };
  let o = Yi(e);
  for (let a = o - 1; a >= 0; a--)
    r(a) || (a === o - 1 ? (o--, qi(e, o)) : or[i].add(a));
}
function cr() {
  if (!pn) {
    Wa(true);
    for (const i in Nt)
      lr(i, (t) => {
        const e = t.data, s = t.provider, n = e.prefix, r = _t(
          s,
          n
        );
        if (!un(r, e).length)
          return false;
        const o = e.lastModified || -1;
        return r.lastModifiedCached = r.lastModifiedCached ? Math.min(r.lastModifiedCached, o) : o, true;
      });
  }
}
function Ga(i, t) {
  const e = i.lastModifiedCached;
  if (
    // Matches or newer
    e && e >= t
  )
    return e === t;
  if (i.lastModifiedCached = t, e)
    for (const s in Nt)
      lr(s, (n) => {
        const r = n.data;
        return n.provider !== i.provider || r.prefix !== i.prefix || r.lastModified === t;
      });
  return true;
}
function qa(i, t) {
  pn || cr();
  function e(s) {
    let n;
    if (!Nt[s] || !(n = ar(s)))
      return;
    const r = or[s];
    let o;
    if (r.size)
      r.delete(o = Array.from(r).shift());
    else if (o = Yi(n), o >= Va || !qi(n, o + 1))
      return;
    const a = {
      cached: Math.floor(Date.now() / rr),
      provider: i.provider,
      data: t
    };
    return dn2(
      n,
      ke + o.toString(),
      JSON.stringify(a)
    );
  }
  t.lastModified && !Ga(i, t.lastModified) || Object.keys(t.icons).length && (t.not_found && (t = Object.assign({}, t), delete t.not_found), e("local") || e("session"));
}
function Kn() {
}
function Ya(i) {
  i.iconsLoaderFlag || (i.iconsLoaderFlag = true, setTimeout(() => {
    i.iconsLoaderFlag = false, Ma(i);
  }));
}
function Xa(i, t) {
  i.iconsToLoad ? i.iconsToLoad = i.iconsToLoad.concat(t).sort() : i.iconsToLoad = t, i.iconsQueueFlag || (i.iconsQueueFlag = true, setTimeout(() => {
    i.iconsQueueFlag = false;
    const { provider: e, prefix: s } = i, n = i.iconsToLoad;
    delete i.iconsToLoad;
    let r;
    !n || !(r = Vi(e)) || r.prepare(e, s, n).forEach((o) => {
      nr(e, o, (a) => {
        if (typeof a != "object")
          o.icons.forEach((l) => {
            i.missing.add(l);
          });
        else
          try {
            const l = un(
              i,
              a
            );
            if (!l.length)
              return;
            const u = i.pendingIcons;
            u && l.forEach((h) => {
              u.delete(h);
            }), qa(i, a);
          } catch (l) {
            console.error(l);
          }
        Ya(i);
      });
    });
  }));
}
var fn = (i, t) => {
  const e = Da(i, true, Zs()), s = Na(e);
  if (!s.pending.length) {
    let l = true;
    return t && setTimeout(() => {
      l && t(
        s.loaded,
        s.missing,
        s.pending,
        Kn
      );
    }), () => {
      l = false;
    };
  }
  const n = /* @__PURE__ */ Object.create(null), r = [];
  let o, a;
  return s.pending.forEach((l) => {
    const { provider: u, prefix: h } = l;
    if (h === a && u === o)
      return;
    o = u, a = h, r.push(_t(u, h));
    const d = n[u] || (n[u] = /* @__PURE__ */ Object.create(null));
    d[h] || (d[h] = []);
  }), s.pending.forEach((l) => {
    const { provider: u, prefix: h, name: d } = l, c = _t(u, h), p = c.pendingIcons || (c.pendingIcons = /* @__PURE__ */ new Set());
    p.has(d) || (p.add(d), n[u][h].push(d));
  }), r.forEach((l) => {
    const { provider: u, prefix: h } = l;
    n[u][h].length && Xa(l, n[u][h]);
  }), t ? za(t, s, r) : Kn;
};
var Ja = (i) => new Promise((t, e) => {
  const s = typeof i == "string" ? ze(i, true) : i;
  if (!s) {
    e(i);
    return;
  }
  fn([s || i], (n) => {
    if (n.length && s) {
      const r = Se(s);
      if (r) {
        t({
          ...Le,
          ...r
        });
        return;
      }
    }
    e(i);
  });
});
function Qa(i) {
  try {
    const t = typeof i == "string" ? JSON.parse(i) : i;
    if (typeof t.body == "string")
      return {
        ...t
      };
  } catch {
  }
}
function Ka(i, t) {
  const e = typeof i == "string" ? ze(i, true, true) : null;
  if (!e) {
    const r = Qa(i);
    return {
      value: i,
      data: r
    };
  }
  const s = Se(e);
  if (s !== void 0 || !e.prefix)
    return {
      value: i,
      name: e,
      data: s
      // could be 'null' -> icon is missing
    };
  const n = fn([e], () => t(i, e, Se(e)));
  return {
    value: i,
    name: e,
    loading: n
  };
}
function Ni(i) {
  return i.hasAttribute("inline");
}
var ur = false;
try {
  ur = navigator.vendor.indexOf("Apple") === 0;
} catch {
}
function Za(i, t) {
  switch (t) {
    case "svg":
    case "bg":
    case "mask":
      return t;
  }
  return t !== "style" && (ur || i.indexOf("<a") === -1) ? "svg" : i.indexOf("currentColor") === -1 ? "bg" : "mask";
}
var tl = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var el = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function Xi(i, t, e) {
  if (t === 1)
    return i;
  if (e = e || 100, typeof i == "number")
    return Math.ceil(i * t * e) / e;
  if (typeof i != "string")
    return i;
  const s = i.split(tl);
  if (s === null || !s.length)
    return i;
  const n = [];
  let r = s.shift(), o = el.test(r);
  for (; ; ) {
    if (o) {
      const a = parseFloat(r);
      isNaN(a) ? n.push(r) : n.push(Math.ceil(a * t * e) / e);
    } else
      n.push(r);
    if (r = s.shift(), r === void 0)
      return n.join("");
    o = !o;
  }
}
function il(i, t = "defs") {
  let e = "";
  const s = i.indexOf("<" + t);
  for (; s >= 0; ) {
    const n = i.indexOf(">", s), r = i.indexOf("</" + t);
    if (n === -1 || r === -1)
      break;
    const o = i.indexOf(">", r);
    if (o === -1)
      break;
    e += i.slice(n + 1, r).trim(), i = i.slice(0, s).trim() + i.slice(o + 1);
  }
  return {
    defs: e,
    content: i
  };
}
function nl(i, t) {
  return i ? "<defs>" + i + "</defs>" + t : t;
}
function sl(i, t, e) {
  const s = il(i);
  return nl(s.defs, t + s.content + e);
}
var rl = (i) => i === "unset" || i === "undefined" || i === "none";
function hr(i, t) {
  const e = {
    ...Le,
    ...i
  }, s = {
    ...Xs,
    ...t
  }, n = {
    left: e.left,
    top: e.top,
    width: e.width,
    height: e.height
  };
  let r = e.body;
  [e, s].forEach((x) => {
    const _ = [], w = x.hFlip, f = x.vFlip;
    let b = x.rotate;
    w ? f ? b += 2 : (_.push(
      "translate(" + (n.width + n.left).toString() + " " + (0 - n.top).toString() + ")"
    ), _.push("scale(-1 1)"), n.top = n.left = 0) : f && (_.push(
      "translate(" + (0 - n.left).toString() + " " + (n.height + n.top).toString() + ")"
    ), _.push("scale(1 -1)"), n.top = n.left = 0);
    let g;
    switch (b < 0 && (b -= Math.floor(b / 4) * 4), b = b % 4, b) {
      case 1:
        g = n.height / 2 + n.top, _.unshift(
          "rotate(90 " + g.toString() + " " + g.toString() + ")"
        );
        break;
      case 2:
        _.unshift(
          "rotate(180 " + (n.width / 2 + n.left).toString() + " " + (n.height / 2 + n.top).toString() + ")"
        );
        break;
      case 3:
        g = n.width / 2 + n.left, _.unshift(
          "rotate(-90 " + g.toString() + " " + g.toString() + ")"
        );
        break;
    }
    b % 2 === 1 && (n.left !== n.top && (g = n.left, n.left = n.top, n.top = g), n.width !== n.height && (g = n.width, n.width = n.height, n.height = g)), _.length && (r = sl(
      r,
      '<g transform="' + _.join(" ") + '">',
      "</g>"
    ));
  });
  const o = s.width, a = s.height, l = n.width, u = n.height;
  let h, d;
  o === null ? (d = a === null ? "1em" : a === "auto" ? u : a, h = Xi(d, l / u)) : (h = o === "auto" ? l : o, d = a === null ? Xi(h, u / l) : a === "auto" ? u : a);
  const c = {}, p = (x, _) => {
    rl(_) || (c[x] = _.toString());
  };
  p("width", h), p("height", d);
  const v = [n.left, n.top, l, u];
  return c.viewBox = v.join(" "), {
    attributes: c,
    viewBox: v,
    body: r
  };
}
function mn(i, t) {
  let e = i.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const s in t)
    e += " " + s + '="' + t[s] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + e + ">" + i + "</svg>";
}
function ol(i) {
  return i.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function al(i) {
  return "data:image/svg+xml," + ol(i);
}
function dr(i) {
  return 'url("' + al(i) + '")';
}
var ll = () => {
  let i;
  try {
    if (i = fetch, typeof i == "function")
      return i;
  } catch {
  }
};
var li = ll();
function cl(i) {
  li = i;
}
function ul() {
  return li;
}
function hl(i, t) {
  const e = gi(i);
  if (!e)
    return 0;
  let s;
  if (!e.maxURL)
    s = 0;
  else {
    let n = 0;
    e.resources.forEach((o) => {
      n = Math.max(n, o.length);
    });
    const r = t + ".json?icons=";
    s = e.maxURL - n - e.path.length - r.length;
  }
  return s;
}
function dl(i) {
  return i === 404;
}
var pl = (i, t, e) => {
  const s = [], n = hl(i, t), r = "icons";
  let o = {
    type: r,
    provider: i,
    prefix: t,
    icons: []
  }, a = 0;
  return e.forEach((l, u) => {
    a += l.length + 1, a >= n && u > 0 && (s.push(o), o = {
      type: r,
      provider: i,
      prefix: t,
      icons: []
    }, a = l.length), o.icons.push(l);
  }), s.push(o), s;
};
function fl(i) {
  if (typeof i == "string") {
    const t = gi(i);
    if (t)
      return t.path;
  }
  return "/";
}
var ml = (i, t, e) => {
  if (!li) {
    e("abort", 424);
    return;
  }
  let s = fl(t.provider);
  switch (t.type) {
    case "icons": {
      const r = t.prefix, o = t.icons.join(","), a = new URLSearchParams({
        icons: o
      });
      s += r + ".json?" + a.toString();
      break;
    }
    case "custom": {
      const r = t.uri;
      s += r.slice(0, 1) === "/" ? r.slice(1) : r;
      break;
    }
    default:
      e("abort", 400);
      return;
  }
  let n = 503;
  li(i + s).then((r) => {
    const o = r.status;
    if (o !== 200) {
      setTimeout(() => {
        e(dl(o) ? "abort" : "next", o);
      });
      return;
    }
    return n = 501, r.json();
  }).then((r) => {
    if (typeof r != "object" || r === null) {
      setTimeout(() => {
        r === 404 ? e("abort", r) : e("next", n);
      });
      return;
    }
    setTimeout(() => {
      e("success", r);
    });
  }).catch(() => {
    e("next", n);
  });
};
var bl = {
  prepare: pl,
  send: ml
};
function Zn(i, t) {
  switch (i) {
    case "local":
    case "session":
      Nt[i] = t;
      break;
    case "all":
      for (const e in Nt)
        Nt[e] = t;
      break;
  }
}
var Mi = "data-style";
var pr = "";
function gl(i) {
  pr = i;
}
function ts(i, t) {
  let e = Array.from(i.childNodes).find((s) => s.hasAttribute && s.hasAttribute(Mi));
  e || (e = document.createElement("style"), e.setAttribute(Mi, Mi), i.appendChild(e)), e.textContent = ":host{display:inline-block;vertical-align:" + (t ? "-0.125em" : "0") + "}span,svg{display:block}" + pr;
}
function fr() {
  Gn("", bl), Zs(true);
  let i;
  try {
    i = window;
  } catch {
  }
  if (i) {
    if (cr(), i.IconifyPreload !== void 0) {
      const t = i.IconifyPreload, e = "Invalid IconifyPreload syntax.";
      typeof t == "object" && t !== null && (t instanceof Array ? t : [t]).forEach((s) => {
        try {
          (typeof s != "object" || s === null || s instanceof Array || // Check for 'icons' and 'prefix'
          typeof s.icons != "object" || typeof s.prefix != "string" || // Add icon set
          !Vn(s)) && console.error(e);
        } catch {
          console.error(e);
        }
      });
    }
    if (i.IconifyProviders !== void 0) {
      const t = i.IconifyProviders;
      if (typeof t == "object" && t !== null)
        for (const e in t) {
          const s = "IconifyProviders[" + e + "] is invalid.";
          try {
            const n = t[e];
            if (typeof n != "object" || !n || n.resources === void 0)
              continue;
            qn(e, n) || console.error(s);
          } catch {
            console.error(s);
          }
        }
    }
  }
  return {
    enableCache: (t) => Zn(t, true),
    disableCache: (t) => Zn(t, false),
    iconLoaded: Wn,
    iconExists: Wn,
    getIcon: Ra,
    listIcons: Pa,
    addIcon: tr,
    addCollection: Vn,
    calculateSize: Xi,
    buildIcon: hr,
    iconToHTML: mn,
    svgToURL: dr,
    loadIcons: fn,
    loadIcon: Ja,
    addAPIProvider: qn,
    appendCustomStyle: gl,
    _api: {
      getAPIConfig: gi,
      setAPIModule: Gn,
      sendAPIQuery: nr,
      setFetch: cl,
      getFetch: ul,
      listAPIProviders: Fa
    }
  };
}
var Ji = {
  "background-color": "currentColor"
};
var mr = {
  "background-color": "transparent"
};
var es = {
  image: "var(--svg)",
  repeat: "no-repeat",
  size: "100% 100%"
};
var is = {
  "-webkit-mask": Ji,
  mask: Ji,
  background: mr
};
for (const i in is) {
  const t = is[i];
  for (const e in es)
    t[i + "-" + e] = es[e];
}
function ns(i) {
  return i ? i + (i.match(/^[-0-9.]+$/) ? "px" : "") : "inherit";
}
function vl(i, t, e) {
  const s = document.createElement("span");
  let n = i.body;
  n.indexOf("<a") !== -1 && (n += "<!-- " + Date.now() + " -->");
  const r = i.attributes, o = mn(n, {
    ...r,
    width: t.width + "",
    height: t.height + ""
  }), a = dr(o), l = s.style, u = {
    "--svg": a,
    width: ns(r.width),
    height: ns(r.height),
    ...e ? Ji : mr
  };
  for (const h in u)
    l.setProperty(h, u[h]);
  return s;
}
var ye;
function yl() {
  try {
    ye = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (i) => i
    });
  } catch {
    ye = null;
  }
}
function _l(i) {
  return ye === void 0 && yl(), ye ? ye.createHTML(i) : i;
}
function xl(i) {
  const t = document.createElement("span"), e = i.attributes;
  let s = "";
  e.width || (s = "width: inherit;"), e.height || (s += "height: inherit;"), s && (e.style = s);
  const n = mn(i.body, e);
  return t.innerHTML = _l(n), t.firstChild;
}
function Qi(i) {
  return Array.from(i.childNodes).find((t) => {
    const e = t.tagName && t.tagName.toUpperCase();
    return e === "SPAN" || e === "SVG";
  });
}
function ss(i, t) {
  const e = t.icon.data, s = t.customisations, n = hr(e, s);
  s.preserveAspectRatio && (n.attributes.preserveAspectRatio = s.preserveAspectRatio);
  const r = t.renderedMode;
  let o;
  switch (r) {
    case "svg":
      o = xl(n);
      break;
    default:
      o = vl(n, {
        ...Le,
        ...e
      }, r === "mask");
  }
  const a = Qi(i);
  a ? o.tagName === "SPAN" && a.tagName === o.tagName ? a.setAttribute("style", o.getAttribute("style")) : i.replaceChild(o, a) : i.appendChild(o);
}
function rs(i, t, e) {
  const s = e && (e.rendered ? e : e.lastRender);
  return {
    rendered: false,
    inline: t,
    icon: i,
    lastRender: s
  };
}
function wl(i = "iconify-icon") {
  let t, e;
  try {
    t = window.customElements, e = window.HTMLElement;
  } catch {
    return;
  }
  if (!t || !e)
    return;
  const s = t.get(i);
  if (s)
    return s;
  const n = [
    // Icon
    "icon",
    // Mode
    "mode",
    "inline",
    "observe",
    // Customisations
    "width",
    "height",
    "rotate",
    "flip"
  ], r = class extends e {
    /**
     * Constructor
     */
    constructor() {
      super(), Ot(this, "_shadowRoot"), Ot(this, "_initialised", false), Ot(this, "_state"), Ot(this, "_checkQueued", false), Ot(this, "_connected", false), Ot(this, "_observer", null), Ot(this, "_visible", true);
      const a = this._shadowRoot = this.attachShadow({
        mode: "open"
      }), l = Ni(this);
      ts(a, l), this._state = rs({
        value: ""
      }, l), this._queueCheck();
    }
    /**
     * Connected to DOM
     */
    connectedCallback() {
      this._connected = true, this.startObserver();
    }
    /**
     * Disconnected from DOM
     */
    disconnectedCallback() {
      this._connected = false, this.stopObserver();
    }
    /**
     * Observed attributes
     */
    static get observedAttributes() {
      return n.slice(0);
    }
    /**
     * Observed properties that are different from attributes
     *
     * Experimental! Need to test with various frameworks that support it
     */
    /*
    static get properties() {
        return {
            inline: {
                type: Boolean,
                reflect: true,
            },
            // Not listing other attributes because they are strings or combination
            // of string and another type. Cannot have multiple types
        };
    }
    */
    /**
     * Attribute has changed
     */
    attributeChangedCallback(a) {
      switch (a) {
        case "inline": {
          const l = Ni(this), u = this._state;
          l !== u.inline && (u.inline = l, ts(this._shadowRoot, l));
          break;
        }
        case "observer": {
          this.observer ? this.startObserver() : this.stopObserver();
          break;
        }
        default:
          this._queueCheck();
      }
    }
    /**
     * Get/set icon
     */
    get icon() {
      const a = this.getAttribute("icon");
      if (a && a.slice(0, 1) === "{")
        try {
          return JSON.parse(a);
        } catch {
        }
      return a;
    }
    set icon(a) {
      typeof a == "object" && (a = JSON.stringify(a)), this.setAttribute("icon", a);
    }
    /**
     * Get/set inline
     */
    get inline() {
      return Ni(this);
    }
    set inline(a) {
      a ? this.setAttribute("inline", "true") : this.removeAttribute("inline");
    }
    /**
     * Get/set observer
     */
    get observer() {
      return this.hasAttribute("observer");
    }
    set observer(a) {
      a ? this.setAttribute("observer", "true") : this.removeAttribute("observer");
    }
    /**
     * Restart animation
     */
    restartAnimation() {
      const a = this._state;
      if (a.rendered) {
        const l = this._shadowRoot;
        if (a.renderedMode === "svg")
          try {
            l.lastChild.setCurrentTime(0);
            return;
          } catch {
          }
        ss(l, a);
      }
    }
    /**
     * Get status
     */
    get status() {
      const a = this._state;
      return a.rendered ? "rendered" : a.icon.data === null ? "failed" : "loading";
    }
    /**
     * Queue attributes re-check
     */
    _queueCheck() {
      this._checkQueued || (this._checkQueued = true, setTimeout(() => {
        this._check();
      }));
    }
    /**
     * Check for changes
     */
    _check() {
      if (!this._checkQueued)
        return;
      this._checkQueued = false;
      const a = this._state, l = this.getAttribute("icon");
      if (l !== a.icon.value) {
        this._iconChanged(l);
        return;
      }
      if (!a.rendered || !this._visible)
        return;
      const u = this.getAttribute("mode"), h = Bn2(this);
      (a.attrMode !== u || Ea(a.customisations, h) || !Qi(this._shadowRoot)) && this._renderIcon(a.icon, h, u);
    }
    /**
     * Icon value has changed
     */
    _iconChanged(a) {
      const l = Ka(a, (u, h, d) => {
        const c = this._state;
        if (c.rendered || this.getAttribute("icon") !== u)
          return;
        const p = {
          value: u,
          name: h,
          data: d
        };
        p.data ? this._gotIconData(p) : c.icon = p;
      });
      l.data ? this._gotIconData(l) : this._state = rs(l, this._state.inline, this._state);
    }
    /**
     * Force render icon on state change
     */
    _forceRender() {
      if (!this._visible) {
        const a = Qi(this._shadowRoot);
        a && this._shadowRoot.removeChild(a);
        return;
      }
      this._queueCheck();
    }
    /**
     * Got new icon data, icon is ready to (re)render
     */
    _gotIconData(a) {
      this._checkQueued = false, this._renderIcon(a, Bn2(this), this.getAttribute("mode"));
    }
    /**
     * Re-render based on icon data
     */
    _renderIcon(a, l, u) {
      const h = Za(a.data.body, u), d = this._state.inline;
      ss(this._shadowRoot, this._state = {
        rendered: true,
        icon: a,
        inline: d,
        customisations: l,
        attrMode: u,
        renderedMode: h
      });
    }
    /**
     * Start observer
     */
    startObserver() {
      if (!this._observer)
        try {
          this._observer = new IntersectionObserver((a) => {
            const l = a.some((u) => u.isIntersecting);
            l !== this._visible && (this._visible = l, this._forceRender());
          }), this._observer.observe(this);
        } catch {
          if (this._observer) {
            try {
              this._observer.disconnect();
            } catch {
            }
            this._observer = null;
          }
        }
    }
    /**
     * Stop observer
     */
    stopObserver() {
      this._observer && (this._observer.disconnect(), this._observer = null, this._visible = true, this._connected && this._forceRender());
    }
  };
  n.forEach((a) => {
    a in r.prototype || Object.defineProperty(r.prototype, a, {
      get: function() {
        return this.getAttribute(a);
      },
      set: function(l) {
        l !== null ? this.setAttribute(a, l) : this.removeAttribute(a);
      }
    });
  });
  const o = fr();
  for (const a in o)
    r[a] = r.prototype[a] = o[a];
  return t.define(i, r), r;
}
wl() || fr();
var $l = Object.defineProperty;
var nt = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && $l(t, e, n), n;
};
var Xe;
var tt = (Xe = class extends k {
  constructor() {
    super(), this.labelHidden = false, this.active = false, this.disabled = false, this.vertical = false, this.tooltipVisible = false, this._parent = Wt(), this._tooltip = Wt(), this._contextMenu = Wt(), this._mouseLeave = false, this.onWindowMouseUp = (i) => {
      const { value: t } = this._contextMenu;
      !this.contains(i.target) && t && (t.visible = false);
    }, this.mouseLeave = true, this.addEventListener("click", (i) => i.stopPropagation());
  }
  set mouseLeave(i) {
    this._mouseLeave = i, i && (this.tooltipVisible = false, clearTimeout(this.timeoutID));
  }
  get mouseLeave() {
    return this._mouseLeave;
  }
  computeTooltipPosition() {
    const { value: i } = this._parent, { value: t } = this._tooltip;
    i && t && Hs(i, t, {
      placement: "bottom",
      middleware: [Ss(10), js(), Ds(), zs({ padding: 5 })]
    }).then((e) => {
      const { x: s, y: n } = e;
      Object.assign(t.style, {
        left: `${s}px`,
        top: `${n}px`
      });
    });
  }
  onMouseEnter() {
    if (!(this.tooltipTitle || this.tooltipText))
      return;
    this.mouseLeave = false;
    const i = this.tooltipTime ?? 700;
    this.timeoutID = setTimeout(() => {
      this.mouseLeave || (this.computeTooltipPosition(), this.tooltipVisible = true);
    }, i);
  }
  onChildrenClick(i) {
    i.stopPropagation();
    const { value: t } = this._contextMenu;
    t && (t.visible = !t.visible);
  }
  onSlotChange(i) {
    const { value: t } = this._contextMenu, e = i.target.assignedElements();
    for (const s of e) {
      if (!(s instanceof Xe)) {
        s.remove(), console.warn(
          "Only bim-button is allowed inside bim-button. Child has been removed."
        );
        continue;
      }
      s.addEventListener("click", () => t == null ? void 0 : t.updatePosition());
    }
    this.requestUpdate();
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("mouseup", this.onWindowMouseUp);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("mouseup", this.onWindowMouseUp);
  }
  render() {
    const i = y`
      <div ${ot(this._tooltip)} class="tooltip">
        ${this.tooltipTitle ? y`<p style="text-wrap: nowrap;">
              <strong>${this.tooltipTitle}</strong>
            </p>` : null}
        ${this.tooltipText ? y`<p style="width: 9rem;">${this.tooltipText}</p>` : null}
      </div>
    `, t = this.children.length > 0;
    return y`
      <style>
        .button {
          border-radius: var(
            --bim-button--bdrs,
            ${t ? "var(--bim-ui_size-4xs) 0 0 var(--bim-ui_size-4xs)" : "var(--bim-ui_size-4xs)"}
          );
        }
        .children {
          border-radius: var(
            --bim-button--bdrs,
            ${t ? "0 var(--bim-ui_size-4xs) var(--bim-ui_size-4xs) 0" : "var(--bim-ui_size-4xs)"}
          );
        }
      </style>
      <div ${ot(this._parent)} class="parent">
        ${this.label || this.icon ? y`
              <div
                class="button"
                @mouseenter=${this.onMouseEnter}
                @mouseleave=${() => this.mouseLeave = true}
              >
                <bim-label
                  .icon=${this.icon}
                  .vertical=${this.vertical}
                  .labelHidden=${this.labelHidden}
                  >${this.label}</bim-label
                >
              </div>
            ` : null}
        ${this.tooltipTitle || this.tooltipText ? i : null}
        ${t ? y`
              <div class="children" @click=${this.onChildrenClick}>
                <bim-icon .icon=${"ic:round-plus"}></bim-icon>
              </div>
            ` : null}
        <bim-context-menu
          ${ot(this._contextMenu)}
          style="row-gap: var(--bim-ui_size-4xs)"
        >
          <slot @slotchange=${this.onSlotChange}></slot>
        </bim-context-menu>
      </div>
    `;
  }
}, Xe.styles = T`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100, white);
      display: block;
      flex: 1;
      pointer-events: none;
      background-color: var(--bim-button--bgc, var(--bim-ui_bg-contrast-20));
      border-radius: var(--bim-ui_size-4xs);
    }

    :host(:not([disabled]):hover) {
      cursor: pointer;
    }

    bim-label {
      pointer-events: none;
    }

    .parent {
      --bim-icon--c: var(--bim-label--c);
      display: flex;
      height: 100%;
      user-select: none;
      row-gap: 0.125rem;
      min-height: var(--bim-ui_size-5xl);
      min-width: var(--bim-ui_size-5xl);
    }

    .button,
    .children {
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }

    .children {
      padding: 0 0.375rem;
    }

    :host(:not([label-hidden])[icon][vertical]) .parent {
      min-height: 2.5rem;
    }

    .button {
      flex-grow: 1;
    }

    :host(:not([label-hidden])[label]) .button {
      justify-content: var(--bim-button--jc, center);
    }

    :host(:hover),
    :host([active]) {
      --bim-label--c: var(--bim-ui_main-contrast);
      background-color: var(--bim-ui_main-base);
    }

    :host(:not([label]):not([icon])) .children {
      flex: 1;
    }

    :host([vertical]) .parent {
      justify-content: center;
    }

    :host(:not([label-hidden])[label]) .button {
      padding: 0 0.5rem;
    }

    :host([disabled]) .parent {
      background-color: gray;
    }

    ::slotted(bim-button) {
      --bim-icon--fz: var(--bim-ui_size-base);
      --bim-button--bdrs: var(--bim-ui_size-4xs);
      --bim-button--olw: 0;
      --bim-button--olc: transparent;
    }

    .tooltip {
      position: absolute;
      padding: 0.75rem;
      z-index: 99;
      display: flex;
      flex-flow: column;
      row-gap: 0.375rem;
      box-shadow: 0 0 10px 3px rgba(0 0 0 / 20%);
      outline: 1px solid var(--bim-ui_bg-contrast-40);
      font-size: var(--bim-ui_size-xs);
      border-radius: var(--bim-ui_size-4xs);
      background-color: var(--bim-ui_bg-contrast-20);
      color: var(--bim-ui_bg-contrast-100);
    }

    .tooltip p {
      margin: 0;
      padding: 0;
    }

    :host(:not([tooltip-visible])) .tooltip {
      display: none;
    }
  `, Xe);
nt([
  m({ type: String, reflect: true })
], tt.prototype, "label");
nt([
  m({ type: Boolean, attribute: "label-hidden", reflect: true })
], tt.prototype, "labelHidden");
nt([
  m({ type: Boolean, reflect: true })
], tt.prototype, "active");
nt([
  m({ type: Boolean, reflect: true, attribute: "disabled" })
], tt.prototype, "disabled");
nt([
  m({ type: String, reflect: true })
], tt.prototype, "icon");
nt([
  m({ type: Boolean, reflect: true })
], tt.prototype, "vertical");
nt([
  m({ type: Number, attribute: "tooltip-time", reflect: true })
], tt.prototype, "tooltipTime");
nt([
  m({ type: Boolean, attribute: "tooltip-visible", reflect: true })
], tt.prototype, "tooltipVisible");
nt([
  m({ type: String, attribute: "tooltip-title", reflect: true })
], tt.prototype, "tooltipTitle");
nt([
  m({ type: String, attribute: "tooltip-text", reflect: true })
], tt.prototype, "tooltipText");
var Cl = tt;
var El = Object.defineProperty;
var De = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && El(t, e, n), n;
};
var br = class extends k {
  constructor() {
    super(...arguments), this.checked = false, this.inverted = false, this.onValueChange = new Event("change");
  }
  /**
   * A getter that returns the current checked state of the checkbox. This is useful for retrieving the checkbox's value in form submissions or JavaScript interactions as it provides a consistent `value` property as many other components.
   * @type {boolean}
   * @default false
   * @example <script>console.log(document.querySelector('bim-checkbox').value);<\/script>
   * @example
   * const checkbox = document.createElement('bim-checkbox');
   * document.body.appendChild(checkbox);
   * console.log(checkbox.value); // false initially
   */
  get value() {
    return this.checked;
  }
  onChange(t) {
    t.stopPropagation(), this.checked = t.target.checked, this.dispatchEvent(this.onValueChange);
  }
  render() {
    return y`
      <div class="parent">
        ${this.label ? y`<bim-label .icon="${this.icon}">${this.label}</bim-label> ` : null}
        <input
          type="checkbox"
          aria-label=${this.label || this.name || "Checkbox Input"}
          @change="${this.onChange}"
          .checked="${this.checked}"
        />
      </div>
    `;
  }
};
br.styles = T`
    :host {
      display: block;
    }

    .parent {
      display: flex;
      justify-content: space-between;
      height: 1.75rem;
      column-gap: 0.5rem;
      width: 100%;
      align-items: center;
    }

    :host([inverted]) .parent {
      flex-direction: row-reverse;
      justify-content: start;
    }

    input {
      height: 1rem;
      width: 1rem;
      cursor: pointer;
      border: none;
      outline: none;
      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));
    }

    input:focus {
      outline: var(--bim-checkbox--olw, 2px) solid
        var(--bim-checkbox--olc, var(--bim-ui_accent-base));
    }
  `;
var ie = br;
De([
  m({ type: String, reflect: true })
], ie.prototype, "icon");
De([
  m({ type: String, reflect: true })
], ie.prototype, "name");
De([
  m({ type: String, reflect: true })
], ie.prototype, "label");
De([
  m({ type: Boolean, reflect: true })
], ie.prototype, "checked");
De([
  m({ type: Boolean, reflect: true })
], ie.prototype, "inverted");
var Al = Object.defineProperty;
var ne = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Al(t, e, n), n;
};
var gr2 = class extends k {
  constructor() {
    super(...arguments), this.vertical = false, this.color = "#bcf124", this._colorInput = Wt(), this._textInput = Wt(), this.onValueChange = new Event("input"), this.onOpacityInput = (t) => {
      const e = t.target;
      this.opacity = e.value, this.dispatchEvent(this.onValueChange);
    };
  }
  /**
   * Represents both the color and opacity values combined into a single object. This is an instance property, not an HTMLElement attribute.
   * @type {Object}
   * @example
   * const colorInput = document.createElement('bim-color-input');
   * colorInput.value = { color: '#ff0000', opacity: 0.5 };
   */
  set value(t) {
    const { color: e, opacity: s } = t;
    this.color = e, s && (this.opacity = s);
  }
  get value() {
    const t = {
      color: this.color
    };
    return this.opacity && (t.opacity = this.opacity), t;
  }
  onColorInput(t) {
    t.stopPropagation();
    const { value: e } = this._colorInput;
    e && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  onTextInput(t) {
    t.stopPropagation();
    const { value: e } = this._textInput;
    if (!e)
      return;
    const { value: s } = e;
    let n = s.replace(/[^a-fA-F0-9]/g, "");
    n.startsWith("#") || (n = `#${n}`), e.value = n.slice(0, 7), e.value.length === 7 && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  /**
   * Focuses on the color input by programmatically triggering a click event on the underlying color input element.
   * If the color input element is not available, the function does nothing.
   */
  focus() {
    const { value: t } = this._colorInput;
    t && t.click();
  }
  render() {
    return y`
      <div class="parent">
        <bim-input
          .label=${this.label}
          .icon=${this.icon}
          .vertical="${this.vertical}"
        >
          <div class="color-container">
            <div
              style="display: flex; align-items: center; gap: .375rem; height: 100%; flex: 1; padding: 0 0.5rem;"
            >
              <input
                ${ot(this._colorInput)}
                @input="${this.onColorInput}"
                type="color"
                aria-label=${this.label || this.name || "Color Input"}
                value="${this.color}"
              />
              <div
                @click=${this.focus}
                class="sample"
                style="background-color: ${this.color}"
              ></div>
              <input
                ${ot(this._textInput)}
                @input="${this.onTextInput}"
                value="${this.color}"
                type="text"
                aria-label=${this.label || this.name || "Text Color Input"}
              />
            </div>
            ${this.opacity !== void 0 ? y`<bim-number-input
                  @change=${this.onOpacityInput}
                  slider
                  suffix="%"
                  min="0"
                  value=${this.opacity}
                  max="100"
                ></bim-number-input>` : null}
          </div>
        </bim-input>
      </div>
    `;
  }
};
gr2.styles = T`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-ui_accent-base);
    }

    .parent {
      display: flex;
      gap: 0.375rem;
    }

    .color-container {
      position: relative;
      outline: none;
      display: flex;
      height: 100%;
      gap: 0.5rem;
      justify-content: flex-start;
      align-items: center;
      flex: 1;
      border-radius: var(--bim-color-input--bdrs, var(--bim-ui_size-4xs));
    }

    .color-container input[type="color"] {
      position: absolute;
      bottom: -0.25rem;
      visibility: hidden;
      width: 0;
      height: 0;
    }

    .color-container .sample {
      width: 1rem;
      height: 1rem;
      border-radius: 0.125rem;
      background-color: #fff;
    }

    .color-container input[type="text"] {
      height: 100%;
      flex: 1;
      width: 3.25rem;
      text-transform: uppercase;
      font-size: 0.75rem;
      background-color: transparent;
      padding: 0%;
      outline: none;
      border: none;
      color: var(--bim-color-input--c, var(--bim-ui_bg-contrast-100));
    }

    bim-number-input {
      flex-grow: 0;
    }
  `;
var Dt = gr2;
ne([
  m({ type: String, reflect: true })
], Dt.prototype, "name");
ne([
  m({ type: String, reflect: true })
], Dt.prototype, "label");
ne([
  m({ type: String, reflect: true })
], Dt.prototype, "icon");
ne([
  m({ type: Boolean, reflect: true })
], Dt.prototype, "vertical");
ne([
  m({ type: Number, reflect: true })
], Dt.prototype, "opacity");
ne([
  m({ type: String, reflect: true })
], Dt.prototype, "color");
var Sl = T`
  ::-webkit-scrollbar {
    width: 0.4rem;
    height: 0.4rem;
    overflow: hidden;
  }

  ::-webkit-scrollbar-thumb {
    border-radius: 0.25rem;
    background-color: var(
      --bim-scrollbar--c,
      color-mix(in lab, var(--bim-ui_main-base), white 15%)
    );
  }

  ::-webkit-scrollbar-track {
    background-color: var(--bim-scrollbar--bgc, var(--bim-ui_bg-base));
  }
`;
var kl = T`
  :root {
    /* Grayscale Colors */
    --bim-ui_gray-0: hsl(210 10% 5%);
    --bim-ui_gray-1: hsl(210 10% 10%);
    --bim-ui_gray-2: hsl(210 10% 20%);
    --bim-ui_gray-4: hsl(210 10% 40%);
    --bim-ui_gray-6: hsl(210 10% 60%);
    --bim-ui_gray-8: hsl(210 10% 80%);
    --bim-ui_gray-9: hsl(210 10% 90%);
    --bim-ui_gray-10: hsl(210 10% 95%);

    /* Brand Colors */
    --bim-ui_main-base: #6528d7;
    --bim-ui_accent-base: #bcf124;

    /* Brand Colors Contrasts */
    --bim-ui_main-contrast: var(--bim-ui_gray-10);
    --bim-ui_accent-contrast: var(--bim-ui_gray-0);

    /* Sizes */
    --bim-ui_size-4xs: 0.375rem;
    --bim-ui_size-3xs: 0.5rem;
    --bim-ui_size-2xs: 0.625rem;
    --bim-ui_size-xs: 0.75rem;
    --bim-ui_size-sm: 0.875rem;
    --bim-ui_size-base: 1rem;
    --bim-ui_size-lg: 1.125rem;
    --bim-ui_size-xl: 1.25rem;
    --bim-ui_size-2xl: 1.375rem;
    --bim-ui_size-3xl: 1.5rem;
    --bim-ui_size-4xl: 1.625rem;
    --bim-ui_size-5xl: 1.75rem;
    --bim-ui_size-6xl: 1.875rem;
    --bim-ui_size-7xl: 2rem;
    --bim-ui_size-8xl: 2.125rem;
    --bim-ui_size-9xl: 2.25rem;
  }

  /* Background Colors */
  @media (prefers-color-scheme: dark) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-0);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
    }
  }

  @media (prefers-color-scheme: light) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-10);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
      --bim-ui_accent-base: #6528d7;
    }
  }

  html.bim-ui-dark {
    --bim-ui_bg-base: var(--bim-ui_gray-0);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
  }

  html.bim-ui-light {
    --bim-ui_bg-base: var(--bim-ui_gray-10);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
    --bim-ui_accent-base: #6528d7;
  }
`;
var jt = {
  scrollbar: Sl,
  globalStyles: kl
};
var Ol = Object.defineProperty;
var Tl = Object.getOwnPropertyDescriptor;
var Il = (i, t, e, s) => {
  for (var n = Tl(t, e), r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Ol(t, e, n), n;
};
var vr = class extends k {
  constructor() {
    super(...arguments), this._visible = false, this._middleware = {
      name: "middleware",
      async fn(t) {
        const { right: e, top: s } = await sn(t);
        return t.x -= Math.sign(e) === 1 ? e + 5 : 0, t.y -= Math.sign(s) === 1 ? s + 5 : 0, t;
      }
    };
  }
  get visible() {
    return this._visible;
  }
  set visible(t) {
    this._visible = t, t && this.updatePosition();
  }
  /**
   * Asynchronously updates the position of the context menu relative to a target element.
   * If no target element is provided, it attempts to use the parent node as the target.
   * The position is calculated using the `computePosition` function from `@floating-ui/dom`,
   * which considers various adjustments like offset, inline positioning, flipping, and shifting
   * to ensure the context menu is properly placed relative to the target element.
   *
   * @param [target] - The target element relative to which the context menu should be positioned.
   *                                 If not provided, the parent node is used as the target.
   * @returns A promise that resolves once the position has been updated. This method
   *                          does not explicitly return a value but updates the context menu's style
   *                          properties to position it on the screen.
   */
  async updatePosition(t) {
    const e = t || this.parentNode;
    if (!e) {
      this.visible = false, console.warn("No target element found for context-menu.");
      return;
    }
    const s = await Hs(e, this, {
      placement: "right",
      middleware: [
        Ss(10),
        js(),
        Ds(),
        zs({ padding: 5 }),
        this._middleware
      ]
    }), { x: n, y: r } = s;
    this.style.left = `${n}px`, this.style.top = `${r}px`;
  }
  render() {
    return y` <slot></slot> `;
  }
};
vr.styles = [
  jt.scrollbar,
  T`
      :host {
        --bim-label--fz: var(--bim-ui_size-xs);
        position: absolute;
        top: 0;
        left: 0;
        z-index: 999;
        overflow: auto;
        max-height: 20rem;
        min-width: 3rem;
        flex-direction: column;
        box-shadow: 1px 2px 8px 2px rgba(0, 0, 0, 0.15);
        padding: 0.5rem;
        border-radius: var(--bim-ui_size-4xs);
        background-color: var(
          --bim-context-menu--bgc,
          var(--bim-ui_bg-contrast-20)
        );
      }

      :host([visible]) {
        display: flex;
      }

      :host(:not([visible])) {
        display: none;
      }
    `
];
var yr = vr;
Il([
  m({ type: Boolean, reflect: true })
], yr.prototype, "visible");
var $t = class extends k {
  constructor() {
    super(...arguments), this._lazyLoadObserver = null, this._visibleElements = [], this.ELEMENTS_BEFORE_OBSERVER = 20, this.useObserver = false, this.elements = /* @__PURE__ */ new Set(), this.observe = (t) => {
      if (!this.useObserver)
        return;
      for (const s of t)
        this.elements.add(s);
      const e = t.slice(this.ELEMENTS_BEFORE_OBSERVER);
      for (const s of e)
        s.remove();
      this.observeLastElement();
    };
  }
  set visibleElements(t) {
    this._visibleElements = this.useObserver ? t : [], this.requestUpdate();
  }
  get visibleElements() {
    return this._visibleElements;
  }
  getLazyObserver() {
    if (!this.useObserver)
      return null;
    if (this._lazyLoadObserver)
      return this._lazyLoadObserver;
    const t = new IntersectionObserver(
      (e) => {
        const s = e[0];
        if (!s.isIntersecting)
          return;
        const n = s.target;
        t.unobserve(n);
        const r = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length, o = [...this.elements][r];
        o && (this.visibleElements = [...this.visibleElements, o], t.observe(o));
      },
      { threshold: 0.5 }
    );
    return t;
  }
  observeLastElement() {
    const t = this.getLazyObserver();
    if (!t)
      return;
    const e = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length - 1, s = [...this.elements][e];
    s && t.observe(s);
  }
  resetVisibleElements() {
    const t = this.getLazyObserver();
    if (t) {
      for (const e of this.elements)
        t.unobserve(e);
      this.visibleElements = [], this.observeLastElement();
    }
  }
  /**
   * Creates a new UI component instance based on the provided template and initial state.
   *
   * @template T - The type of the UI component element.
   * @template S - The type of the component state.
   *
   * @param template - The component template function (stateless or stateful).
   * @param initialState - The initial state of the component (optional for stateless components).
   * @returns The created UI component element or an array containing the element and a function to update its state.
   */
  static create(t, e) {
    const s = document.createDocumentFragment();
    if (t.length === 0)
      return Zt(t(), s), s.firstElementChild;
    if (!e)
      throw new Error(
        "UIComponent: Initial state is required for statefull components."
      );
    let n = e;
    const r = t, o = (a) => (n = { ...n, ...a }, Zt(r(n), s), n);
    return o(e), [s.firstElementChild, o];
  }
};
var ci = (i, t = true) => {
  let e = {};
  for (const s of i.children) {
    const n = s, r = n.getAttribute("name") || n.getAttribute("label");
    if (r) {
      if ("value" in n) {
        const o = n.value;
        if (typeof o == "object" && !Array.isArray(o) && Object.keys(o).length === 0)
          continue;
        e[r] = n.value;
      } else if (t) {
        const o = ci(n);
        if (Object.keys(o).length === 0)
          continue;
        e[r] = o;
      }
    } else
      t && (e = { ...e, ...ci(n) });
  }
  return e;
};
var vi = (i) => i === "true" || i === "false" ? i === "true" : i && !isNaN(Number(i)) && i.trim() !== "" ? Number(i) : i;
var Pl = [">=", "<=", "=", ">", "<", "?", "/", "#"];
function os(i) {
  const t = Pl.find(
    (o) => i.split(o).length === 2
  ), e = i.split(t).map((o) => o.trim()), [s, n] = e, r = n.startsWith("'") && n.endsWith("'") ? n.replace(/'/g, "") : vi(n);
  return { key: s, condition: t, value: r };
}
var Ki = (i) => {
  try {
    const t = [], e = i.split(/&(?![^()]*\))/).map((s) => s.trim());
    for (const s of e) {
      const n = !s.startsWith("(") && !s.endsWith(")"), r = s.startsWith("(") && s.endsWith(")");
      if (n) {
        const o = os(s);
        t.push(o);
      }
      if (r) {
        const o = {
          operator: "&",
          queries: s.replace(/^(\()|(\))$/g, "").split("&").map((a) => a.trim()).map((a, l) => {
            const u = os(a);
            return l > 0 && (u.operator = "&"), u;
          })
        };
        t.push(o);
      }
    }
    return t;
  } catch {
    return null;
  }
};
var as = (i, t, e) => {
  let s = false;
  switch (t) {
    case "=":
      s = i === e;
      break;
    case "?":
      s = String(i).includes(String(e));
      break;
    case "<":
      (typeof i == "number" || typeof e == "number") && (s = i < e);
      break;
    case "<=":
      (typeof i == "number" || typeof e == "number") && (s = i <= e);
      break;
    case ">":
      (typeof i == "number" || typeof e == "number") && (s = i > e);
      break;
    case ">=":
      (typeof i == "number" || typeof e == "number") && (s = i >= e);
      break;
    case "/":
      s = String(i).startsWith(String(e));
      break;
  }
  return s;
};
var Rl = Object.defineProperty;
var Nl = Object.getOwnPropertyDescriptor;
var Ct = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Nl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Rl(t, e, n), n;
};
var _r = class extends k {
  constructor() {
    super(...arguments), this.checked = false, this.checkbox = false, this.noMark = false, this.vertical = false;
  }
  get value() {
    return this._value !== void 0 ? this._value : this.label ? vi(this.label) : this.label;
  }
  set value(t) {
    this._value = t;
  }
  render() {
    return y`
      <div class="parent" .title=${this.label ?? ""}>
        ${this.img || this.icon || this.label ? y` <div style="display: flex; column-gap: 0.375rem">
              ${this.checkbox && !this.noMark ? y`<bim-checkbox
                    style="pointer-events: none"
                    .checked=${this.checked}
                  ></bim-checkbox>` : null}
              <bim-label
                .vertical=${this.vertical}
                .icon=${this.icon}
                .img=${this.img}
                >${this.label}</bim-label
              >
            </div>` : null}
        ${!this.checkbox && !this.noMark && this.checked ? y`<svg
              xmlns="http://www.w3.org/2000/svg"
              height="1.125rem"
              viewBox="0 0 24 24"
              width="1.125rem"
              fill="#FFFFFF"
            >
              <path d="M0 0h24v24H0z" fill="none" />
              <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" />
            </svg>` : null}
        <slot></slot>
      </div>
    `;
  }
};
_r.styles = T`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
      display: block;
      box-sizing: border-box;
      flex: 1;
      padding: 0rem 0.5rem;
      border-radius: var(--bim-ui_size-4xs);
    }

    :host(:hover) {
      cursor: pointer;
      background-color: color-mix(
        in lab,
        var(--bim-selector--bgc, var(--bim-ui_bg-contrast-20)),
        var(--bim-ui_main-base) 10%
      );
    }

    :host([checked]) {
      --bim-label--c: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    :host([checked]) svg {
      fill: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    .parent {
      box-sizing: border-box;
      display: flex;
      justify-content: var(--bim-option--jc, space-between);
      column-gap: 0.5rem;
      align-items: center;
      min-height: 1.75rem;
      height: 100%;
    }

    input {
      height: 1rem;
      width: 1rem;
      cursor: pointer;
      border: none;
      outline: none;
      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));
    }

    input:focus {
      outline: var(--bim-checkbox--olw, 2px) solid
        var(--bim-checkbox--olc, var(--bim-ui_accent-base));
    }

    bim-label {
      pointer-events: none;
    }
  `;
var D = _r;
Ct([
  m({ type: String, reflect: true })
], D.prototype, "img", 2);
Ct([
  m({ type: String, reflect: true })
], D.prototype, "label", 2);
Ct([
  m({ type: String, reflect: true })
], D.prototype, "icon", 2);
Ct([
  m({ type: Boolean, reflect: true })
], D.prototype, "checked", 2);
Ct([
  m({ type: Boolean, reflect: true })
], D.prototype, "checkbox", 2);
Ct([
  m({ type: Boolean, attribute: "no-mark", reflect: true })
], D.prototype, "noMark", 2);
Ct([
  m({
    converter: {
      fromAttribute(i) {
        return i && vi(i);
      }
    }
  })
], D.prototype, "value", 1);
Ct([
  m({ type: Boolean, reflect: true })
], D.prototype, "vertical", 2);
var Ml = Object.defineProperty;
var Ll = Object.getOwnPropertyDescriptor;
var Et = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Ll(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Ml(t, e, n), n;
};
var xr = class extends $t {
  constructor() {
    super(), this.multiple = false, this.required = false, this.vertical = false, this._visible = false, this._value = /* @__PURE__ */ new Set(), this.onValueChange = new Event("change"), this.onWindowMouseUp = (t) => {
      this.visible && (this.contains(t.target) || (this.visible = false));
    }, this.onOptionClick = (t) => {
      const e = t.target, s = this._value.has(e);
      if (!this.multiple && !this.required && !s)
        this._value = /* @__PURE__ */ new Set([e]);
      else if (!this.multiple && !this.required && s)
        this._value = /* @__PURE__ */ new Set([]);
      else if (!this.multiple && this.required && !s)
        this._value = /* @__PURE__ */ new Set([e]);
      else if (this.multiple && !this.required && !s)
        this._value = /* @__PURE__ */ new Set([...this._value, e]);
      else if (this.multiple && !this.required && s) {
        const n = [...this._value].filter((r) => r !== e);
        this._value = new Set(n);
      } else if (this.multiple && this.required && !s)
        this._value = /* @__PURE__ */ new Set([...this._value, e]);
      else if (this.multiple && this.required && s) {
        const n = [...this._value].filter((o) => o !== e), r = new Set(n);
        r.size !== 0 && (this._value = r);
      }
      this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
    }, this.useObserver = true;
  }
  set visible(t) {
    this._visible = t, t || this.resetVisibleElements();
  }
  get visible() {
    return this._visible;
  }
  /**
   * The selected values in the dropdown.
   * @type {any[]}
   * @example
   * const dropdown = document.createElement('bim-dropdown');
   * dropdown.value = ['option1', 'option2'];
   */
  set value(t) {
    if (this.required && Object.keys(t).length === 0)
      return;
    const e = /* @__PURE__ */ new Set();
    for (const s of t) {
      const n = this.findOption(s);
      if (n && (e.add(n), !this.multiple && Object.keys(t).length === 1))
        break;
    }
    this._value = e, this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
  }
  get value() {
    return [...this._value].filter(
      (t) => t instanceof D && t.checked
    ).map((t) => t.value);
  }
  get _options() {
    const t = /* @__PURE__ */ new Set([...this.elements]);
    for (const e of this.children)
      e instanceof D && t.add(e);
    return [...t];
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    this.observe(e);
    const s = /* @__PURE__ */ new Set();
    for (const n of this.elements) {
      if (!(n instanceof D)) {
        n.remove();
        continue;
      }
      n.checked && s.add(n), n.removeEventListener("click", this.onOptionClick), n.addEventListener("click", this.onOptionClick);
    }
    this._value = s;
  }
  updateOptionsState() {
    for (const t of this._options)
      t instanceof D && (t.checked = this._value.has(t));
  }
  findOption(t) {
    return this._options.find((e) => e instanceof D ? e.label === t || e.value === t : false);
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("mouseup", this.onWindowMouseUp);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("mouseup", this.onWindowMouseUp);
  }
  render() {
    let t, e, s;
    if (this._value.size === 0)
      t = "Select an option...";
    else if (this._value.size === 1) {
      const n = [...this._value][0];
      t = (n == null ? void 0 : n.label) || (n == null ? void 0 : n.value), e = n == null ? void 0 : n.img, s = n == null ? void 0 : n.icon;
    } else
      t = `Multiple (${this._value.size})`;
    return y`
      <bim-input
        title=${this.label ?? ""}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        <div class="input" @click=${() => this.visible = !this.visible}>
          <bim-label
            .img=${e}
            .icon=${s}
            style="overflow: hidden;"
            >${t}</bim-label
          >
          <svg
            style="flex-shrink: 0; fill: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100))"
            xmlns="http://www.w3.org/2000/svg"
            height="1.125rem"
            viewBox="0 0 24 24"
            width="1.125rem"
            fill="#9ca3af"
          >
            <path d="M0 0h24v24H0V0z" fill="none" />
            <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
          </svg>
        </div>
        <bim-context-menu .visible=${this.visible}>
          <slot @slotchange=${this.onSlotChange}></slot>
          ${this.visibleElements.map((n) => n)}
        </bim-context-menu>
      </bim-input>
    `;
  }
};
xr.styles = [
  jt.scrollbar,
  T`
      :host {
        --bim-input--bgc: var(
          --bim-dropdown--bgc,
          var(--bim-ui_bg-contrast-20)
        );
        --bim-input--olw: 2px;
        --bim-input--olc: transparent;
        --bim-input--bdrs: var(--bim-ui_size-4xs);
        flex: 1;
        display: block;
      }

      :host([visible]) {
        --bim-input--olc: var(--bim-ui_accent-base);
      }

      .input {
        --bim-label--fz: var(--bim-drodown--fz, var(--bim-ui_size-xs));
        --bim-label--c: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100));
        height: 100%;
        display: flex;
        flex: 1;
        overflow: hidden;
        column-gap: 0.25rem;
        outline: none;
        cursor: pointer;
        align-items: center;
        justify-content: space-between;
        padding: 0 0.5rem;
      }

      bim-label {
        pointer-events: none;
      }
    `
];
var ct = xr;
Et([
  m({ type: String, reflect: true })
], ct.prototype, "name", 2);
Et([
  m({ type: String, reflect: true })
], ct.prototype, "icon", 2);
Et([
  m({ type: String, reflect: true })
], ct.prototype, "label", 2);
Et([
  m({ type: Boolean, reflect: true })
], ct.prototype, "multiple", 2);
Et([
  m({ type: Boolean, reflect: true })
], ct.prototype, "required", 2);
Et([
  m({ type: Boolean, reflect: true })
], ct.prototype, "vertical", 2);
Et([
  m({ type: Boolean, reflect: true })
], ct.prototype, "visible", 1);
Et([
  Me()
], ct.prototype, "_value", 2);
var zl = Object.defineProperty;
var wr = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && zl(t, e, n), n;
};
var $r = class extends k {
  constructor() {
    super(...arguments), this.floating = false, this.layouts = {};
  }
  // private isVerticalArea(area: string) {
  //   const { rows } = this;
  //   const row = rows.find((row) => row.includes(area));
  //   if (!row)
  //     throw new Error(
  //       `${area} wasn't defined in the grid-template of this bim-grid`,
  //     );
  //   const index = rows.indexOf(row);
  //   const abovePanel = index > 0 && rows[index - 1].includes(area);
  //   const belowPanel =
  //     index < rows.length - 1 && rows[index + 1].includes(area);
  //   return abovePanel || belowPanel;
  // }
  getUniqueAreasFromTemplate(t) {
    const e = t.split(`
`).map((s) => s.trim()).map((s) => s.split('"')[1]).filter((s) => s !== void 0).flatMap((s) => s.split(/\s+/));
    return [...new Set(e)].filter((s) => s !== "");
  }
  firstUpdated() {
    this._onLayoutChange = new Event("layoutchange");
  }
  render() {
    if (this.layout) {
      if (this.layouts[this.layout]) {
        this.innerHTML = "";
        const t = this.layouts[this.layout], e = this.getUniqueAreasFromTemplate(t.template).map((s) => {
          const n = t.elements[s];
          return n && (n.style.gridArea = s), n;
        }).filter((s) => !!s);
        this.style.gridTemplate = t.template, this._onLayoutChange && this.dispatchEvent(this._onLayoutChange), this.append(...e);
      }
    } else
      this.innerHTML = "", this.style.gridTemplate = "", this._onLayoutChange && this.dispatchEvent(this._onLayoutChange);
    return y`<slot></slot>`;
  }
};
$r.styles = T`
    :host {
      display: grid;
      height: 100%;
      width: 100%;
      overflow: hidden;
      box-sizing: border-box;
    }

    /* :host(:not([layout])) {
      display: none;
    } */

    :host([floating]) {
      --bim-panel--bdrs: var(--bim-ui_size-4xs);
      background-color: transparent;
      padding: 1rem;
      gap: 1rem;
      position: absolute;
      pointer-events: none;
      top: 0px;
      left: 0px;
    }

    :host(:not([floating])) {
      --bim-panel--bdrs: 0;
      background-color: var(--bim-ui_bg-contrast-20);
      gap: 1px;
    }
  `;
var bn = $r;
wr([
  m({ type: Boolean, reflect: true })
], bn.prototype, "floating");
wr([
  m({ type: String, reflect: true })
], bn.prototype, "layout");
var Zi = class extends k {
  render() {
    return y`
      <iconify-icon .icon=${this.icon} height="none"></iconify-icon>
    `;
  }
};
Zi.styles = T`
    :host {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
    }

    iconify-icon {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
      color: var(--bim-icon--c);
    }
  `, Zi.properties = {
  icon: { type: String }
};
var Dl = Zi;
var jl = Object.defineProperty;
var yi = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && jl(t, e, n), n;
};
var Cr = class extends k {
  constructor() {
    super(...arguments), this.vertical = false, this.onValueChange = new Event("change");
  }
  get value() {
    const t = {};
    for (const e of this.children) {
      const s = e;
      "value" in s ? t[s.name || s.label] = s.value : "checked" in s && (t[s.name || s.label] = s.checked);
    }
    return t;
  }
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((a) => {
        const l = a;
        return l.name === s || l.label === s;
      });
      if (!n)
        continue;
      const r = n, o = t[s];
      typeof o == "boolean" ? r.checked = o : r.value = o;
    }
  }
  render() {
    return y`
      <div class="parent">
        ${this.label || this.icon ? y`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="input">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Cr.styles = T`
    :host {
      flex: 1;
      display: block;
    }

    .parent {
      display: flex;
      flex-wrap: wrap;
      column-gap: 1rem;
      row-gap: 0.375rem;
      user-select: none;
      flex: 1;
    }

    :host(:not([vertical])) .parent {
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .input {
      overflow: hidden;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      min-height: 1.75rem;
      min-width: 3rem;
      gap: var(--bim-input--g, var(--bim-ui_size-4xs));
      padding: var(--bim-input--p, 0);
      background-color: var(--bim-input--bgc, transparent);
      outline: var(--bim-input--olw, 2px) solid
        var(--bim-input--olc, transparent);
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
    }

    :host(:not([vertical])) .input {
      flex: 1;
      justify-content: flex-end;
    }

    :host(:not([vertical])[label]) .input {
      max-width: fit-content;
    }
  `;
var je = Cr;
yi([
  m({ type: String, reflect: true })
], je.prototype, "name");
yi([
  m({ type: String, reflect: true })
], je.prototype, "label");
yi([
  m({ type: String, reflect: true })
], je.prototype, "icon");
yi([
  m({ type: Boolean, reflect: true })
], je.prototype, "vertical");
var Hl = Object.defineProperty;
var He = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Hl(t, e, n), n;
};
var Er = class extends k {
  constructor() {
    super(...arguments), this.labelHidden = false, this.iconHidden = false, this.vertical = false;
  }
  get value() {
    return this.textContent ? vi(this.textContent) : this.textContent;
  }
  render() {
    return y`
      <div class="parent" .title=${this.textContent ?? ""}>
        ${this.img ? y`<img .src=${this.img} .alt=${this.textContent || ""} />` : null}
        ${!this.iconHidden && this.icon ? y`<bim-icon .icon=${this.icon}></bim-icon>` : null}
        <p><slot></slot></p>
      </div>
    `;
  }
};
Er.styles = T`
    :host {
      --bim-icon--c: var(--bim-label--c);
      color: var(--bim-label--c, var(--bim-ui_bg-contrast-60));
      font-size: var(--bim-label--fz, var(--bim-ui_size-xs));
      overflow: hidden;
      display: block;
      white-space: nowrap;
      line-height: 1.1rem;
    }

    .parent {
      display: flex;
      align-items: center;
      column-gap: 0.25rem;
      row-gap: 0.125rem;
      user-select: none;
      height: 100%;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .parent p {
      margin: 0;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    :host([label-hidden]) .parent p,
    :host(:empty) .parent p {
      display: none;
    }

    img {
      height: 100%;
      aspect-ratio: 1;
      border-radius: 100%;
      margin-right: 0.125rem;
    }

    :host(:not([vertical])) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 1.5)
      );
    }

    :host([vertical]) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 4)
      );
    }
  `;
var se = Er;
He([
  m({ type: String, reflect: true })
], se.prototype, "img");
He([
  m({ type: Boolean, attribute: "label-hidden", reflect: true })
], se.prototype, "labelHidden");
He([
  m({ type: String, reflect: true })
], se.prototype, "icon");
He([
  m({ type: Boolean, attribute: "icon-hidden", reflect: true })
], se.prototype, "iconHidden");
He([
  m({ type: Boolean, reflect: true })
], se.prototype, "vertical");
var Fl = Object.defineProperty;
var Bl = Object.getOwnPropertyDescriptor;
var J = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Bl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Fl(t, e, n), n;
};
var Ar = class extends k {
  constructor() {
    super(...arguments), this._value = 0, this.vertical = false, this.slider = false, this._input = Wt(), this.onValueChange = new Event("change");
  }
  set value(t) {
    this.setValue(t.toString());
  }
  get value() {
    return this._value;
  }
  onChange(t) {
    t.stopPropagation();
    const { value: e } = this._input;
    e && this.setValue(e.value);
  }
  setValue(t) {
    const { value: e } = this._input;
    let s = t;
    if (s = s.replace(/[^0-9.-]/g, ""), s = s.replace(/(\..*)\./g, "$1"), s.endsWith(".") || (s.lastIndexOf("-") > 0 && (s = s[0] + s.substring(1).replace(/-/g, "")), s === "-" || s === "-0"))
      return;
    let n = Number(s);
    Number.isNaN(n) || (n = this.min !== void 0 ? Math.max(n, this.min) : n, n = this.max !== void 0 ? Math.min(n, this.max) : n, this.value !== n && (this._value = n, e && (e.value = this.value.toString()), this.requestUpdate(), this.dispatchEvent(this.onValueChange)));
  }
  onBlur() {
    const { value: t } = this._input;
    t && Number.isNaN(Number(t.value)) && (t.value = this.value.toString());
  }
  onSliderMouseDown(t) {
    document.body.style.cursor = "w-resize";
    const { clientX: e } = t, s = this.value;
    let n = false;
    const r = (l) => {
      var u;
      n = true;
      const { clientX: h } = l, d = this.step ?? 1, c = ((u = d.toString().split(".")[1]) == null ? void 0 : u.length) || 0, p = 1 / (this.sensitivity ?? 1), v = (h - e) / p;
      if (Math.floor(Math.abs(v)) !== Math.abs(v))
        return;
      const x = s + v * d;
      this.setValue(x.toFixed(c));
    }, o = () => {
      this.slider = true, this.removeEventListener("blur", o);
    }, a = () => {
      document.removeEventListener("mousemove", r), document.body.style.cursor = "default", n ? n = false : (this.addEventListener("blur", o), this.slider = false, requestAnimationFrame(() => this.focus())), document.removeEventListener("mouseup", a);
    };
    document.addEventListener("mousemove", r), document.addEventListener("mouseup", a);
  }
  onFocus(t) {
    t.stopPropagation();
    const e = (s) => {
      s.key === "Escape" && (this.blur(), window.removeEventListener("keydown", e));
    };
    window.addEventListener("keydown", e);
  }
  connectedCallback() {
    super.connectedCallback(), this.min && this.min > this.value && (this._value = this.min), this.max && this.max < this.value && (this._value = this.max);
  }
  /**
   * Sets focus to the input element of the number input component.
   * This method is useful for programmatically focusing the input element, for example,
   * in response to a user action or to emphasize the input in the UI.
   *
   * If the input element reference is not available (not yet rendered or disconnected),
   * this method will do nothing.
   */
  focus() {
    const { value: t } = this._input;
    t && t.focus();
  }
  render() {
    const t = y`
      ${this.pref || this.icon ? y`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            .icon=${this.icon}
            >${this.pref}</bim-label
          >` : null}
      <input
        ${ot(this._input)}
        type="text"
        aria-label=${this.label || this.name || "Number Input"}
        size="1"
        @input=${(a) => a.stopPropagation()}
        @change=${this.onChange}
        @blur=${this.onBlur}
        @focus=${this.onFocus}
        .value=${this.value.toString()}
      />
      ${this.suffix ? y`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            >${this.suffix}</bim-label
          >` : null}
    `, e = this.min ?? -1 / 0, s = this.max ?? 1 / 0, n = 100 * (this.value - e) / (s - e), r = y`
      <style>
        .slider-indicator {
          width: ${`${n}%`};
        }
      </style>
      <div class="slider" @mousedown=${this.onSliderMouseDown}>
        <div class="slider-indicator"></div>
        ${this.pref || this.icon ? y`<bim-label
              style="z-index: 1; margin-right: 0.125rem"
              .icon=${this.icon}
              >${`${this.pref}: `}</bim-label
            >` : null}
        <bim-label style="z-index: 1;">${this.value}</bim-label>
        ${this.suffix ? y`<bim-label style="z-index: 1;">${this.suffix}</bim-label>` : null}
      </div>
    `, o = `${this.label || this.name || this.pref ? `${this.label || this.name || this.pref}: ` : ""}${this.value}${this.suffix ?? ""}`;
    return y`
      <bim-input
        title=${o}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        ${this.slider ? r : t}
      </bim-input>
    `;
  }
};
Ar.styles = T`
    :host {
      --bim-input--bgc: var(
        --bim-number-input--bgc,
        var(--bim-ui_bg-contrast-20)
      );
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-number-input--olc, transparent);
      --bim-input--bdrs: var(--bim-number-input--bdrs, var(--bim-ui_size-4xs));
      --bim-input--p: 0 0.375rem;
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(
        --bim-number-inputfocus--c,
        var(--bim-ui_accent-base)
      );
    }

    :host(:not([slider])) bim-label {
      --bim-label--c: var(
        --bim-number-input_affixes--c,
        var(--bim-ui_bg-contrast-60)
      );
      --bim-label--fz: var(
        --bim-number-input_affixes--fz,
        var(--bim-ui_size-xs)
      );
    }

    p {
      margin: 0;
      padding: 0;
    }

    input {
      background-color: transparent;
      outline: none;
      border: none;
      padding: 0;
      flex-grow: 1;
      text-align: right;
      font-family: inherit;
      font-feature-settings: inherit;
      font-variation-settings: inherit;
      font-size: var(--bim-number-input--fz, var(--bim-ui_size-xs));
      color: var(--bim-number-input--c, var(--bim-ui_bg-contrast-100));
    }

    :host([suffix]:not([pref])) input {
      text-align: left;
    }

    :host([slider]) {
      --bim-input--p: 0;
    }

    :host([slider]) .slider {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
    }

    .slider {
      position: relative;
      display: flex;
      justify-content: center;
      width: 100%;
      height: 100%;
      padding: 0 0.5rem;
    }

    .slider-indicator {
      height: 100%;
      background-color: var(--bim-ui_main-base);
      position: absolute;
      top: 0;
      left: 0;
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
    }

    bim-input {
      display: flex;
    }

    bim-label {
      pointer-events: none;
    }
  `;
var W = Ar;
J([
  m({ type: String, reflect: true })
], W.prototype, "name", 2);
J([
  m({ type: String, reflect: true })
], W.prototype, "icon", 2);
J([
  m({ type: String, reflect: true })
], W.prototype, "label", 2);
J([
  m({ type: String, reflect: true })
], W.prototype, "pref", 2);
J([
  m({ type: Number, reflect: true })
], W.prototype, "min", 2);
J([
  m({ type: Number, reflect: true })
], W.prototype, "value", 1);
J([
  m({ type: Number, reflect: true })
], W.prototype, "step", 2);
J([
  m({ type: Number, reflect: true })
], W.prototype, "sensitivity", 2);
J([
  m({ type: Number, reflect: true })
], W.prototype, "max", 2);
J([
  m({ type: String, reflect: true })
], W.prototype, "suffix", 2);
J([
  m({ type: Boolean, reflect: true })
], W.prototype, "vertical", 2);
J([
  m({ type: Boolean, reflect: true })
], W.prototype, "slider", 2);
var Ul = Object.defineProperty;
var Vl = Object.getOwnPropertyDescriptor;
var Fe = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Vl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Ul(t, e, n), n;
};
var Sr = class extends k {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change"), this._hidden = false, this.headerHidden = false, this.activationButton = document.createElement("bim-button");
  }
  set hidden(t) {
    this._hidden = t, this.activationButton.active = !t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  /**
   * The `value` getter computes and returns the current state of the panel's form elements as an object. This property is dynamic and reflects the current input values within the panel. When accessed, it traverses the panel's child elements, collecting values from those that have a `name` or `label` attribute, and constructs an object where each key corresponds to the `name` or `label` of the element, and the value is the element's value. This property is particularly useful for forms or interactive panels where the user's input needs to be retrieved programmatically. The value returned is a snapshot of the panel's state at the time of access, and it does not maintain a live link to the input elements.
   *
   * @type {Record<string, any>}
   * @default {}
   * @example <bim-panel></bim-panel> <!-- Access via JavaScript to get value -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * console.log(panel.value); // Logs the current value object of the panel
   */
  get value() {
    return ci(this);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel's form elements. When a data object is passed to this property, it attempts to match the object's keys with the `name` or `label` attributes of the panel's child elements. If a match is found, the corresponding element's value is updated to the value associated with the key in the data object. This property is useful for initializing the panel with specific data or updating its state based on external inputs. Note that this operation does not affect elements without a matching `name` or `label`, and it only updates the values of elements that are direct children of the panel.
   *
   * @type {Record<string, any>}
   * @example <bim-panel></bim-panel> <!-- Set value via JavaScript -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * panel.value = { 'input-name': 'John Doe', 'checkbox-name': true };
   */
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((o) => {
        const a = o;
        return a.name === s || a.label === s;
      });
      if (!n)
        continue;
      const r = n;
      r.value = t[s];
    }
  }
  connectedCallback() {
    super.connectedCallback(), this.activationButton.active = !this.hidden, this.activationButton.onclick = () => this.hidden = !this.hidden;
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.activationButton.remove();
  }
  /**
   * Collapses all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `true`,
   * effectively hiding their content from view. This can be used to programmatically minimize the space taken up by sections
   * within the panel, making the panel more compact or to hide details that are not immediately necessary.
   */
  collapseSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = true;
  }
  /**
   * Expands all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `false`,
   * effectively showing their content. This can be used to programmatically reveal the content of sections within the panel,
   * making the panel more informative or to display details that are necessary for the user.
   */
  expandSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = false;
  }
  render() {
    return this.activationButton.icon = this.icon, this.activationButton.label = this.label || this.name, this.activationButton.tooltipTitle = this.label || this.name, y`
      <div class="parent">
        ${this.label || this.name || this.icon ? y`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="sections">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Sr.styles = [
  jt.scrollbar,
  T`
      :host {
        display: flex;
        border-radius: var(--bim-ui_size-base);
        background-color: var(--bim-ui_bg-base);
        overflow: auto;
      }

      :host([hidden]) {
        display: none;
      }

      .parent {
        display: flex;
        flex: 1;
        flex-direction: column;
        pointer-events: auto;
        overflow: auto;
      }

      .parent bim-label {
        --bim-label--c: var(--bim-panel--c, var(--bim-ui_bg-contrast-80));
        --bim-label--fz: var(--bim-panel--fz, var(--bim-ui_size-sm));
        font-weight: 600;
        padding: 1rem;
        flex-shrink: 0;
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([header-hidden]) .parent bim-label {
        display: none;
      }

      .sections {
        display: flex;
        flex-direction: column;
        overflow: auto;
      }

      ::slotted(bim-panel-section:not(:last-child)) {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }
    `
];
var re = Sr;
Fe([
  m({ type: String, reflect: true })
], re.prototype, "icon", 2);
Fe([
  m({ type: String, reflect: true })
], re.prototype, "name", 2);
Fe([
  m({ type: String, reflect: true })
], re.prototype, "label", 2);
Fe([
  m({ type: Boolean, reflect: true })
], re.prototype, "hidden", 1);
Fe([
  m({ type: Boolean, attribute: "header-hidden", reflect: true })
], re.prototype, "headerHidden", 2);
var Wl = Object.defineProperty;
var Be = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Wl(t, e, n), n;
};
var kr = class extends k {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change");
  }
  /**
   * The `value` getter computes and returns the current state of the panel section's form elements as an object. This object's keys are the `name` or `label` attributes of the child elements, and the values are the corresponding values of these elements. This property is particularly useful for retrieving a consolidated view of the user's input or selections within the panel section. When the value of any child element changes, the returned object from this getter will reflect those changes, providing a dynamic snapshot of the panel section's state. Note that this property does not have a default value as it dynamically reflects the current state of the panel section's form elements.
   * @type {Record<string, any>}
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a getter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * console.log(section.value); // Logs the current value object
   */
  get value() {
    return ci(this);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel section's child elements. It accepts an object where keys correspond to the `name` or `label` attributes of the child elements, and the values are the new values to be set for these elements. This property is useful for initializing the panel section with specific values or updating its state based on external data. When the property changes, the corresponding child elements' values are updated to reflect the new state. This does not have a default value as it is a method for updating child elements' values.
   * @type {Record<string, any>}
   * @default undefined
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a setter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * section.value = { 'user-settings': 'John Doe' }; // Programmatically sets the value of a child element named 'user-settings'
   */
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((o) => {
        const a = o;
        return a.name === s || a.label === s;
      });
      if (!n)
        continue;
      const r = n;
      r.value = t[s];
    }
  }
  onHeaderClick() {
    this.fixed || (this.collapsed = !this.collapsed);
  }
  render() {
    const t = this.label || this.icon || this.name || this.fixed, e = y`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
    >
      <path d="M0 0h24v24H0V0z" fill="none" />
      <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
    </svg>`, s = y`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
    >
      <path d="M0 0h24v24H0z" fill="none" />
      <path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z" />
    </svg>`, n = this.collapsed ? e : s, r = y`
      <div
        class="header"
        title=${this.label ?? ""}
        @click=${this.onHeaderClick}
      >
        ${this.label || this.icon || this.name ? y`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        ${this.fixed ? null : n}
      </div>
    `;
    return y`
      <div class="parent">
        ${t ? r : null}
        <div class="components">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
kr.styles = [
  jt.scrollbar,
  T`
      :host {
        display: block;
        pointer-events: auto;
      }

      :host(:not([fixed])) .header:hover {
        --bim-label--c: var(--bim-ui_accent-base);
        color: var(--bim-ui_accent-base);
        cursor: pointer;
      }

      :host(:not([fixed])) .header:hover svg {
        fill: var(--bim-ui_accent-base);
      }

      .header {
        --bim-label--fz: var(--bim-ui_size-sm);
        --bim-label--c: var(--bim-ui_bg-contrast-80);
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        height: 1.5rem;
        padding: 0.75rem 1rem;
      }

      .header svg {
        fill: var(--bim-ui_bg-contrast-80);
      }

      .title {
        display: flex;
        align-items: center;
        column-gap: 0.5rem;
      }

      .title p {
        font-size: var(--bim-ui_size-sm);
      }

      .components {
        display: flex;
        flex-direction: column;
        row-gap: 0.75rem;
        padding: 0.125rem 1rem 1rem;
      }

      :host(:not([fixed])[collapsed]) .components {
        display: none;
      }

      bim-label {
        pointer-events: none;
      }
    `
];
var oe = kr;
Be([
  m({ type: String, reflect: true })
], oe.prototype, "icon");
Be([
  m({ type: String, reflect: true })
], oe.prototype, "label");
Be([
  m({ type: String, reflect: true })
], oe.prototype, "name");
Be([
  m({ type: Boolean, reflect: true })
], oe.prototype, "fixed");
Be([
  m({ type: Boolean, reflect: true })
], oe.prototype, "collapsed");
var Gl = Object.defineProperty;
var Ue = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Gl(t, e, n), n;
};
var Or = class extends k {
  constructor() {
    super(...arguments), this.vertical = false, this.onValueChange = new Event("change"), this._canEmitEvents = false, this._value = document.createElement("bim-option"), this.onOptionClick = (t) => {
      this._value = t.target, this.dispatchEvent(this.onValueChange);
      for (const e of this.children)
        e instanceof D && (e.checked = e === t.target);
    };
  }
  get _options() {
    return [...this.querySelectorAll("bim-option")];
  }
  /**
   * Sets the value of the selector.
   * It finds the matching option based on the provided value and sets it as the selected option.
   * If no matching option is found, it does nothing.
   *
   * @param value - The value to set for the selector.
   */
  set value(t) {
    const e = this.findOption(t);
    if (e) {
      for (const s of this._options)
        s.checked = s === e;
      this._value = e, this._canEmitEvents && this.dispatchEvent(this.onValueChange);
    }
  }
  get value() {
    return this._value.value;
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    for (const s of e)
      s instanceof D && (s.noMark = true, s.removeEventListener("click", this.onOptionClick), s.addEventListener("click", this.onOptionClick));
  }
  findOption(t) {
    return this._options.find((e) => e instanceof D ? e.label === t || e.value === t : false);
  }
  firstUpdated() {
    const t = [...this.children].find(
      (e) => e instanceof D && e.checked
    );
    t && (this._value = t);
  }
  render() {
    return y`
      <bim-input
        .vertical=${this.vertical}
        .label=${this.label}
        .icon=${this.icon}
      >
        <slot @slotchange=${this.onSlotChange}></slot>
      </bim-input>
    `;
  }
};
Or.styles = T`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      --bim-input--g: 0;
      --bim-option--jc: center;
      flex: 1;
      display: block;
    }

    ::slotted(bim-option) {
      border-radius: 0;
    }

    ::slotted(bim-option[checked]) {
      --bim-label--c: var(--bim-ui_main-contrast);
      background-color: var(--bim-ui_main-base);
    }
  `;
var ae = Or;
Ue([
  m({ type: String, reflect: true })
], ae.prototype, "name");
Ue([
  m({ type: String, reflect: true })
], ae.prototype, "icon");
Ue([
  m({ type: String, reflect: true })
], ae.prototype, "label");
Ue([
  m({ type: Boolean, reflect: true })
], ae.prototype, "vertical");
Ue([
  Me()
], ae.prototype, "_value");
var ql = Object.defineProperty;
var Yl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && ql(t, e, n), n;
};
var Tr = class extends k {
  constructor() {
    super(...arguments), this.column = "", this.columnIndex = 0, this.rowData = {};
  }
  get data() {
    return this.column ? this.rowData[this.column] : null;
  }
  render() {
    return y`
      <style>
        :host {
          grid-area: ${this.column ?? "unset"};
        }
      </style>
      <slot></slot>
    `;
  }
};
Tr.styles = T`
    :host {
      padding: 0.25rem 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    :host([data-column-index="0"]:not([data-cell-header])) {
      justify-content: normal;
    }

    :host([data-column-index="0"]:not([data-cell-header]))
      ::slotted(bim-label) {
      text-align: left;
    }

    ::slotted(*) {
      --bim-input--bgc: transparent;
      --bim-input--olc: var(--bim-ui_bg-contrast-20);
      --bim-input--olw: 1px;
    }

    ::slotted(bim-input) {
      --bim-input--olw: 0;
    }

    ::slotted(bim-label) {
      white-space: normal;
      text-align: center;
    }
  `;
var Ir = Tr;
Yl([
  m({ type: String, reflect: true })
], Ir.prototype, "column");
var Xl = Object.defineProperty;
var Jl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Xl(t, e, n), n;
};
var Pr = class extends k {
  constructor() {
    super(...arguments), this._groups = [], this.data = [], this.table = this.closest("bim-table");
  }
  toggleGroups(t, e = false) {
    for (const s of this._groups)
      s.childrenHidden = typeof t > "u" ? !s.childrenHidden : !t, e && s.toggleChildren(t, e);
  }
  render() {
    return this._groups = [], y`
      <slot></slot>
      ${this.data.map((t) => {
      const e = document.createElement(
        "bim-table-group"
      );
      return this._groups.push(e), e.table = this.table, e.data = t, e;
    })}
    `;
  }
};
Pr.styles = T`
    :host {
      position: relative;
      grid-area: Children;
    }

    :host([hidden]) {
      display: none;
    }

    ::slotted(.branch.branch-vertical) {
      top: 0;
      bottom: 1.125rem;
    }
  `;
var Rr = Pr;
Jl([
  m({ type: Array, attribute: false })
], Rr.prototype, "data");
var Ql = Object.defineProperty;
var Kl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Ql(t, e, n), n;
};
var Nr = class extends k {
  constructor() {
    super(...arguments), this.data = { data: {} }, this.childrenHidden = true, this.table = this.closest("bim-table");
  }
  connectedCallback() {
    super.connectedCallback(), this.table && this.table.expanded ? this.childrenHidden = false : this.childrenHidden = true;
  }
  toggleChildren(t, e = false) {
    this._children && (this.childrenHidden = typeof t > "u" ? !this.childrenHidden : !t, e && this._children.toggleGroups(t, e));
  }
  render() {
    var t, e;
    const s = ((t = this.table) == null ? void 0 : t.getGroupIndentation(this.data)) ?? 0, n = y`
      <style>
        .branch-vertical {
          left: ${s + 0.5625}rem;
        }
      </style>
      <div class="branch branch-vertical"></div>
    `, r = document.createDocumentFragment();
    Zt(n, r);
    const o = document.createElement("div");
    o.classList.add("branch", "branch-horizontal"), o.style.left = `${s - 1 + 0.5625}rem`;
    const a = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "svg"
    );
    a.setAttribute("height", "9.5"), a.setAttribute("width", "7.5"), a.setAttribute("viewBox", "0 0 4.6666672 7.3333333");
    const l = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "path"
    );
    l.setAttribute(
      "d",
      "m 1.7470835,6.9583848 2.5899999,-2.59 c 0.39,-0.39 0.39,-1.02 0,-1.41 L 1.7470835,0.36838483 c -0.63,-0.62000003 -1.71000005,-0.18 -1.71000005,0.70999997 v 5.17 c 0,0.9 1.08000005,1.34 1.71000005,0.71 z"
    ), a.append(l);
    const u = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "svg"
    );
    u.setAttribute("height", "6.5"), u.setAttribute("width", "9.5"), u.setAttribute("viewBox", "0 0 5.9111118 5.0175439");
    const h = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "path"
    );
    h.setAttribute(
      "d",
      "M -0.33616196,1.922522 2.253838,4.5125219 c 0.39,0.39 1.02,0.39 1.41,0 L 6.2538379,1.922522 c 0.6200001,-0.63 0.18,-1.71000007 -0.7099999,-1.71000007 H 0.37383804 c -0.89999997,0 -1.33999997,1.08000007 -0.71,1.71000007 z"
    ), u.append(h);
    const d = document.createElement("div");
    d.addEventListener("click", (v) => {
      v.stopPropagation(), this.toggleChildren();
    }), d.classList.add("caret"), d.style.left = `${0.125 + s}rem`, this.childrenHidden ? d.append(a) : d.append(u);
    const c = document.createElement("bim-table-row");
    this.data.children && !this.childrenHidden && c.append(r), c.table = this.table, c.data = this.data.data, (e = this.table) == null || e.dispatchEvent(
      new CustomEvent("rowcreated", { detail: { row: c } })
    ), this.data.children && c.append(d), s !== 0 && (!this.data.children || this.childrenHidden) && c.append(o);
    let p;
    if (this.data.children) {
      p = document.createElement("bim-table-children"), this._children = p, p.table = this.table, p.data = this.data.children;
      const v = document.createDocumentFragment();
      Zt(n, v), p.append(v);
    }
    return y`
      <div class="parent">${c} ${this.childrenHidden ? null : p}</div>
    `;
  }
};
Nr.styles = T`
    :host {
      position: relative;
    }

    .parent {
      display: grid;
      grid-template-areas: "Data" "Children";
    }

    .branch {
      position: absolute;
      z-index: 1;
    }

    .branch-vertical {
      border-left: 1px dotted var(--bim-ui_bg-contrast-40);
    }

    .branch-horizontal {
      top: 50%;
      width: 1rem;
      border-bottom: 1px dotted var(--bim-ui_bg-contrast-40);
    }

    .caret {
      position: absolute;
      z-index: 2;
      transform: translateY(-50%) rotate(0deg);
      top: 50%;
      display: flex;
      width: 0.95rem;
      height: 0.95rem;
      justify-content: center;
      align-items: center;
      cursor: pointer;
    }

    .caret svg {
      fill: var(--bim-ui_bg-contrast-60);
    }
  `;
var Mr = Nr;
Kl([
  m({ type: Boolean, attribute: "children-hidden", reflect: true })
], Mr.prototype, "childrenHidden");
var Zl = Object.defineProperty;
var Ve = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Zl(t, e, n), n;
};
var Lr = class extends k {
  constructor() {
    super(...arguments), this.columns = [], this.hiddenColumns = [], this.data = {}, this.isHeader = false, this.table = this.closest("bim-table"), this.onTableColumnsChange = () => {
      this.table && (this.columns = this.table.columns);
    }, this.onTableColumnsHidden = () => {
      this.table && (this.hiddenColumns = this.table.hiddenColumns);
    }, this._observer = new IntersectionObserver(
      (t) => {
        this._intersecting = t[0].isIntersecting;
      },
      { rootMargin: "36px" }
    );
  }
  get _columnNames() {
    return this.columns.filter(
      (t) => !this.hiddenColumns.includes(t.name)
    ).map((t) => t.name);
  }
  get _columnWidths() {
    return this.columns.filter(
      (t) => !this.hiddenColumns.includes(t.name)
    ).map((t) => t.width);
  }
  connectedCallback() {
    super.connectedCallback(), this._observer.observe(this), this.table && (this.columns = this.table.columns, this.hiddenColumns = this.table.hiddenColumns, this.table.addEventListener("columnschange", this.onTableColumnsChange), this.table.addEventListener("columnshidden", this.onTableColumnsHidden));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._observer.unobserve(this), this.table && (this.columns = [], this.hiddenColumns = [], this.table.removeEventListener("columnschange", this.onTableColumnsChange), this.table.removeEventListener("columnshidden", this.onTableColumnsHidden));
  }
  compute() {
    var t, e, s;
    const n = ((t = this.table) == null ? void 0 : t.getRowIndentation(this.data)) ?? 0, r = this.isHeader ? this.data : ((e = this.table) == null ? void 0 : e.computeRowDeclaration(this.data)) ?? this.data, o = [];
    for (const a in r) {
      if (this.hiddenColumns.includes(a))
        continue;
      const l = r[a];
      let u;
      if (typeof l == "string" || typeof l == "boolean" || typeof l == "number" ? (u = document.createElement("bim-label"), u.textContent = String(l)) : l instanceof HTMLElement ? u = l : (u = document.createDocumentFragment(), Zt(l, u)), !u)
        continue;
      const h = document.createElement("bim-table-cell");
      h.append(u), h.column = a, this._columnNames.indexOf(a) === 0 && !this.isHeader && (h.style.marginLeft = `${n + 0.125}rem`);
      const d = this._columnNames.indexOf(a);
      h.setAttribute("data-column-index", String(d)), h.toggleAttribute("data-cell-header", this.isHeader), h.rowData = this.data, (s = this.table) == null || s.dispatchEvent(
        new CustomEvent("cellcreated", {
          detail: { cell: h }
        })
      ), o.push(h);
    }
    return this.style.gridTemplateAreas = `"${this._columnNames.join(" ")}"`, this.style.gridTemplateColumns = `${this._columnWidths.join(" ")}`, y`
      ${o}
      <slot></slot>
    `;
  }
  render() {
    return y`${this._intersecting ? this.compute() : y``}`;
  }
};
Lr.styles = T`
    :host {
      position: relative;
      grid-area: Data;
      display: grid;
      min-height: 2.25rem;
    }

    ::slotted(.branch.branch-vertical) {
      top: 50%;
      bottom: 0;
    }
  `;
var le = Lr;
Ve([
  m({ attribute: false })
], le.prototype, "columns");
Ve([
  m({ attribute: false })
], le.prototype, "hiddenColumns");
Ve([
  m({ attribute: false })
], le.prototype, "data");
Ve([
  m({ type: Boolean, attribute: "is-header", reflect: true })
], le.prototype, "isHeader");
Ve([
  Me()
], le.prototype, "_intersecting");
var tc = Object.defineProperty;
var ec = Object.getOwnPropertyDescriptor;
var ce = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? ec(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && tc(t, e, n), n;
};
var zr = class extends k {
  constructor() {
    super(...arguments), this._columnsChange = new Event("columnschange"), this._filteredData = [], this.headersHidden = false, this.minColWidth = "4rem", this._columns = [], this._textDelimiters = {
      comma: ",",
      tab: "	"
    }, this._queryString = null, this._data = [], this.expanded = false, this.preserveStructureOnFilter = false, this.indentationInText = false, this.dataTransform = {}, this._onColumnsHidden = new Event("columnshidden"), this._hiddenColumns = [], this._stringFilterFunction = (t, e) => Object.values(e.data).some((s) => String(s).toLowerCase().includes(t.toLowerCase())), this._queryFilterFunction = (t, e) => {
      let s = false;
      const n = Ki(t) ?? [];
      for (const r of n) {
        if ("queries" in r) {
          s = false;
          break;
        }
        const { condition: o, value: a } = r;
        let { key: l } = r;
        if (l.startsWith("[") && l.endsWith("]")) {
          const u = l.replace("[", "").replace("]", "");
          l = u, s = Object.keys(e.data).filter((h) => h.includes(u)).map(
            (h) => as(e.data[h], o, a)
          ).some((h) => h);
        } else
          s = as(e.data[l], o, a);
        if (!s)
          break;
      }
      return s;
    };
  }
  set columns(t) {
    const e = [];
    for (const s of t) {
      const n = typeof s == "string" ? { name: s, width: `minmax(${this.minColWidth}, 1fr)` } : s;
      e.push(n);
    }
    this._columns = e, this.computeMissingColumns(this.data), this.dispatchEvent(this._columnsChange);
  }
  get columns() {
    return this._columns;
  }
  get _headerRowData() {
    const t = {};
    for (const e of this.columns)
      if (typeof e == "string")
        t[e] = e;
      else {
        const { name: s } = e;
        t[s] = s;
      }
    return t;
  }
  /**
   * Getter for the `value` property.
   * Returns the filtered data if a search string is provided, otherwise returns the original data.
   *
   * @example
   * ```typescript
   * const tableValue = table.value;
   * console.log(tableValue); // Output: The filtered or original data.
   * ```
   */
  get value() {
    return this._filteredData;
  }
  /**
   * Sets the search string for filtering the table data.
   * This property allows you to filter the table data based on a search string.
   * If a search string is provided, the table will only display rows that match the search criteria.
   * The search criteria can be a simple string or a complex query.
   * If a simple string is provided, the table will filter rows based on the string's presence in any column.
   * If a complex query is provided, the table will filter rows based on the query's conditions and values.
   *
   * @example
   * ```typescript
   * table.queryString = "example";
   * ```
   *
   * @example
   * ```typescript
   * table.queryString = "column1="Jhon Doe" & column2=20";
   * ```
   */
  set queryString(t) {
    this._queryString = t && t.trim() !== "" ? t.trim() : null, this.updateFilteredData();
  }
  get queryString() {
    return this._queryString;
  }
  set data(t) {
    this._data = t, this.updateFilteredData(), this.computeMissingColumns(t) && (this.columns = this._columns);
  }
  get data() {
    return this._data;
  }
  get dataAsync() {
    return new Promise((t) => {
      setTimeout(() => {
        t(this.data);
      });
    });
  }
  set hiddenColumns(t) {
    this._hiddenColumns = t, setTimeout(() => {
      this.dispatchEvent(this._onColumnsHidden);
    });
  }
  get hiddenColumns() {
    return this._hiddenColumns;
  }
  updateFilteredData() {
    this.queryString ? (Ki(this.queryString) ? (this.filterFunction = this._queryFilterFunction, this._filteredData = this.filter(this.queryString)) : (this.filterFunction = this._stringFilterFunction, this._filteredData = this.filter(this.queryString)), this.preserveStructureOnFilter && (this._expandedBeforeFilter === void 0 && (this._expandedBeforeFilter = this.expanded), this.expanded = true)) : (this.preserveStructureOnFilter && this._expandedBeforeFilter !== void 0 && (this.expanded = this._expandedBeforeFilter, this._expandedBeforeFilter = void 0), this._filteredData = this.data);
  }
  computeMissingColumns(t) {
    let e = false;
    for (const s of t) {
      const { children: n, data: r } = s;
      for (const o in r)
        this._columns.map((a) => typeof a == "string" ? a : a.name).includes(o) || (this._columns.push({
          name: o,
          width: `minmax(${this.minColWidth}, 1fr)`
        }), e = true);
      if (n) {
        const o = this.computeMissingColumns(n);
        o && !e && (e = o);
      }
    }
    return e;
  }
  generateText(t = "comma", e = this.value, s = "", n = true) {
    const r = this._textDelimiters[t];
    let o = "";
    const a = this.columns.map((l) => l.name);
    if (n) {
      this.indentationInText && (o += `Indentation${r}`);
      const l = `${a.join(r)}
`;
      o += l;
    }
    for (const [l, u] of e.entries()) {
      const { data: h, children: d } = u, c = this.indentationInText ? `${s}${l + 1}${r}` : "", p = a.map((x) => h[x] ?? ""), v = `${c}${p.join(r)}
`;
      o += v, d && (o += this.generateText(
        t,
        u.children,
        `${s}${l + 1}.`,
        false
      ));
    }
    return o;
  }
  /**
   * A getter function that generates a CSV (Comma Separated Values) representation of the table data.
   *
   * @returns A string containing the CSV representation of the table data.
   *
   * @example
   * ```typescript
   * const csvData = table.csv;
   * console.log(csvData); // Output: "Column 1,Column 2\nValue 1,Value 2\nValue 3,Value 4"
   * ```
   */
  get csv() {
    return this.generateText("comma");
  }
  /**
   * A getter function that generates a Tab Separated Values (TSV) representation of the table data.
   *
   * @returns A string containing the TSV representation of the table data.
   *
   * @example
   * ```typescript
   * const tsvData = table.tsv;
   * console.log(tsvData); // Output: "Column 1\tColumn 2\nValue 1\tValue 2\nValue 3\tValue 4"
   * ```
   */
  get tsv() {
    return this.generateText("tab");
  }
  computeRowDeclaration(t) {
    const e = {};
    for (const s in t) {
      const n = this.dataTransform[s];
      n ? e[s] = n(t[s], t) : e[s] = t[s];
    }
    return e;
  }
  /**
   * The `downloadData` method is used to download the table data in different formats.
   *
   * @param fileName - The name of the downloaded file. Default is "BIM Table Data".
   * @param format - The format of the downloaded file. Can be "json", "tsv", or "csv". Default is "json".
   *
   * @returns - This method does not return any value.
   *
   * @example
   * ```typescript
   * table.downloadData("MyTableData", "tsv");
   * ```
   */
  downloadData(t = "BIM Table Data", e = "json") {
    let s = null;
    if (e === "json" && (s = new File(
      [JSON.stringify(this.value, void 0, 2)],
      `${t}.json`
    )), e === "csv" && (s = new File([this.csv], `${t}.csv`)), e === "tsv" && (s = new File([this.tsv], `${t}.tsv`)), !s)
      return;
    const n = document.createElement("a");
    n.href = URL.createObjectURL(s), n.download = s.name, n.click(), URL.revokeObjectURL(n.href);
  }
  getRowIndentation(t, e = this.value, s = 0) {
    for (const n of e) {
      if (n.data === t)
        return s;
      if (n.children) {
        const r = this.getRowIndentation(
          t,
          n.children,
          s + 1
        );
        if (r !== null)
          return r;
      }
    }
    return null;
  }
  getGroupIndentation(t, e = this.value, s = 0) {
    for (const n of e) {
      if (n === t)
        return s;
      if (n.children) {
        const r = this.getGroupIndentation(
          t,
          n.children,
          s + 1
        );
        if (r !== null)
          return r;
      }
    }
    return null;
  }
  connectedCallback() {
    super.connectedCallback(), this.dispatchEvent(new Event("connected"));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.dispatchEvent(new Event("disconnected"));
  }
  filter(t, e = this.filterFunction ?? this._stringFilterFunction, s = this.data) {
    const n = [];
    for (const r of s)
      if (e(t, r)) {
        if (this.preserveStructureOnFilter) {
          const o = { data: r.data };
          if (r.children) {
            const a = this.filter(
              t,
              e,
              r.children
            );
            a.length && (o.children = a);
          }
          n.push(o);
        } else if (n.push({ data: r.data }), r.children) {
          const o = this.filter(
            t,
            e,
            r.children
          );
          n.push(...o);
        }
      } else if (r.children) {
        const o = this.filter(
          t,
          e,
          r.children
        );
        this.preserveStructureOnFilter && o.length ? n.push({
          data: r.data,
          children: o
        }) : n.push(...o);
      }
    return n;
  }
  render() {
    const t = document.createElement("bim-table-row");
    t.table = this, t.isHeader = true, t.data = this._headerRowData, t.style.gridArea = "Header", t.style.position = "sticky", t.style.top = "0", t.style.zIndex = "5";
    const e = document.createElement("bim-table-children");
    return e.table = this, e.data = this.value, e.style.gridArea = "Body", e.style.backgroundColor = "transparent", y`
      <div class="parent">
        ${this.headersHidden ? null : t}
        <div style="overflow-x: hidden; grid-area: Body">${e}</div>
      </div>
    `;
  }
};
zr.styles = [
  jt.scrollbar,
  T`
      :host {
        --bim-button--bgc: transparent;
        position: relative;
        overflow: auto;
        display: block;
        pointer-events: auto;
      }

      .parent {
        display: grid;
        grid-template:
          "Header" auto
          "Body" 1fr
          "Footer" auto;
        overflow: auto;
        height: 100%;
      }

      .parent > bim-table-row[is-header] {
        color: var(--bim-table_header--c, var(--bim-ui_bg-contrast-100));
        background-color: var(
          --bim-table_header--bgc,
          var(--bim-ui_bg-contrast-20)
        );
      }

      .controls {
        display: flex;
        gap: 0.375rem;
        flex-wrap: wrap;
        margin-bottom: 0.5rem;
      }
    `
];
var Ht = zr;
ce([
  Me()
], Ht.prototype, "_filteredData", 2);
ce([
  m({
    type: Boolean,
    attribute: "headers-hidden",
    reflect: true
  })
], Ht.prototype, "headersHidden", 2);
ce([
  m({ type: String, attribute: "min-col-width", reflect: true })
], Ht.prototype, "minColWidth", 2);
ce([
  m({ type: Array, attribute: false })
], Ht.prototype, "columns", 1);
ce([
  m({ type: Array, attribute: false })
], Ht.prototype, "data", 1);
ce([
  m({ type: Boolean, reflect: true })
], Ht.prototype, "expanded", 2);
var ic = Object.defineProperty;
var nc = Object.getOwnPropertyDescriptor;
var _i = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? nc(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && ic(t, e, n), n;
};
var Dr = class extends k {
  constructor() {
    super(...arguments), this._defaultName = "__unnamed__", this.name = this._defaultName, this._hidden = false;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  connectedCallback() {
    super.connectedCallback();
    const { parentElement: t } = this;
    if (t && this.name === this._defaultName) {
      const e = [...t.children].indexOf(this);
      this.name = `${this._defaultName}${e}`;
    }
  }
  render() {
    return y` <slot></slot> `;
  }
};
Dr.styles = T`
    :host {
      display: block;
      height: 100%;
    }

    :host([hidden]) {
      display: none;
    }
  `;
var Y = Dr;
_i([
  m({ type: String, reflect: true })
], Y.prototype, "name", 2);
_i([
  m({ type: String, reflect: true })
], Y.prototype, "label", 2);
_i([
  m({ type: String, reflect: true })
], Y.prototype, "icon", 2);
_i([
  m({ type: Boolean, reflect: true })
], Y.prototype, "hidden", 1);
var sc = Object.defineProperty;
var rc = Object.getOwnPropertyDescriptor;
var ue = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? rc(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && sc(t, e, n), n;
};
var jr = class extends k {
  constructor() {
    super(...arguments), this._switchers = [], this.bottom = false, this.switchersHidden = false, this.floating = false, this.switchersFull = false, this.onTabHiddenChange = (t) => {
      const e = t.target;
      e instanceof Y && !e.hidden && (e.removeEventListener("hiddenchange", this.onTabHiddenChange), this.tab = e.name, e.addEventListener("hiddenchange", this.onTabHiddenChange));
    };
  }
  set tab(t) {
    this._tab = t;
    const e = [...this.children], s = e.find(
      (n) => n instanceof Y && n.name === t
    );
    for (const n of e) {
      if (!(n instanceof Y))
        continue;
      n.hidden = s !== n;
      const r = this.getTabSwitcher(n.name);
      r && r.toggleAttribute("data-active", !n.hidden);
    }
  }
  get tab() {
    return this._tab;
  }
  getTabSwitcher(t) {
    return this._switchers.find(
      (e) => e.getAttribute("data-name") === t
    );
  }
  createSwitchers() {
    this._switchers = [];
    for (const t of this.children) {
      if (!(t instanceof Y))
        continue;
      const e = document.createElement("div");
      e.addEventListener("click", () => {
        this.tab === t.name ? this.toggleAttribute("tab", false) : this.tab = t.name;
      }), e.setAttribute("data-name", t.name), e.className = "switcher";
      const s = document.createElement("bim-label");
      s.textContent = t.label ?? "", s.icon = t.icon, e.append(s), this._switchers.push(e);
    }
  }
  onSlotChange(t) {
    this.createSwitchers();
    const e = t.target.assignedElements(), s = e.find((n) => n instanceof Y ? this.tab ? n.name === this.tab : !n.hidden : false);
    s && s instanceof Y && (this.tab = s.name);
    for (const n of e) {
      if (!(n instanceof Y)) {
        n.remove();
        continue;
      }
      n.removeEventListener("hiddenchange", this.onTabHiddenChange), s !== n && (n.hidden = true), n.addEventListener("hiddenchange", this.onTabHiddenChange);
    }
  }
  render() {
    return y`
      <div class="parent">
        <div class="switchers">${this._switchers}</div>
        <div class="content">
          <slot @slotchange=${this.onSlotChange}></slot>
        </div>
      </div>
    `;
  }
};
jr.styles = [
  jt.scrollbar,
  T`
      * {
        box-sizing: border-box;
      }

      :host {
        background-color: var(--bim-ui_bg-base);
        display: block;
        overflow: auto;
      }

      .parent {
        display: grid;
        grid-template: "switchers" auto "content" 1fr;
        height: 100%;
      }

      :host([bottom]) .parent {
        grid-template: "content" 1fr "switchers" auto;
      }

      .switchers {
        display: flex;
        height: 2.25rem;
        font-weight: 600;
        grid-area: switchers;
      }

      .switcher {
        --bim-label--c: var(--bim-ui_bg-contrast-80);
        background-color: var(--bim-ui_bg-base);
        cursor: pointer;
        pointer-events: auto;
        padding: 0rem 0.75rem;
        display: flex;
        justify-content: center;
      }

      :host([switchers-full]) .switcher {
        flex: 1;
      }

      .switcher:hover,
      .switcher[data-active] {
        --bim-label--c: var(--bim-ui_main-contrast);
        background-color: var(--bim-ui_main-base);
      }

      .switchers bim-label {
        pointer-events: none;
      }

      :host([switchers-hidden]) .switchers {
        display: none;
      }

      .content {
        grid-area: content;
        overflow: auto;
      }

      :host(:not([bottom])) .content {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([bottom]) .content {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host(:not([tab])) .content {
        display: none;
      }

      :host([floating]) {
        background-color: transparent;
      }

      :host([floating]) .switchers {
        justify-self: center;
        overflow: auto;
      }

      :host([floating]:not([bottom])) .switchers {
        border-radius: var(--bim-ui_size-2xs) var(--bim-ui_size-2xs) 0 0;
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom]) .switchers {
        border-radius: 0 0 var(--bim-ui_size-2xs) var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]:not([tab])) .switchers {
        border-radius: var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom]:not([tab])) .switchers {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]) .content {
        border: 1px solid var(--bim-ui_bg-contrast-20);
        border-radius: var(--bim-ui_size-2xs);
        background-color: var(--bim-ui_bg-base);
      }
    `
];
var Ft = jr;
ue([
  Me()
], Ft.prototype, "_switchers", 2);
ue([
  m({ type: Boolean, reflect: true })
], Ft.prototype, "bottom", 2);
ue([
  m({ type: Boolean, attribute: "switchers-hidden", reflect: true })
], Ft.prototype, "switchersHidden", 2);
ue([
  m({ type: Boolean, reflect: true })
], Ft.prototype, "floating", 2);
ue([
  m({ type: String, reflect: true })
], Ft.prototype, "tab", 1);
ue([
  m({ type: Boolean, attribute: "switchers-full", reflect: true })
], Ft.prototype, "switchersFull", 2);
var oc = (i) => i ?? M;
var ac = Object.defineProperty;
var lc = Object.getOwnPropertyDescriptor;
var At = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? lc(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && ac(t, e, n), n;
};
var Hr = class extends k {
  constructor() {
    super(...arguments), this._inputTypes = [
      "date",
      "datetime-local",
      "email",
      "month",
      "password",
      "search",
      "tel",
      "text",
      "time",
      "url",
      "week"
    ], this.value = "", this.vertical = false, this._type = "text", this.onValueChange = new Event("input");
  }
  set type(t) {
    this._inputTypes.includes(t) && (this._type = t);
  }
  get type() {
    return this._type;
  }
  /**
   * Gets the query value derived from the current input value.
   * The `getQuery` function is assumed to be a utility function that takes a string as input
   * and returns a processed query value based on the input.
   *
   * @returns The processed query value derived from the current input value.
   *
   * @example
   * ```typescript
   * const textInput = new TextInput();
   * textInput.value = "Key?Value";
   * console.log(textInput.query);
   * ```
   */
  get query() {
    return Ki(this.value);
  }
  onInputChange(t) {
    t.stopPropagation();
    const e = t.target;
    clearTimeout(this._debounceTimeoutID), this._debounceTimeoutID = setTimeout(() => {
      this.value = e.value, this.dispatchEvent(this.onValueChange);
    }, this.debounce);
  }
  focus() {
    setTimeout(() => {
      var t;
      const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector("input");
      e == null || e.focus();
    });
  }
  render() {
    return y`
      <bim-input
        .name=${this.name}
        .icon=${this.icon}
        .label=${this.label}
        .vertical=${this.vertical}
      >
        <input
          aria-label=${this.label || this.name || "Text Input"}
          .type=${this.type}
          .value=${this.value}
          placeholder=${oc(this.placeholder)}
          @input=${this.onInputChange}
        />
      </bim-input>
    `;
  }
};
Hr.styles = T`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      flex: 1;
      display: block;
    }

    input {
      background-color: transparent;
      outline: none;
      border: none;
      width: 100%;
      height: 100%;
      padding: 0 var(--bim-ui_size-3xs);
      border-radius: var(--bim-text-input--bdrs, var(--bim-ui_size-4xs));
      color: var(--bim-text-input--c, var(--bim-ui_bg-contrast-100));
    }

    :host(:focus) {
      --bim-input--olc: var(--bim-ui_accent-base);
    }

    /* :host([disabled]) {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
    } */
  `;
var ut = Hr;
At([
  m({ type: String, reflect: true })
], ut.prototype, "icon", 2);
At([
  m({ type: String, reflect: true })
], ut.prototype, "label", 2);
At([
  m({ type: String, reflect: true })
], ut.prototype, "name", 2);
At([
  m({ type: String, reflect: true })
], ut.prototype, "placeholder", 2);
At([
  m({ type: String, reflect: true })
], ut.prototype, "value", 2);
At([
  m({ type: Boolean, reflect: true })
], ut.prototype, "vertical", 2);
At([
  m({ type: Number, reflect: true })
], ut.prototype, "debounce", 2);
At([
  m({ type: String, reflect: true })
], ut.prototype, "type", 1);
var cc = Object.defineProperty;
var uc = Object.getOwnPropertyDescriptor;
var Fr = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? uc(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && cc(t, e, n), n;
};
var Br = class extends k {
  constructor() {
    super(...arguments), this.rows = 2, this._vertical = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      this.vertical ? e.setAttribute("label-hidden", "") : e.removeAttribute("label-hidden");
  }
  render() {
    return y`
      <style>
        .parent {
          grid-auto-flow: ${this.vertical ? "row" : "column"};
          grid-template-rows: repeat(${this.rows}, 1fr);
        }
      </style>
      <div class="parent">
        <slot @slotchange=${this.updateChildren}></slot>
      </div>
    `;
  }
};
Br.styles = T`
    .parent {
      display: grid;
      gap: 0.25rem;
    }

    ::slotted(bim-button[label]:not([vertical])) {
      --bim-button--jc: flex-start;
    }

    ::slotted(bim-button) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
    }
  `;
var xi = Br;
Fr([
  m({ type: Number, reflect: true })
], xi.prototype, "rows", 2);
Fr([
  m({ type: Boolean, reflect: true })
], xi.prototype, "vertical", 1);
var hc = Object.defineProperty;
var dc = Object.getOwnPropertyDescriptor;
var wi = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? dc(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && hc(t, e, n), n;
};
var Ur = class extends k {
  constructor() {
    super(...arguments), this._vertical = false, this._labelHidden = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  set labelHidden(t) {
    this._labelHidden = t, this.updateChildren();
  }
  get labelHidden() {
    return this._labelHidden;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      e instanceof xi && (e.vertical = this.vertical), e.toggleAttribute("label-hidden", this.vertical);
  }
  render() {
    return y`
      <div class="parent">
        <div class="children">
          <slot @slotchange=${this.updateChildren}></slot>
        </div>
        ${!this.labelHidden && (this.label || this.icon) ? y`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
      </div>
    `;
  }
};
Ur.styles = T`
    :host {
      --bim-label--fz: var(--bim-ui_size-xs);
      --bim-label--c: var(--bim-ui_bg-contrast-60);
      display: block;
      flex: 1;
    }

    :host(:not([vertical])) ::slotted(bim-button[vertical]) {
      --bim-icon--fz: var(--bim-ui_size-5xl);
      min-height: 3.75rem;
    }

    ::slotted(bim-button) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
    }

    .parent {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: center;
      padding: 0.5rem;
      height: 100%;
      box-sizing: border-box;
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: row-reverse;
    }

    :host([vertical]) .parent > bim-label {
      writing-mode: tb;
    }

    .children {
      display: flex;
      gap: 0.25rem;
    }

    :host([vertical]) .children {
      flex-direction: column;
    }
  `;
var he = Ur;
wi([
  m({ type: String, reflect: true })
], he.prototype, "label", 2);
wi([
  m({ type: String, reflect: true })
], he.prototype, "icon", 2);
wi([
  m({ type: Boolean, reflect: true })
], he.prototype, "vertical", 1);
wi([
  m({ type: Boolean, attribute: "label-hidden", reflect: true })
], he.prototype, "labelHidden", 1);
var Vr = class S {
  static set config(t) {
    this._config = { ...S._config, ...t };
  }
  static get config() {
    return S._config;
  }
  static addGlobalStyles() {
    let t = document.querySelector("style[id='bim-ui']");
    if (t)
      return;
    t = document.createElement("style"), t.id = "bim-ui", t.textContent = jt.globalStyles.cssText;
    const e = document.head.firstChild;
    e ? document.head.insertBefore(t, e) : document.head.append(t);
  }
  static defineCustomElement(t, e) {
    customElements.get(t) || customElements.define(t, e);
  }
  /**
   * @deprecated Use `Manager.init()` instead.
   */
  static registerComponents() {
    S.init();
  }
  /**
   * Initializes the BIM UI library by defining custom elements.
   * It ensures that all necessary styles and custom elements are registered for use in BIM UI components.
   *
   * @example
   * ```typescript
   * import { Manager } from "@thatopen/ui";
   * Manager.init();
   * ```
   */
  static init() {
    S.addGlobalStyles(), S.defineCustomElement("bim-button", Cl), S.defineCustomElement("bim-checkbox", ie), S.defineCustomElement("bim-color-input", Dt), S.defineCustomElement("bim-context-menu", yr), S.defineCustomElement("bim-dropdown", ct), S.defineCustomElement("bim-grid", bn), S.defineCustomElement("bim-icon", Dl), S.defineCustomElement("bim-input", je), S.defineCustomElement("bim-label", se), S.defineCustomElement("bim-number-input", W), S.defineCustomElement("bim-option", D), S.defineCustomElement("bim-panel", re), S.defineCustomElement("bim-panel-section", oe), S.defineCustomElement("bim-selector", ae), S.defineCustomElement("bim-table", Ht), S.defineCustomElement("bim-tabs", Ft), S.defineCustomElement("bim-tab", Y), S.defineCustomElement("bim-table-cell", Ir), S.defineCustomElement("bim-table-children", Rr), S.defineCustomElement("bim-table-group", Mr), S.defineCustomElement("bim-table-row", le), S.defineCustomElement("bim-text-input", ut), S.defineCustomElement("bim-toolbar", $i), S.defineCustomElement("bim-toolbar-group", xi), S.defineCustomElement(
      "bim-toolbar-section",
      he
    ), S.defineCustomElement("bim-viewport", qr);
  }
  static newRandomId() {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let e = "";
    for (let s = 0; s < 10; s++) {
      const n = Math.floor(Math.random() * t.length);
      e += t.charAt(n);
    }
    return e;
  }
};
Vr._config = {
  sectionLabelOnVerticalToolbar: false
  // draggableToolbars: true,
  // draggablePanels: true,
};
var tn = Vr;
var pc = Object.defineProperty;
var fc = Object.getOwnPropertyDescriptor;
var gn2 = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? fc(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && pc(t, e, n), n;
};
var Wr = class extends k {
  constructor() {
    super(...arguments), this.labelsHidden = false, this._vertical = false, this._hidden = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateSections();
  }
  get vertical() {
    return this._vertical;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  // private setActivationButton() {
  //   this.activationButton.draggable = Manager.config.draggableToolbars;
  //   this.activationButton.addEventListener(
  //     "click",
  //     () => (this.hidden = !this.hidden),
  //   );
  //   this.activationButton.setAttribute("data-ui-manager-id", this._managerID);
  //   this.activationButton.addEventListener("dragstart", (e) => {
  //     const id = this.getAttribute("data-ui-manager-id");
  //     if (e.dataTransfer && id) {
  //       e.dataTransfer.setData("id", id);
  //       e.dataTransfer.effectAllowed = "move";
  //     }
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       if (container === this.parentElement) continue;
  //       container.dropping = true;
  //     }
  //   });
  //   this.activationButton.addEventListener("dragend", (e) => {
  //     if (e.dataTransfer) e.dataTransfer.clearData();
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       container.dropping = false;
  //     }
  //   });
  // }
  updateSections() {
    const t = this.children;
    for (const e of t)
      e instanceof he && (e.labelHidden = this.vertical && !tn.config.sectionLabelOnVerticalToolbar, e.vertical = this.vertical);
  }
  // firstUpdated() {
  //   this.setAttribute("data-ui-manager-id", this._managerID);
  // }
  render() {
    return y`
      <div class="parent">
        <slot @slotchange=${this.updateSections}></slot>
      </div>
    `;
  }
};
Wr.styles = T`
    :host {
      --bim-button--bgc: transparent;
      background-color: var(--bim-ui_bg-base);
      border-radius: var(--bim-ui_size-2xs);
      display: block;
    }

    :host([hidden]) {
      display: none;
    }

    .parent {
      display: flex;
      width: min-content;
      pointer-events: auto;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    :host([vertical]) {
      width: min-content;
      border-radius: var(--bim-ui_size-2xs);
      border: 1px solid var(--bim-ui_bg-contrast-20);
    }

    ::slotted(bim-toolbar-section:not(:last-child)) {
      border-right: 1px solid var(--bim-ui_bg-contrast-20);
      border-bottom: none;
    }

    :host([vertical]) ::slotted(bim-toolbar-section:not(:last-child)) {
      border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      border-right: none;
    }
  `;
var $i = Wr;
gn2([
  m({ type: String, reflect: true })
], $i.prototype, "icon", 2);
gn2([
  m({ type: Boolean, attribute: "labels-hidden", reflect: true })
], $i.prototype, "labelsHidden", 2);
gn2([
  m({ type: Boolean, reflect: true })
], $i.prototype, "vertical", 1);
var mc = Object.defineProperty;
var bc = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && mc(t, e, n), n;
};
var Gr = class extends k {
  constructor() {
    super(), this._onResize = new Event("resize"), new ResizeObserver(() => {
      setTimeout(() => {
        this.dispatchEvent(this._onResize);
      });
    }).observe(this);
  }
  render() {
    return y`
      <div class="parent">
        <slot></slot>
      </div>
    `;
  }
};
Gr.styles = T`
    :host {
      display: grid;
      min-width: 0;
      min-height: 0;
      height: 100%;
    }

    .parent {
      overflow: hidden;
      position: relative;
    }
  `;
var qr = Gr;
bc([
  m({ type: String, reflect: true })
], qr.prototype, "name");
var gc = (i) => {
  const { components: t } = i, e = t.get(Ri);
  return y`
    <bim-button
      data-ui-id="import-ifc"
      label="Load IFC"
      icon="mage:box-3d-fill"
      @click=${() => {
    const n = document.createElement("input");
    n.type = "file", n.accept = ".ifc", n.onchange = async () => {
      if (n.files === null || n.files.length === 0)
        return;
      const r = n.files[0];
      n.remove();
      const o = await r.arrayBuffer(), a = new Uint8Array(o), l = await e.load(a);
      l.name = r.name.replace(".ifc", "");
    }, n.click();
  }}
    ></bim-button>
  `;
};
var vc = (i) => $t.create(
  gc,
  i
);
var yc = Object.freeze(Object.defineProperty({
  __proto__: null,
  loadIfc: vc
}, Symbol.toStringTag, { value: "Module" }));
var nh = {
  ...yc
  // fragmentExploder,
};
var _c = (i) => {
  const { components: t } = i, e = i.schemaTag ?? true, s = i.viewDefinitionTag ?? true, n = t.get(ht), r = document.createElement("bim-table");
  r.addEventListener("cellcreated", ({ detail: a }) => {
    const { cell: l } = a;
    l.style.padding = "0.25rem 0";
  }), r.hiddenColumns = ["modelID"], r.headersHidden = true;
  const o = [];
  for (const [, a] of n.groups) {
    if (!a)
      continue;
    const l = {
      data: {
        Name: a.name || a.uuid,
        modelID: a.uuid
      }
    };
    o.push(l);
  }
  return r.dataTransform = {
    Name: (a, l) => {
      const { modelID: u } = l;
      if (typeof u != "string")
        return a;
      const h = n.groups.get(u);
      if (!h)
        return u;
      const d = {};
      for (const f of h.items)
        d[f.id] = f.ids;
      let c;
      const { schema: p } = h.ifcMetadata;
      e && p && (c = y`
          <bim-label style="background-color: var(--bim-ui_main-base); padding: 0 0.25rem; color: var(--bim-ui_main-contrast); border-radius: 0.25rem;">${p}</bim-label>
          `);
      let v;
      if (s && "viewDefinition" in h.ifcMetadata) {
        const f = h.ifcMetadata.viewDefinition;
        v = y`
          ${f.split(",").map((b) => y`<bim-label style="background-color: var(--bim-ui_main-base); padding: 0 0.25rem; color: var(--bim-ui_main-contrast); border-radius: 0.25rem;">${b}</bim-label>`)}
        `;
      }
      return y`
       <div style="display: flex; flex: 1; gap: var(--bim-ui_size-4xs); justify-content: space-between; overflow: auto;">
        <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 0 var(--bim-ui_size-4xs); flex-grow: 1; overflow: auto;">
          <div style="min-height: 1.75rem; overflow: auto; display: flex;">
            <bim-label style="white-space: normal;">${a}</bim-label>
          </div>
          <div style="display: flex; flex-wrap: wrap; gap: var(--bim-ui_size-4xs); overflow: auto;">
            ${c}
            ${v}
          </div>
        </div>
        <div style="display: flex; align-self: flex-start; flex-shrink: 0;">
          <bim-button @click=${() => {
        const f = document.createElement("input");
        f.type = "file", f.accept = ".ifc", f.multiple = false, f.addEventListener("change", async () => {
          if (!(f.files && f.files.length === 1))
            return;
          const b = f.files[0], g = await b.arrayBuffer(), C = await t.get(gn).saveToIfc(
            h,
            new Uint8Array(g)
          ), A = new File([C], b.name), E = document.createElement("a");
          E.href = URL.createObjectURL(A), E.download = A.name, E.click(), URL.revokeObjectURL(E.href);
        }), f.click();
      }} icon="flowbite:download-solid"></bim-button>
          <bim-button @click=${(f) => {
        const b = t.get(Sn), g = f.target;
        b.set(g.hasAttribute("data-model-hidden"), d), g.toggleAttribute("data-model-hidden"), g.icon = g.hasAttribute("data-model-hidden") ? "mdi:eye-off" : "mdi:eye";
      }} icon="mdi:eye"></bim-button>
          <bim-button @click=${() => n.disposeGroup(h)} icon="mdi:delete"></bim-button>
        </div>
       </div>
      `;
    }
  }, r.data = o, y`
    <div>
      ${o.length === 0 ? y`<bim-label>No models has been loaded yet</bim-label>` : r}
    </div>
  `;
};
var xc = (i, t = true) => {
  const e = $t.create(
    _c,
    i
  );
  if (t) {
    const { components: s } = i, n = s.get(ht), [, r] = e;
    n.onFragmentsLoaded.add(() => setTimeout(() => r())), n.onFragmentsDisposed.add(() => r());
  }
  return e;
};
var wc = Object.freeze(Object.defineProperty({
  __proto__: null,
  modelsList: xc
}, Symbol.toStringTag, { value: "Module" }));
var Yr = [
  "Name",
  "ContainedInStructure",
  "ForLayerSet",
  "LayerThickness",
  "HasProperties",
  "HasAssociations",
  "HasAssignments",
  "HasPropertySets",
  "PredefinedType",
  "Quantities",
  "ReferencedSource",
  "Identification",
  (i) => i.includes("Value"),
  (i) => i.startsWith("Material"),
  (i) => i.startsWith("Relating"),
  (i) => {
    const t = ["IsGroupedBy", "IsDecomposedBy"];
    return i.startsWith("Is") && !t.includes(i);
  }
];
async function Ke(i, t, e, s = Yr, n = false) {
  const r = i.get(pe), o = await t.getProperties(e);
  if (!o)
    return {
      data: { Entity: `${e} properties not found...` }
      // onRowCreated(row) {
      //   row.addEventListener("cellcreated", (event) => {
      //     if (!(event instanceof CustomEvent)) return;
      //     const { cell } = event.detail;
      //     cell.style.gridColumn = "1 / -1";
      //   });
      // },
    };
  const a = r.relationMaps[t.uuid], l = {
    data: {}
  };
  for (const u in o) {
    const h = s.map((c) => typeof c == "string" ? u === c : c(u)).includes(true);
    if (!(u === "type" || h))
      continue;
    const d = o[u];
    if (d)
      if (d.type === 5) {
        l.children || (l.children = []);
        const c = await Ke(
          i,
          t,
          d.value,
          s,
          n
        );
        l.children.push(c);
      } else if (typeof d == "object" && !Array.isArray(d)) {
        const { value: c, type: p } = d;
        if (n)
          p === 1 || p === 2 || p === 3 || (l.data[u] = c);
        else {
          const v = typeof c == "number" ? Number(c.toFixed(3)) : c;
          l.data[u] = v;
        }
      } else if (Array.isArray(d))
        for (const c of d) {
          if (c.type !== 5)
            continue;
          l.children || (l.children = []);
          const p = await Ke(
            i,
            t,
            c.value,
            s,
            n
          );
          l.children.push(p);
        }
      else if (u === "type") {
        const c = Bn[d];
        l.data.Entity = c;
      } else
        l.data[u] = d;
  }
  if (a && a.get(o.expressID)) {
    const u = a.get(o.expressID);
    for (const h of s) {
      const d = [];
      if (typeof h == "string") {
        const c = r._inverseAttributes.indexOf(
          h
        );
        c !== -1 && d.push(c);
      } else {
        const c = r._inverseAttributes.filter(
          (p) => h(p)
        );
        for (const p of c) {
          const v = r._inverseAttributes.indexOf(p);
          d.push(v);
        }
      }
      for (const c of d) {
        const p = u.get(c);
        if (p)
          for (const v of p) {
            const x = await Ke(
              i,
              t,
              v,
              s,
              n
            );
            l.children || (l.children = []), l.children.push(x);
          }
      }
    }
  }
  return l;
}
var $c = (i) => {
  const {
    components: t,
    fragmentIdMap: e,
    attributesToInclude: s,
    editable: n,
    tableDefinition: r
  } = i, o = t.get(ht);
  let a;
  return typeof s == "function" ? a = s(Yr) : a = s, y`<bim-table ${ot(async (u) => {
    if (!u)
      return;
    const h = u, d = [], c = [];
    for (const p in e) {
      const v = o.list.get(p);
      if (!(v && v.group))
        continue;
      const x = v.group, _ = c.find((w) => w.model === x);
      if (_)
        for (const w of e[p])
          _.expressIDs.add(w);
      else {
        const w = { model: x, expressIDs: new Set(e[p]) };
        c.push(w);
      }
    }
    for (const p of c) {
      const { model: v, expressIDs: x } = p;
      for (const _ of x) {
        const w = await Ke(
          t,
          v,
          _,
          a,
          n
        );
        d.push(w);
      }
    }
    h.dataTransform = r, h.data = d, h.columns = [{ name: "Entity", width: "minmax(15rem, 1fr)" }];
  })}></bim-table>`;
};
var Cc = (i) => $t.create(
  $c,
  i
);
var Ec = Object.freeze(Object.defineProperty({
  __proto__: null,
  entityAttributes: Cc
}, Symbol.toStringTag, { value: "Module" }));
function Ac(i) {
  const t = Object.keys(i).pop();
  return t && i[t].length > 0 ? i[t][0] : "";
}
function Xr(i) {
  return i.map((t) => {
    const e = {
      data: {
        System: Ac(t.filter)
        // Actions: JSON.stringify(node.filter),
      }
    };
    return t.children && t.children.length > 0 && (e.children = Xr(t.children)), e;
  });
}
var Sc2 = (i) => {
  const { components: t, classifications: e } = i, s = t.get(Ai), n = (r) => {
    if (!r)
      return;
    const o = r;
    o.dataTransform = {
      Actions: (u) => u
    };
    const a = (u, h = {}) => {
      const d = s.list, c = u[0], p = d[c], v = [];
      if (!c || !p)
        return v;
      for (const x in p) {
        const _ = { ...h, [c]: [x] }, w = s.find(_);
        if (Object.keys(w).length > 0) {
          const b = { filter: _ };
          b.children = a(u.slice(1), _), v.push(b);
        }
      }
      return v;
    }, l = [];
    for (const u in e) {
      const h = e[u], d = a(h), c = Xr(d);
      l.push({
        data: { System: u },
        children: c
      });
    }
    o.data = l;
  };
  return y`
  <div>
    ${Object.keys(e).length === 0 ? y`<bim-label label="No classifications to show"></bim-label>` : y`<bim-table ${ot(n)} headers-hidden expanded></bim-table>`}
  </div>
  `;
};
var kc = (i, t = true) => {
  const e = $t.create(
    Sc2,
    i
  );
  if (t) {
    const { components: s } = i, n = s.get(ht), [, r] = e;
    n.onFragmentsDisposed.add(() => r());
  }
  return e;
};
var Oc = Object.freeze(Object.defineProperty({
  __proto__: null,
  classificationTree: kc
}, Symbol.toStringTag, { value: "Module" }));
var Tc = ["OwnerHistory", "ObjectPlacement", "CompositionType"];
var ls = async (i, t, e) => {
  const n = { ...{
    groupName: "Attributes",
    includeClass: false
  }, ...e }, { groupName: r, includeClass: o } = n, a = await i.getProperties(t) ?? {}, l = { data: { Name: r } };
  o && (l.children || (l.children = []), l.children.push({
    data: {
      Name: "Class",
      Value: Bn[a.type]
    }
  }));
  for (const u in a) {
    if (Tc.includes(u))
      continue;
    const h = a[u];
    if (h && typeof h == "object" && !Array.isArray(h)) {
      if (h.type === REF)
        continue;
      const d = {
        data: { Name: u, Value: h.value }
      };
      l.children || (l.children = []), l.children.push(d);
    }
  }
  return l;
};
var Ic = async (i, t) => {
  const e = { data: { Name: "Property Sets" } };
  for (const s of t) {
    const n = await i.getProperties(s);
    if (!n)
      continue;
    const r = {
      data: { Name: n.Name.value }
    };
    if (n.type === IFCPROPERTYSET) {
      for (const o of n.HasProperties) {
        const { value: a } = o, l = await i.getProperties(a);
        if (!l)
          continue;
        const u = Object.keys(l).find(
          (d) => d.includes("Value")
        );
        if (!(u && l[u]))
          continue;
        const h = {
          data: {
            Name: l.Name.value,
            Value: l[u].value
          }
        };
        r.children || (r.children = []), r.children.push(h);
      }
      r.children && (e.children || (e.children = []), e.children.push(r));
    }
  }
  return e;
};
var Pc = async (i, t) => {
  const e = { data: { Name: "Quantity Sets" } };
  for (const s of t) {
    const n = await i.getProperties(s);
    if (!n)
      continue;
    const r = {
      data: { Name: n.Name.value }
    };
    if (n.type === IFCELEMENTQUANTITY) {
      for (const o of n.Quantities) {
        const { value: a } = o, l = await i.getProperties(a);
        if (!l)
          continue;
        const u = Object.keys(l).find(
          (d) => d.includes("Value")
        );
        if (!(u && l[u]))
          continue;
        const h = {
          data: {
            Name: l.Name.value,
            Value: l[u].value
          }
        };
        r.children || (r.children = []), r.children.push(h);
      }
      r.children && (e.children || (e.children = []), e.children.push(r));
    }
  }
  return e;
};
var Rc = async (i, t) => {
  const e = { data: { Name: "Materials" } };
  for (const s of t) {
    const n = await i.getProperties(s);
    if (n && n.type === IFCMATERIALLAYERSETUSAGE) {
      const r = n.ForLayerSet.value, o = await i.getProperties(r);
      if (!o)
        continue;
      for (const a of o.MaterialLayers) {
        const { value: l } = a, u = await i.getProperties(l);
        if (!u)
          continue;
        const h = await i.getProperties(
          u.Material.value
        );
        if (!h)
          continue;
        const d = {
          data: {
            Name: "Layer"
          },
          children: [
            {
              data: {
                Name: "Thickness",
                Value: u.LayerThickness.value
              }
            },
            {
              data: {
                Name: "Material",
                Value: h.Name.value
              }
            }
          ]
        };
        e.children || (e.children = []), e.children.push(d);
      }
    }
    if (n && n.type === IFCMATERIALLIST)
      for (const r of n.Materials) {
        const { value: o } = r, a = await i.getProperties(o);
        if (!a)
          continue;
        const l = {
          data: {
            Name: "Name",
            Value: a.Name.value
          }
        };
        e.children || (e.children = []), e.children.push(l);
      }
    if (n && n.type === IFCMATERIAL) {
      const r = await i.getProperties(s);
      if (!r)
        continue;
      const o = {
        data: {
          Name: "Name",
          Value: r.Name.value
        }
      };
      e.children || (e.children = []), e.children.push(o);
    }
  }
  return e;
};
var Nc = async (i, t) => {
  var s, n;
  const e = { data: { Name: "Classifications" } };
  for (const r of t) {
    const o = await i.getProperties(r);
    if (o && o.type === IFCCLASSIFICATIONREFERENCE) {
      const { value: a } = o.ReferencedSource, l = await i.getProperties(a);
      if (!l)
        continue;
      const u = {
        data: {
          Name: l.Name.value
        },
        children: [
          {
            data: {
              Name: "Identification",
              Value: ((s = o.Identification) == null ? void 0 : s.value) || ((n = o.ItemReference) == null ? void 0 : n.value)
            }
          },
          {
            data: {
              Name: "Name",
              Value: o.Name.value
            }
          }
        ]
      };
      e.children || (e.children = []), e.children.push(u);
    }
  }
  return e;
};
var Mc = async (i, t) => {
  var o;
  const e = i.get(pe), s = i.get(ht), n = [], r = [];
  for (const a in t) {
    const l = s.list.get(a);
    if (!(l && l.group))
      continue;
    const u = l.group, h = r.find((d) => d.model === u);
    if (h)
      for (const d of t[a])
        h.expressIDs.add(d);
    else {
      const d = { model: u, expressIDs: new Set(t[a]) };
      r.push(d);
    }
  }
  for (const a in r) {
    const { model: l, expressIDs: u } = r[a], h = e.relationMaps[l.uuid];
    if (h)
      for (const d of u) {
        const c = await l.getProperties(d);
        if (!c)
          continue;
        const p = {
          data: {
            Name: (o = c.Name) == null ? void 0 : o.value
          }
        };
        n.push(p);
        const v = await ls(l, d, {
          includeClass: true
        });
        if (p.children || (p.children = []), p.children.push(v), !h.get(d))
          continue;
        const _ = e.getEntityRelations(
          l,
          d,
          "IsDefinedBy"
        );
        if (_) {
          const b = _.filter(async (A) => {
            const E = await l.getProperties(A);
            return E ? E.type === IFCPROPERTYSET : false;
          }), g = await Ic(l, b);
          g.children && p.children.push(g);
          const $ = _.filter(async (A) => {
            const E = await l.getProperties(A);
            return E ? E.type === IFCELEMENTQUANTITY : false;
          }), C = await Pc(l, $);
          C.children && p.children.push(C);
        }
        const w = e.getEntityRelations(
          l,
          d,
          "HasAssociations"
        );
        if (w) {
          const b = w.filter(async (A) => {
            const E = await l.getProperties(A);
            return E ? E.type === IFCMATERIALLAYERSETUSAGE || E.type === IFCMATERIALLAYERSET || E.type === IFCMATERIALLAYER || E.type === IFCMATERIAL || E.type === IFCMATERIALLIST : false;
          }), g = await Rc(l, b);
          g.children && p.children.push(g);
          const $ = w.filter(
            async (A) => {
              const E = await l.getProperties(A);
              return E ? E.type === IFCCLASSIFICATIONREFERENCE : false;
            }
          ), C = await Nc(
            l,
            $
          );
          C.children && p.children.push(C);
        }
        const f = e.getEntityRelations(
          l,
          d,
          "ContainedInStructure"
        );
        if (f) {
          const b = f[0], g = await ls(l, b, {
            groupName: "SpatialContainer"
          });
          p.children.push(g);
        }
      }
  }
  return n;
};
var Lc = new Event("datacomputed");
var pt;
var zc = (i) => {
  const { components: t, fragmentIdMap: e } = i;
  return pt || (pt = document.createElement("bim-table"), pt.columns = [{ name: "Name", width: "12rem" }], pt.headersHidden = true, pt.addEventListener("cellcreated", ({ detail: s }) => {
    const { cell: n } = s;
    n.column === "Name" && !("Value" in n.rowData) && (n.style.gridColumn = "1 / -1");
  })), Mc(t, e).then((s) => {
    pt.data = s, s.length !== 0 && pt.dispatchEvent(Lc);
  }), y`${pt}`;
};
var Dc = (i) => $t.create(
  zc,
  i
);
var jc = Object.freeze(Object.defineProperty({
  __proto__: null,
  elementProperties: Dc
}, Symbol.toStringTag, { value: "Module" }));
var en = async (i, t, e, s) => {
  var u;
  const n = [], r = i.get(pe), o = await t.getProperties(e);
  if (!o)
    return n;
  const { type: a } = o, l = {
    data: {
      Entity: Bn[a],
      Name: (u = o.Name) == null ? void 0 : u.value,
      modelID: t.uuid
    }
  };
  for (const h of s) {
    const d = r.getEntityRelations(t, e, h);
    if (l.data.expressID = e, !!d) {
      l.data.relations = JSON.stringify(d);
      for (const c of d) {
        const p = await en(
          i,
          t,
          c,
          s
        );
        l.children || (l.children = []), l.children.push(...p);
      }
    }
  }
  return n.push(l), n;
};
var Hc = async (i, t, e, s) => {
  const n = i.get(pe), r = [];
  for (const o of t) {
    let a;
    if (s)
      a = {
        data: {
          Entity: o.name !== "" ? o.name : o.uuid
        },
        children: await en(
          i,
          o,
          s,
          e
        )
      };
    else {
      const l = n.relationMaps[o.uuid], u = await o.getAllPropertiesOfType(
        IFCPROJECT
      );
      if (!(l && u))
        continue;
      const { expressID: h } = Object.values(u)[0];
      a = {
        data: {
          Entity: o.name !== "" ? o.name : o.uuid
        },
        children: await en(
          i,
          o,
          h,
          e
        )
      };
    }
    r.push(a);
  }
  return r;
};
var st;
var cs = (i, t) => {
  const e = i.get(ht), { modelID: s, expressID: n, relations: r } = t.data;
  if (!(s && n))
    return null;
  const o = e.groups.get(s);
  return o ? o.getFragmentMap([
    n,
    ...JSON.parse(r ?? "[]")
  ]) : null;
};
var Fc = (i) => {
  const { components: t, models: e, expressID: s } = i, n = i.selectHighlighterName ?? "select", r = i.hoverHighlighterName ?? "hover";
  st || (st = document.createElement("bim-table"), st.hiddenColumns = ["modelID", "expressID", "relations"], st.columns = ["Entity", "Name"], st.headersHidden = true, st.addEventListener("cellcreated", ({ detail: a }) => {
    const { cell: l } = a;
    l.column === "Entity" && !("Name" in l.rowData) && (l.style.gridColumn = "1 / -1");
  })), st.addEventListener("rowcreated", (a) => {
    a.stopImmediatePropagation();
    const { row: l } = a.detail, u = t.get(Sc);
    l.onmouseover = () => {
      if (!r)
        return;
      const h = cs(t, l);
      h && Object.keys(h).length !== 0 && (l.style.backgroundColor = "var(--bim-ui_bg-contrast-20)", u.highlightByID(
        r,
        h,
        true,
        false,
        u.selection[n] ?? {}
      ));
    }, l.onmouseout = () => {
      l.style.backgroundColor = "", u.clear(r);
    }, l.onclick = () => {
      if (!n)
        return;
      const h = cs(t, l);
      h && Object.keys(h).length !== 0 && u.highlightByID(
        n,
        h,
        true,
        true
      );
    };
  });
  const o = i.inverseAttributes ?? [
    "IsDecomposedBy",
    "ContainsElements"
  ];
  return Hc(t, e, o, s).then(
    (a) => st.data = a
  ), y`${st}`;
};
var Bc = (i, t = true) => {
  const e = $t.create(
    Fc,
    i
  );
  if (t) {
    const [, s] = e, { components: n } = i, r = n.get(ht), o = n.get(pe), a = () => s({ models: r.groups.values() });
    o.onRelationsIndexed.add(a), r.onFragmentsDisposed.add(a);
  }
  return e;
};
var Uc = Object.freeze(Object.defineProperty({
  __proto__: null,
  relationsTree: Bc
}, Symbol.toStringTag, { value: "Module" }));
var fe = (i, t) => [...i.get(dn).list.values()].find((n) => n.world === t);
var Vc = (i, t) => y`
    <bim-color-input @input=${(s) => {
  const n = s.target;
  i.color = new Color(n.color);
}} color=${t}></bim-color-input>
  `;
var Wc = (i, t) => {
  const { postproduction: e } = i, s = e.n8ao.configuration;
  return y`
    <bim-color-input @input=${(r) => {
    const o = r.target;
    s.color = new Color(o.color);
  }} color=${t}></bim-color-input>
  `;
};
var Gc = (i, t) => {
  const { color: e, opacity: s } = JSON.parse(t), { postproduction: n } = i, { customEffects: r } = n;
  return y`
    <bim-color-input @input=${(a) => {
    const { color: l, opacity: u } = a.target;
    r.lineColor = new Color(l).getHex(), u && (r.opacity = u / 100);
  }} color=${e} opacity=${s * 100}></bim-color-input>
  `;
};
var qc = (i, t) => y`
    <bim-color-input @input=${(s) => {
  const n = s.target, r = new Color(n.color);
  i.material.uniforms.uColor.value = r;
}} color=${t}></bim-color-input>
  `;
var Yc = (i, t) => {
  const { postproduction: e } = i;
  return y`
    <bim-checkbox @change=${(n) => {
    const r = n.target;
    e.setPasses({ ao: r.checked });
  }} .checked=${t}></bim-checkbox>
  `;
};
var Xc = (i, t) => {
  const { postproduction: e } = i;
  return y`
    <bim-checkbox @change=${(n) => {
    const r = n.target;
    e.setPasses({ gamma: r.checked });
  }} .checked=${t}></bim-checkbox>
  `;
};
var Jc = (i, t) => {
  const { postproduction: e } = i;
  return y`
    <bim-checkbox @change=${(n) => {
    const r = n.target;
    e.setPasses({ custom: r.checked });
  }} .checked=${t}></bim-checkbox>
  `;
};
var ft = (i, t, e, s = () => {
}) => y`
    <bim-checkbox .checked="${e}" @change="${(r) => {
  const a = r.target.checked;
  i[t] = a, s(a);
}}"></bim-checkbox> 
  `;
var R = (i, t, e, s) => {
  const n = {
    slider: false,
    min: 0,
    max: 100,
    step: 1,
    prefix: null,
    suffix: null,
    onInputSet: () => {
    },
    ...s
  }, { slider: r, min: o, max: a, step: l, suffix: u, prefix: h, onInputSet: d } = n;
  return y`
    <bim-number-input
      .pref=${h}
      .suffix=${u}
      .slider=${r} 
      min=${o} 
      value="${e}" 
      max=${a} 
      step=${l} 
      @change="${(p) => {
    const x = p.target.value;
    i[t] = x, d(x);
  }}"
    ></bim-number-input> 
  `;
};
var Qc = (i) => {
  const { components: t } = i, e = t.get(Ci);
  return y`<bim-table ${ot(async (n) => {
    var a, l, u, h, d;
    if (!n)
      return;
    const r = n;
    r.preserveStructureOnFilter = true, r.dataTransform = {
      Value: (c, p) => {
        const v = p.World, x = e.list.get(v);
        if (!x)
          return c;
        const { scene: _, camera: w, renderer: f } = x, b = p.Name;
        if (b === "Grid" && p.IsGridConfig && typeof c == "boolean") {
          const g = fe(t, x);
          return g ? ft(g, "visible", c) : c;
        }
        if (b === "Color" && p.IsGridConfig && typeof c == "string") {
          const g = fe(t, x);
          return g ? qc(g, c) : c;
        }
        if (b === "Distance" && p.IsGridConfig && typeof c == "number") {
          const g = fe(t, x);
          return g ? R(
            g.material.uniforms.uDistance,
            "value",
            c,
            { slider: true, min: 300, max: 1e3 }
          ) : c;
        }
        if (b === "Size" && p.IsGridConfig && typeof c == "string") {
          const g = fe(t, x);
          if (!g)
            return c;
          const { x: $, y: C } = JSON.parse(c), A = R(
            g.material.uniforms.uSize1,
            "value",
            $,
            { slider: true, suffix: "m", prefix: "A", min: 1, max: 20 }
          ), E = R(
            g.material.uniforms.uSize2,
            "value",
            C,
            { slider: true, suffix: "m", prefix: "B", min: 1, max: 20 }
          );
          return y`
            <div style="display: flex; gap: 0.25rem; width: 100%; flex-wrap: wrap">${A}${E}</div>
          `;
        }
        if (b === "Near Frustum" && w.three instanceof PerspectiveCamera && typeof c == "number") {
          const g = w.three;
          return R(w.three, "near", c, {
            slider: true,
            min: 0.1,
            max: 10,
            step: 0.1,
            onInputSet: () => g.updateProjectionMatrix()
          });
        }
        if (b === "Far Frustum" && w.three instanceof PerspectiveCamera && typeof c == "number") {
          const g = w.three;
          return R(w.three, "far", c, {
            slider: true,
            min: 300,
            max: 2e3,
            step: 10,
            onInputSet: () => g.updateProjectionMatrix()
          });
        }
        if (b === "Field of View" && w.three instanceof PerspectiveCamera && typeof c == "number") {
          const g = w.three;
          return R(w.three, "fov", c, {
            slider: true,
            min: 10,
            max: 120,
            onInputSet: () => g.updateProjectionMatrix()
          });
        }
        if (b === "Invert Drag" && w.hasCameraControls() && typeof c == "boolean")
          return ft(
            w.controls,
            "dollyDragInverted",
            c
          );
        if (b === "Dolly Speed" && w.hasCameraControls() && typeof c == "number")
          return R(w.controls, "dollySpeed", c, {
            slider: true,
            min: 0.5,
            max: 3,
            step: 0.1
          });
        if (b === "Truck Speed" && w.hasCameraControls() && typeof c == "number")
          return R(w.controls, "truckSpeed", c, {
            slider: true,
            min: 0.5,
            max: 6,
            step: 0.1
          });
        if (b === "Smooth Time" && w.hasCameraControls() && typeof c == "number")
          return R(w.controls, "smoothTime", c, {
            slider: true,
            min: 0.01,
            max: 2,
            step: 0.01
          });
        if (b === "Intensity" && typeof c == "number") {
          if (p.Light && typeof p.Light == "string") {
            const g = _.three.children.find(
              ($) => $.uuid === p.Light
            );
            return g && g instanceof Light ? R(g, "intensity", c, {
              slider: true,
              min: 0,
              max: 10,
              step: 0.1
            }) : c;
          }
          if (p.IsAOConfig && f instanceof Sa)
            return R(
              f.postproduction.n8ao.configuration,
              "intensity",
              c,
              { slider: true, max: 16, step: 0.1 }
            );
        }
        if (b === "Color" && typeof c == "string") {
          const g = p.Light, $ = _.three.children.find(
            (C) => C.uuid === g
          );
          if ($ && $ instanceof Light)
            return Vc($, c);
          if (p.IsAOConfig && f instanceof Sa)
            return Wc(f, c);
        }
        if (b === "Ambient Oclussion" && typeof c == "boolean" && p.IsAOConfig && f instanceof Sa)
          return Yc(f, c);
        if (b === "Half Resolution" && p.IsAOConfig && f instanceof Sa && typeof c == "boolean")
          return ft(
            f.postproduction.n8ao.configuration,
            "halfRes",
            c
          );
        if (b === "Screen Space Radius" && p.IsAOConfig && f instanceof Sa && typeof c == "boolean")
          return ft(
            f.postproduction.n8ao.configuration,
            "screenSpaceRadius",
            c
          );
        if (b === "Radius" && p.IsAOConfig && f instanceof Sa && typeof c == "number")
          return R(
            f.postproduction.n8ao.configuration,
            "aoRadius",
            c,
            { slider: true, max: 2, step: 0.1 }
          );
        if (b === "Denoise Samples" && p.IsAOConfig && f instanceof Sa && typeof c == "number")
          return R(
            f.postproduction.n8ao.configuration,
            "denoiseSamples",
            c,
            { slider: true, min: 1, max: 16 }
          );
        if (b === "Samples" && p.IsAOConfig && f instanceof Sa && typeof c == "number")
          return R(
            f.postproduction.n8ao.configuration,
            "aoSamples",
            c,
            { slider: true, min: 1, max: 16 }
          );
        if (b === "Denoise Radius" && p.IsAOConfig && f instanceof Sa && typeof c == "number")
          return R(
            f.postproduction.n8ao.configuration,
            "denoiseRadius",
            c,
            { slider: true, min: 0, max: 16, step: 0.1 }
          );
        if (b === "Distance Falloff" && p.IsAOConfig && f instanceof Sa && typeof c == "number")
          return R(
            f.postproduction.n8ao.configuration,
            "distanceFalloff",
            c,
            { slider: true, min: 0, max: 4, step: 0.1 }
          );
        if (b === "Directional Light" && p.Light && typeof p.Light == "string" && typeof c == "boolean") {
          const g = _.three.children.find(
            ($) => $.uuid === p.Light
          );
          return g && g instanceof Light ? ft(g, "visible", c) : c;
        }
        if (b === "Ambient Light" && p.Light && typeof p.Light == "string" && typeof c == "boolean") {
          const g = _.three.children.find(
            ($) => $.uuid === p.Light
          );
          return g && g instanceof Light ? ft(g, "visible", c) : c;
        }
        if (b === "Position" && p.Light && typeof p.Light == "string" && typeof c == "string") {
          const g = _.three.children.find(
            (Q) => Q.uuid === p.Light
          );
          if (!(g && g instanceof Light))
            return c;
          const { x: $, y: C, z: A } = JSON.parse(c), E = R(g.position, "x", $, {
            slider: true,
            prefix: "X",
            suffix: "m",
            min: -50,
            max: 50
          }), j = R(g.position, "y", C, {
            slider: true,
            prefix: "Y",
            suffix: "m",
            min: -50,
            max: 50
          }), O = R(g.position, "z", A, {
            slider: true,
            prefix: "Z",
            suffix: "m",
            min: -50,
            max: 50
          });
          return y`
            <div style="display: flex; gap: 0.25rem; width: 100%; flex-wrap: wrap">${E}${j}${O}</div>
          `;
        }
        return b === "Custom Effects" && p.IsCEConfig && f instanceof Sa && typeof c == "boolean" ? Jc(f, c) : b === "Color" && p.IsOutlineConfig && f instanceof Sa && typeof c == "string" ? Gc(f, c) : b === "Tolerance" && p.IsOutlineConfig && f instanceof Sa && typeof c == "number" ? R(
          f.postproduction.customEffects,
          "tolerance",
          c,
          { slider: true, min: 0, max: 6, step: 0.01 }
        ) : b === "Outline" && p.IsOutlineConfig && f instanceof Sa && typeof c == "boolean" ? ft(
          f.postproduction.customEffects,
          "outlineEnabled",
          c
        ) : b === "Gloss" && p.IsGlossConfig && f instanceof Sa && typeof c == "boolean" ? ft(
          f.postproduction.customEffects,
          "glossEnabled",
          c
        ) : b === "Min" && p.IsGlossConfig && f instanceof Sa && typeof c == "number" ? R(
          f.postproduction.customEffects,
          "minGloss",
          c,
          { slider: true, min: -0.5, max: 0.5, step: 0.01 }
        ) : b === "Max" && p.IsGlossConfig && f instanceof Sa && typeof c == "number" ? R(
          f.postproduction.customEffects,
          "maxGloss",
          c,
          { slider: true, min: -0.5, max: 0.5, step: 0.01 }
        ) : b === "Exponent" && p.IsGlossConfig && f instanceof Sa && typeof c == "number" ? R(
          f.postproduction.customEffects,
          "glossExponent",
          c,
          { slider: true, min: 0, max: 5, step: 0.01 }
        ) : b === "Gamma Correction" && p.IsGammaConfig && f instanceof Sa && typeof c == "boolean" ? Xc(f, c) : c;
      }
    }, r.addEventListener("cellcreated", ({ detail: c }) => {
      const p = c.cell.parentNode;
      if (!p)
        return;
      const v = p.querySelector(
        "bim-table-cell[column='Name']"
      ), x = p.querySelector(
        "bim-table-cell[column='Value']"
      );
      v && !x && (v.style.gridColumn = "1 / -1");
    });
    const o = [];
    for (const [, c] of e.list) {
      const { scene: p, camera: v, renderer: x } = c, _ = fe(t, c), w = {
        data: {
          Name: c instanceof gr && c.name || c.uuid
        },
        children: []
      };
      if (p) {
        const f = {
          data: {
            Name: "Scene"
          }
        };
        if (_) {
          const $ = {
            data: {
              Name: "Grid",
              Value: _.three.visible,
              World: c.uuid,
              IsGridConfig: true
            },
            children: [
              {
                data: {
                  Name: "Color",
                  get Value() {
                    return `#${_.material.uniforms.uColor.value.getHexString()}`;
                  },
                  World: c.uuid,
                  IsGridConfig: true
                }
              },
              {
                data: {
                  Name: "Size",
                  get Value() {
                    const C = _.material.uniforms.uSize1.value, A = _.material.uniforms.uSize2.value;
                    return JSON.stringify({ x: C, y: A });
                  },
                  World: c.uuid,
                  IsGridConfig: true
                }
              },
              {
                data: {
                  Name: "Distance",
                  Value: _.material.uniforms.uDistance.value,
                  World: c.uuid,
                  IsGridConfig: true
                }
              }
            ]
          };
          f.children || (f.children = []), f.children.push($);
        }
        const b = p.three.children.filter(
          ($) => $ instanceof DirectionalLight
        );
        for (const $ of b) {
          const C = {
            data: {
              Name: "Directional Light",
              Value: $.visible,
              World: c.uuid,
              Light: $.uuid
            },
            children: [
              {
                data: {
                  Name: "Position",
                  Value: JSON.stringify($.position),
                  World: c.uuid,
                  Light: $.uuid
                }
              },
              {
                data: {
                  Name: "Intensity",
                  Value: $.intensity,
                  World: c.uuid,
                  Light: $.uuid
                }
              },
              {
                data: {
                  Name: "Color",
                  Value: `#${$.color.getHexString()}`,
                  World: c.uuid,
                  Light: $.uuid
                }
              }
            ]
          };
          f.children || (f.children = []), f.children.push(C);
        }
        const g = p.three.children.filter(
          ($) => $ instanceof AmbientLight
        );
        for (const $ of g) {
          const C = {
            data: {
              Name: "Ambient Light",
              Value: $.visible,
              World: c.uuid,
              Light: $.uuid
            },
            children: [
              {
                data: {
                  Name: "Intensity",
                  Value: $.intensity,
                  World: c.uuid,
                  Light: $.uuid
                }
              },
              {
                data: {
                  Name: "Color",
                  Value: `#${$.color.getHexString()}`,
                  World: c.uuid,
                  Light: $.uuid
                }
              }
            ]
          };
          f.children || (f.children = []), f.children.push(C);
        }
        f.children && ((a = f.children) == null ? void 0 : a.length) > 0 && ((l = w.children) == null || l.push(f));
      }
      if (v.three instanceof PerspectiveCamera) {
        const f = {
          data: {
            Name: "Perspective Camera"
          },
          children: [
            {
              data: {
                Name: "Near Frustum",
                Value: v.three.near,
                World: c.uuid
              }
            },
            {
              data: {
                Name: "Far Frustum",
                Value: v.three.far,
                World: c.uuid
              }
            },
            {
              data: {
                Name: "Field of View",
                Value: v.three.fov,
                World: c.uuid
              }
            }
          ]
        };
        if (v.hasCameraControls()) {
          const { controls: b } = v, g = {
            dollyDragInverted: "Invert Drag",
            dollySpeed: "Dolly Speed",
            truckSpeed: "Truck Speed",
            smoothTime: "Smooth Time"
          };
          for (const $ in g) {
            const C = b[$];
            C != null && ((u = f.children) == null || u.push({
              data: {
                Name: g[$],
                Value: C,
                World: c.uuid
              }
            }));
          }
        }
        (h = w.children) == null || h.push(f);
      }
      if (x instanceof Sa) {
        const { postproduction: f } = x, b = f.n8ao.configuration, g = {
          data: {
            Name: "Renderer"
          },
          children: [
            {
              data: {
                Name: "Gamma Correction",
                Value: f.settings.gamma ?? false,
                World: c.uuid,
                IsGammaConfig: true
              }
            },
            {
              data: {
                Name: "Ambient Oclussion",
                Value: f.settings.ao ?? false,
                World: c.uuid,
                IsAOConfig: true
              },
              children: [
                {
                  data: {
                    Name: "Samples",
                    Value: b.aoSamples,
                    World: c.uuid,
                    IsAOConfig: true
                  }
                },
                {
                  data: {
                    Name: "Color",
                    Value: `#${b.color.getHexString()}`,
                    World: c.uuid,
                    IsAOConfig: true
                  }
                },
                {
                  data: {
                    Name: "Half Resolution",
                    Value: b.halfRes,
                    World: c.uuid,
                    IsAOConfig: true
                  }
                },
                {
                  data: {
                    Name: "Screen Space Radius",
                    Value: b.screenSpaceRadius,
                    World: c.uuid,
                    IsAOConfig: true
                  }
                },
                {
                  data: {
                    Name: "Radius",
                    Value: b.aoRadius,
                    World: c.uuid,
                    IsAOConfig: true
                  }
                },
                {
                  data: {
                    Name: "Intensity",
                    Value: b.intensity,
                    World: c.uuid,
                    IsAOConfig: true
                  }
                },
                {
                  data: {
                    Name: "Distance Falloff",
                    Value: b.distanceFalloff,
                    World: c.uuid,
                    IsAOConfig: true
                  }
                },
                {
                  data: {
                    Name: "Denoise Samples",
                    Value: b.denoiseSamples,
                    World: c.uuid,
                    IsAOConfig: true
                  }
                },
                {
                  data: {
                    Name: "Denoise Radius",
                    Value: b.denoiseRadius,
                    World: c.uuid,
                    IsAOConfig: true
                  }
                }
              ]
            },
            {
              data: {
                Name: "Custom Effects",
                Value: f.settings.custom ?? false,
                World: c.uuid,
                IsCEConfig: true
              },
              children: [
                {
                  data: {
                    Name: "Gloss",
                    Value: f.customEffects.glossEnabled,
                    World: c.uuid,
                    IsGlossConfig: true
                  },
                  children: [
                    {
                      data: {
                        Name: "Min",
                        Value: f.customEffects.minGloss,
                        World: c.uuid,
                        IsGlossConfig: true
                      }
                    },
                    {
                      data: {
                        Name: "Max",
                        Value: f.customEffects.maxGloss,
                        World: c.uuid,
                        IsGlossConfig: true
                      }
                    },
                    {
                      data: {
                        Name: "Exponent",
                        Value: f.customEffects.glossExponent,
                        World: c.uuid,
                        IsGlossConfig: true
                      }
                    }
                  ]
                },
                {
                  data: {
                    Name: "Outline",
                    Value: f.customEffects.outlineEnabled,
                    World: c.uuid,
                    IsOutlineConfig: true
                  },
                  children: [
                    {
                      data: {
                        Name: "Color",
                        get Value() {
                          const $ = new Color(
                            f.customEffects.lineColor
                          ), C = f.customEffects.opacity;
                          return JSON.stringify({
                            color: `#${$.getHexString()}`,
                            opacity: C
                          });
                        },
                        World: c.uuid,
                        IsOutlineConfig: true
                      }
                    },
                    {
                      data: {
                        Name: "Tolerance",
                        Value: f.customEffects.tolerance,
                        World: c.uuid,
                        IsOutlineConfig: true
                      }
                    }
                  ]
                }
              ]
            }
          ]
        };
        (d = w.children) == null || d.push(g);
      }
      o.push(w);
    }
    r.columns = [{ name: "Name", width: "11rem" }], r.hiddenColumns = [
      "World",
      "Light",
      "IsAOConfig",
      "IsCEConfig",
      "IsGlossConfig",
      "IsOutlineConfig",
      "IsGammaConfig",
      "IsGridConfig"
    ], r.data = o;
  })} headers-hidden expanded></bim-table>`;
};
var Kc = (i, t = true) => {
  const e = $t.create(
    Qc,
    i
  );
  if (t) {
    const [s] = e, n = () => e[1](), { components: r } = i, o = r.get(Ci);
    o.onDisposed.add(s.remove);
    for (const [, a] of o.list)
      a.onDisposed.add(n);
    s.addEventListener("disconnected", () => {
      o.onDisposed.remove(s.remove);
      for (const [, a] of o.list)
        a.onDisposed.remove(n);
    });
  }
  return e;
};
var Zc = Object.freeze(Object.defineProperty({
  __proto__: null,
  worldsConfiguration: Kc
}, Symbol.toStringTag, { value: "Module" }));
var sh = {
  ...wc,
  ...Ec,
  ...Oc,
  ...jc,
  ...Uc,
  ...Zc
};
var Ze = globalThis;
var vn = Ze.ShadowRoot && (Ze.ShadyCSS === void 0 || Ze.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var yn = Symbol();
var us = /* @__PURE__ */ new WeakMap();
var Jr = class {
  constructor(t, e, s) {
    if (this._$cssResult$ = true, s !== yn)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (vn && t === void 0) {
      const s = e !== void 0 && e.length === 1;
      s && (t = us.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), s && us.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
var tu = (i) => new Jr(typeof i == "string" ? i : i + "", void 0, yn);
var Qr = (i, ...t) => {
  const e = i.length === 1 ? i[0] : t.reduce((s, n, r) => s + ((o) => {
    if (o._$cssResult$ === true)
      return o.cssText;
    if (typeof o == "number")
      return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(n) + i[r + 1], i[0]);
  return new Jr(e, i, yn);
};
var eu = (i, t) => {
  if (vn)
    i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else
    for (const e of t) {
      const s = document.createElement("style"), n = Ze.litNonce;
      n !== void 0 && s.setAttribute("nonce", n), s.textContent = e.cssText, i.appendChild(s);
    }
};
var hs = vn ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const s of t.cssRules)
    e += s.cssText;
  return tu(e);
})(i) : i;
var { is: iu, defineProperty: nu, getOwnPropertyDescriptor: su, getOwnPropertyNames: ru, getOwnPropertySymbols: ou, getPrototypeOf: au } = Object;
var gt = globalThis;
var ds = gt.trustedTypes;
var lu = ds ? ds.emptyScript : "";
var Li = gt.reactiveElementPolyfillSupport;
var _e = (i, t) => i;
var ui = { toAttribute(i, t) {
  switch (t) {
    case Boolean:
      i = i ? lu : null;
      break;
    case Object:
    case Array:
      i = i == null ? i : JSON.stringify(i);
  }
  return i;
}, fromAttribute(i, t) {
  let e = i;
  switch (t) {
    case Boolean:
      e = i !== null;
      break;
    case Number:
      e = i === null ? null : Number(i);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(i);
      } catch {
        e = null;
      }
  }
  return e;
} };
var _n = (i, t) => !iu(i, t);
var ps = { attribute: true, type: String, converter: ui, reflect: false, hasChanged: _n };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), gt.litPropertyMetadata ?? (gt.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
var Ut = class extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = ps) {
    if (e.state && (e.attribute = false), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {
      const s = Symbol(), n = this.getPropertyDescriptor(t, s, e);
      n !== void 0 && nu(this.prototype, t, n);
    }
  }
  static getPropertyDescriptor(t, e, s) {
    const { get: n, set: r } = su(this.prototype, t) ?? { get() {
      return this[e];
    }, set(o) {
      this[e] = o;
    } };
    return { get() {
      return n == null ? void 0 : n.call(this);
    }, set(o) {
      const a = n == null ? void 0 : n.call(this);
      r.call(this, o), this.requestUpdate(t, a, s);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? ps;
  }
  static _$Ei() {
    if (this.hasOwnProperty(_e("elementProperties")))
      return;
    const t = au(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(_e("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(_e("properties"))) {
      const e = this.properties, s = [...ru(e), ...ou(e)];
      for (const n of s)
        this.createProperty(n, e[n]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0)
        for (const [s, n] of e)
          this.elementProperties.set(s, n);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, s] of this.elementProperties) {
      const n = this._$Eu(e, s);
      n !== void 0 && this._$Eh.set(n, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const s = new Set(t.flat(1 / 0).reverse());
      for (const n of s)
        e.unshift(hs(n));
    } else
      t !== void 0 && e.push(hs(t));
    return e;
  }
  static _$Eu(t, e) {
    const s = e.attribute;
    return s === false ? void 0 : typeof s == "string" ? s : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
  }
  addController(t) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$EO) == null || e.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const s of e.keys())
      this.hasOwnProperty(s) && (t.set(s, this[s]), delete this[s]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return eu(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t = this._$EO) == null || t.forEach((e) => {
      var s;
      return (s = e.hostConnected) == null ? void 0 : s.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var s;
      return (s = e.hostDisconnected) == null ? void 0 : s.call(e);
    });
  }
  attributeChangedCallback(t, e, s) {
    this._$AK(t, s);
  }
  _$EC(t, e) {
    var r;
    const s = this.constructor.elementProperties.get(t), n = this.constructor._$Eu(t, s);
    if (n !== void 0 && s.reflect === true) {
      const o = (((r = s.converter) == null ? void 0 : r.toAttribute) !== void 0 ? s.converter : ui).toAttribute(e, s.type);
      this._$Em = t, o == null ? this.removeAttribute(n) : this.setAttribute(n, o), this._$Em = null;
    }
  }
  _$AK(t, e) {
    var r;
    const s = this.constructor, n = s._$Eh.get(t);
    if (n !== void 0 && this._$Em !== n) {
      const o = s.getPropertyOptions(n), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((r = o.converter) == null ? void 0 : r.fromAttribute) !== void 0 ? o.converter : ui;
      this._$Em = n, this[n] = a.fromAttribute(e, o.type), this._$Em = null;
    }
  }
  requestUpdate(t, e, s) {
    if (t !== void 0) {
      if (s ?? (s = this.constructor.getPropertyOptions(t)), !(s.hasChanged ?? _n)(this[t], e))
        return;
      this.P(t, e, s);
    }
    this.isUpdatePending === false && (this._$ES = this._$ET());
  }
  P(t, e, s) {
    this._$AL.has(t) || this._$AL.set(t, e), s.reflect === true && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var s;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [r, o] of this._$Ep)
          this[r] = o;
        this._$Ep = void 0;
      }
      const n = this.constructor.elementProperties;
      if (n.size > 0)
        for (const [r, o] of n)
          o.wrapped !== true || this._$AL.has(r) || this[r] === void 0 || this.P(r, this[r], o);
    }
    let t = false;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), (s = this._$EO) == null || s.forEach((n) => {
        var r;
        return (r = n.hostUpdate) == null ? void 0 : r.call(n);
      }), this.update(e)) : this._$EU();
    } catch (n) {
      throw t = false, this._$EU(), n;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$EO) == null || e.forEach((s) => {
      var n;
      return (n = s.hostUpdated) == null ? void 0 : n.call(s);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t)), this.updated(t);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return true;
  }
  update(t) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
Ut.elementStyles = [], Ut.shadowRootOptions = { mode: "open" }, Ut[_e("elementProperties")] = /* @__PURE__ */ new Map(), Ut[_e("finalized")] = /* @__PURE__ */ new Map(), Li == null || Li({ ReactiveElement: Ut }), (gt.reactiveElementVersions ?? (gt.reactiveElementVersions = [])).push("2.0.4");
var xe = globalThis;
var hi = xe.trustedTypes;
var fs = hi ? hi.createPolicy("lit-html", { createHTML: (i) => i }) : void 0;
var Kr = "$lit$";
var bt = `lit$${Math.random().toFixed(9).slice(2)}$`;
var Zr = "?" + bt;
var cu = `<${Zr}>`;
var zt = document;
var Oe = () => zt.createComment("");
var Te = (i) => i === null || typeof i != "object" && typeof i != "function";
var to = Array.isArray;
var uu = (i) => to(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == "function";
var zi = `[ 	
\f\r]`;
var me = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var ms = /-->/g;
var bs = />/g;
var It = RegExp(`>|${zi}(?:([^\\s"'>=/]+)(${zi}*=${zi}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var gs = /'/g;
var vs = /"/g;
var eo = /^(?:script|style|textarea|title)$/i;
var hu = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e });
var io = hu(1);
var te = Symbol.for("lit-noChange");
var z = Symbol.for("lit-nothing");
var ys = /* @__PURE__ */ new WeakMap();
var Rt = zt.createTreeWalker(zt, 129);
function no(i, t) {
  if (!Array.isArray(i) || !i.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return fs !== void 0 ? fs.createHTML(t) : t;
}
var du = (i, t) => {
  const e = i.length - 1, s = [];
  let n, r = t === 2 ? "<svg>" : "", o = me;
  for (let a = 0; a < e; a++) {
    const l = i[a];
    let u, h, d = -1, c = 0;
    for (; c < l.length && (o.lastIndex = c, h = o.exec(l), h !== null); )
      c = o.lastIndex, o === me ? h[1] === "!--" ? o = ms : h[1] !== void 0 ? o = bs : h[2] !== void 0 ? (eo.test(h[2]) && (n = RegExp("</" + h[2], "g")), o = It) : h[3] !== void 0 && (o = It) : o === It ? h[0] === ">" ? (o = n ?? me, d = -1) : h[1] === void 0 ? d = -2 : (d = o.lastIndex - h[2].length, u = h[1], o = h[3] === void 0 ? It : h[3] === '"' ? vs : gs) : o === vs || o === gs ? o = It : o === ms || o === bs ? o = me : (o = It, n = void 0);
    const p = o === It && i[a + 1].startsWith("/>") ? " " : "";
    r += o === me ? l + cu : d >= 0 ? (s.push(u), l.slice(0, d) + Kr + l.slice(d) + bt + p) : l + bt + (d === -2 ? a : p);
  }
  return [no(i, r + (i[e] || "<?>") + (t === 2 ? "</svg>" : "")), s];
};
var Ie = class _Ie {
  constructor({ strings: t, _$litType$: e }, s) {
    let n;
    this.parts = [];
    let r = 0, o = 0;
    const a = t.length - 1, l = this.parts, [u, h] = du(t, e);
    if (this.el = _Ie.createElement(u, s), Rt.currentNode = this.el.content, e === 2) {
      const d = this.el.content.firstChild;
      d.replaceWith(...d.childNodes);
    }
    for (; (n = Rt.nextNode()) !== null && l.length < a; ) {
      if (n.nodeType === 1) {
        if (n.hasAttributes())
          for (const d of n.getAttributeNames())
            if (d.endsWith(Kr)) {
              const c = h[o++], p = n.getAttribute(d).split(bt), v = /([.?@])?(.*)/.exec(c);
              l.push({ type: 1, index: r, name: v[2], strings: p, ctor: v[1] === "." ? fu : v[1] === "?" ? mu : v[1] === "@" ? bu : Ci2 }), n.removeAttribute(d);
            } else
              d.startsWith(bt) && (l.push({ type: 6, index: r }), n.removeAttribute(d));
        if (eo.test(n.tagName)) {
          const d = n.textContent.split(bt), c = d.length - 1;
          if (c > 0) {
            n.textContent = hi ? hi.emptyScript : "";
            for (let p = 0; p < c; p++)
              n.append(d[p], Oe()), Rt.nextNode(), l.push({ type: 2, index: ++r });
            n.append(d[c], Oe());
          }
        }
      } else if (n.nodeType === 8)
        if (n.data === Zr)
          l.push({ type: 2, index: r });
        else {
          let d = -1;
          for (; (d = n.data.indexOf(bt, d + 1)) !== -1; )
            l.push({ type: 7, index: r }), d += bt.length - 1;
        }
      r++;
    }
  }
  static createElement(t, e) {
    const s = zt.createElement("template");
    return s.innerHTML = t, s;
  }
};
function ee(i, t, e = i, s) {
  var o, a;
  if (t === te)
    return t;
  let n = s !== void 0 ? (o = e._$Co) == null ? void 0 : o[s] : e._$Cl;
  const r = Te(t) ? void 0 : t._$litDirective$;
  return (n == null ? void 0 : n.constructor) !== r && ((a = n == null ? void 0 : n._$AO) == null || a.call(n, false), r === void 0 ? n = void 0 : (n = new r(i), n._$AT(i, e, s)), s !== void 0 ? (e._$Co ?? (e._$Co = []))[s] = n : e._$Cl = n), n !== void 0 && (t = ee(i, n._$AS(i, t.values), n, s)), t;
}
var pu = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: s } = this._$AD, n = ((t == null ? void 0 : t.creationScope) ?? zt).importNode(e, true);
    Rt.currentNode = n;
    let r = Rt.nextNode(), o = 0, a = 0, l = s[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let u;
        l.type === 2 ? u = new We(r, r.nextSibling, this, t) : l.type === 1 ? u = new l.ctor(r, l.name, l.strings, this, t) : l.type === 6 && (u = new gu(r, this, t)), this._$AV.push(u), l = s[++a];
      }
      o !== (l == null ? void 0 : l.index) && (r = Rt.nextNode(), o++);
    }
    return Rt.currentNode = zt, n;
  }
  p(t) {
    let e = 0;
    for (const s of this._$AV)
      s !== void 0 && (s.strings !== void 0 ? (s._$AI(t, s, e), e += s.strings.length - 2) : s._$AI(t[e])), e++;
  }
};
var We = class _We {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
  }
  constructor(t, e, s, n) {
    this.type = 2, this._$AH = z, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = s, this.options = n, this._$Cv = (n == null ? void 0 : n.isConnected) ?? true;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = ee(this, t, e), Te(t) ? t === z || t == null || t === "" ? (this._$AH !== z && this._$AR(), this._$AH = z) : t !== this._$AH && t !== te && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : uu(t) ? this.k(t) : this._(t);
  }
  S(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.S(t));
  }
  _(t) {
    this._$AH !== z && Te(this._$AH) ? this._$AA.nextSibling.data = t : this.T(zt.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var r;
    const { values: e, _$litType$: s } = t, n = typeof s == "number" ? this._$AC(t) : (s.el === void 0 && (s.el = Ie.createElement(no(s.h, s.h[0]), this.options)), s);
    if (((r = this._$AH) == null ? void 0 : r._$AD) === n)
      this._$AH.p(e);
    else {
      const o = new pu(n, this), a = o.u(this.options);
      o.p(e), this.T(a), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = ys.get(t.strings);
    return e === void 0 && ys.set(t.strings, e = new Ie(t)), e;
  }
  k(t) {
    to(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let s, n = 0;
    for (const r of t)
      n === e.length ? e.push(s = new _We(this.S(Oe()), this.S(Oe()), this, this.options)) : s = e[n], s._$AI(r), n++;
    n < e.length && (this._$AR(s && s._$AB.nextSibling, n), e.length = n);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var s;
    for ((s = this._$AP) == null ? void 0 : s.call(this, false, true, e); t && t !== this._$AB; ) {
      const n = t.nextSibling;
      t.remove(), t = n;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));
  }
};
var Ci2 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, s, n, r) {
    this.type = 1, this._$AH = z, this._$AN = void 0, this.element = t, this.name = e, this._$AM = n, this.options = r, s.length > 2 || s[0] !== "" || s[1] !== "" ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = z;
  }
  _$AI(t, e = this, s, n) {
    const r = this.strings;
    let o = false;
    if (r === void 0)
      t = ee(this, t, e, 0), o = !Te(t) || t !== this._$AH && t !== te, o && (this._$AH = t);
    else {
      const a = t;
      let l, u;
      for (t = r[0], l = 0; l < r.length - 1; l++)
        u = ee(this, a[s + l], e, l), u === te && (u = this._$AH[l]), o || (o = !Te(u) || u !== this._$AH[l]), u === z ? t = z : t !== z && (t += (u ?? "") + r[l + 1]), this._$AH[l] = u;
    }
    o && !n && this.j(t);
  }
  j(t) {
    t === z ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
};
var fu = class extends Ci2 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === z ? void 0 : t;
  }
};
var mu = class extends Ci2 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== z);
  }
};
var bu = class extends Ci2 {
  constructor(t, e, s, n, r) {
    super(t, e, s, n, r), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = ee(this, t, e, 0) ?? z) === te)
      return;
    const s = this._$AH, n = t === z && s !== z || t.capture !== s.capture || t.once !== s.once || t.passive !== s.passive, r = t !== z && (s === z || n);
    n && this.element.removeEventListener(this.name, this, s), r && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
};
var gu = class {
  constructor(t, e, s) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = s;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    ee(this, t);
  }
};
var Di = xe.litHtmlPolyfillSupport;
Di == null || Di(Ie, We), (xe.litHtmlVersions ?? (xe.litHtmlVersions = [])).push("3.1.4");
var vu = (i, t, e) => {
  const s = (e == null ? void 0 : e.renderBefore) ?? t;
  let n = s._$litPart$;
  if (n === void 0) {
    const r = (e == null ? void 0 : e.renderBefore) ?? null;
    s._$litPart$ = n = new We(t.insertBefore(Oe(), r), r, void 0, e ?? {});
  }
  return n._$AI(i), n;
};
var Gt = class extends Ut {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var e;
    const t = super.createRenderRoot();
    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = vu(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(true);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(false);
  }
  render() {
    return te;
  }
};
var _s;
Gt._$litElement$ = true, Gt.finalized = true, (_s = globalThis.litElementHydrateSupport) == null || _s.call(globalThis, { LitElement: Gt });
var ji = globalThis.litElementPolyfillSupport;
ji == null || ji({ LitElement: Gt });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.6");
var yu = { attribute: true, type: String, converter: ui, reflect: false, hasChanged: _n };
var _u = (i = yu, t, e) => {
  const { kind: s, metadata: n } = e;
  let r = globalThis.litPropertyMetadata.get(n);
  if (r === void 0 && globalThis.litPropertyMetadata.set(n, r = /* @__PURE__ */ new Map()), r.set(e.name, i), s === "accessor") {
    const { name: o } = e;
    return { set(a) {
      const l = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(o, l, i);
    }, init(a) {
      return a !== void 0 && this.P(o, void 0, i), a;
    } };
  }
  if (s === "setter") {
    const { name: o } = e;
    return function(a) {
      const l = this[o];
      t.call(this, a), this.requestUpdate(o, l, i);
    };
  }
  throw Error("Unsupported decorator location: " + s);
};
function G(i) {
  return (t, e) => typeof e == "object" ? _u(i, t, e) : ((s, n, r) => {
    const o = n.hasOwnProperty(r);
    return n.constructor.createProperty(r, o ? { ...s, wrapped: true } : s), o ? Object.getOwnPropertyDescriptor(n, r) : void 0;
  })(i, t, e);
}
function xu(i) {
  return G({ ...i, state: true, attribute: false });
}
var wu = class extends Object3D {
  constructor(t = document.createElement("div")) {
    super(), this.isCSS2DObject = true, this.element = t, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", false), this.center = new Vector2(0.5, 0.5), this.addEventListener("removed", function() {
      this.traverse(function(e) {
        e.element instanceof Element && e.element.parentNode !== null && e.element.parentNode.removeChild(e.element);
      });
    });
  }
  copy(t, e) {
    return super.copy(t, e), this.element = t.element.cloneNode(true), this.center = t.center, this;
  }
};
new Vector3();
new Matrix4();
new Matrix4();
new Vector3();
new Vector3();
var $u = class {
  constructor(t, e) {
    this._group = new Group(), this._frustum = new Frustum(), this._frustumMat = new Matrix4(), this._regenerateDelay = 200, this._regenerateCounter = 0, this.material = new LineBasicMaterial({ color: "#2e3338" }), this.numbers = new Group(), this.maxRegenerateRetrys = 4, this.gridsFactor = 5, this._scaleX = 1, this._scaleY = 1, this._offsetX = 0, this._offsetY = 0, this._camera = t, this._container = e;
    const s = this.newGrid(-1), n = this.newGrid(-2);
    this.grids = { main: s, secondary: n }, this._group.add(n, s, this.numbers);
  }
  set scaleX(t) {
    this._scaleX = t, this.regenerate();
  }
  get scaleX() {
    return this._scaleX;
  }
  set scaleY(t) {
    this._scaleY = t, this.regenerate();
  }
  get scaleY() {
    return this._scaleY;
  }
  set offsetX(t) {
    this._offsetX = t, this.regenerate();
  }
  get offsetX() {
    return this._offsetX;
  }
  set offsetY(t) {
    this._offsetY = t, this.regenerate();
  }
  get offsetY() {
    return this._offsetY;
  }
  get() {
    return this._group;
  }
  dispose() {
    const { main: t, secondary: e } = this.grids;
    t.removeFromParent(), e.removeFromParent(), t.geometry.dispose(), t.material.dispose(), e.geometry.dispose(), e.material.dispose();
  }
  regenerate() {
    if (!this.isGridReady()) {
      if (this._regenerateCounter++, this._regenerateCounter > this.maxRegenerateRetrys)
        throw new Error("Grid could not be regenerated");
      setTimeout(() => this.regenerate, this._regenerateDelay);
      return;
    }
    this._regenerateCounter = 0, this._camera.updateMatrix(), this._camera.updateMatrixWorld();
    const e = this._frustumMat.multiplyMatrices(
      this._camera.projectionMatrix,
      this._camera.matrixWorldInverse
    );
    this._frustum.setFromProjectionMatrix(e);
    const { planes: s } = this._frustum, n = s[0].constant * -s[0].normal.x, r = s[1].constant * -s[1].normal.x, o = s[2].constant * -s[2].normal.y, a = s[3].constant * -s[3].normal.y, l = Math.abs(n - r), u = Math.abs(a - o), { clientWidth: h, clientHeight: d } = this._container, c = Math.max(h, d), v = Math.max(l, u) / c, x = Math.ceil(Math.log10(l / this.scaleX)), _ = Math.ceil(Math.log10(u / this.scaleY)), w = 10 ** (x - 2) * this.scaleX, f = 10 ** (_ - 2) * this.scaleY, b = w * this.gridsFactor, g = f * this.gridsFactor, $ = Math.ceil(u / g), C = Math.ceil(l / b), A = Math.ceil(u / f), E = Math.ceil(l / w), j = w * Math.ceil(r / w), O = f * Math.ceil(o / f), Q = b * Math.ceil(r / b), kt = g * Math.ceil(o / g), ht2 = [...this.numbers.children];
    for (const F of ht2)
      F.removeFromParent();
    this.numbers.children = [];
    const U = [], dt = 9 * v, H = 1e4, K = Q + this._offsetX, q = Math.round(Math.abs(K / this.scaleX) * H) / H, et = (C - 1) * b, Ei = Math.round(Math.abs((K + et) / this.scaleX) * H) / H, so = Math.max(q, Ei).toString().length * dt;
    let Ai2 = Math.ceil(so / b) * b;
    for (let F = 0; F < C; F++) {
      let L = Q + F * b;
      U.push(L, a, 0, L, o, 0), L = Math.round(L * H) / H, Ai2 = Math.round(Ai2 * H) / H;
      const de = L % Ai2;
      if (!(b < 1 || g < 1) && Math.abs(de) > 0.01)
        continue;
      const Oi = this.newNumber((L + this._offsetX) / this.scaleX), co = 12 * v;
      Oi.position.set(L, o + co, 0);
    }
    for (let F = 0; F < $; F++) {
      const L = kt + F * g;
      U.push(r, L, 0, n, L, 0);
      const de = this.newNumber(L / this.scaleY);
      let ki = 12;
      de.element.textContent && (ki += 4 * de.element.textContent.length);
      const Oi = ki * v;
      de.position.set(r + Oi, L, 0);
    }
    const Si = [];
    for (let F = 0; F < E; F++) {
      const L = j + F * w;
      Si.push(L, a, 0, L, o, 0);
    }
    for (let F = 0; F < A; F++) {
      const L = O + F * f;
      Si.push(r, L, 0, n, L, 0);
    }
    const ro = new BufferAttribute(new Float32Array(U), 3), oo = new BufferAttribute(new Float32Array(Si), 3), { main: ao, secondary: lo } = this.grids;
    ao.geometry.setAttribute("position", ro), lo.geometry.setAttribute("position", oo);
  }
  newNumber(t) {
    const e = document.createElement("bim-label");
    e.textContent = String(Math.round(t * 100) / 100);
    const s = new wu(e);
    return this.numbers.add(s), s;
  }
  newGrid(t) {
    const e = new BufferGeometry(), s = new LineSegments(e, this.material);
    return s.frustumCulled = false, s.renderOrder = t, s;
  }
  isGridReady() {
    const t = this._camera.projectionMatrix.elements;
    for (let e = 0; e < t.length; e++) {
      const s = t[e];
      if (Number.isNaN(s))
        return false;
    }
    return true;
  }
};
var Cu = Object.defineProperty;
var Eu = Object.getOwnPropertyDescriptor;
var Ge = (i, t, e, s) => {
  for (var n = Eu(t, e), r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Cu(t, e, n), n;
};
var xn = class xn2 extends Gt {
  constructor() {
    super(...arguments), this._grid = null, this._world = null, this.resize = () => {
      this._world && this._grid && this._grid.regenerate();
    };
  }
  set gridColor(t) {
    if (this._gridColor = t, !(t && this._grid))
      return;
    const e = Number(t.replace("#", "0x"));
    Number.isNaN(e) || this._grid.material.color.setHex(e);
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridScaleX(t) {
    this._gridScaleX = t, t && this._grid && (this._grid.scaleX = t);
  }
  get gridScaleX() {
    return this._gridScaleX;
  }
  set gridScaleY(t) {
    this._gridScaleY = t, t && this._grid && (this._grid.scaleY = t);
  }
  get gridScaleY() {
    return this._gridScaleY;
  }
  get gridOffsetX() {
    var t;
    return ((t = this._grid) == null ? void 0 : t.offsetX) || 0;
  }
  set gridOffsetX(t) {
    this._grid && (this._grid.offsetX = t);
  }
  get gridOffsetY() {
    var t;
    return ((t = this._grid) == null ? void 0 : t.offsetY) || 0;
  }
  set gridOffsetY(t) {
    this._grid && (this._grid.offsetY = t);
  }
  set components(t) {
    this.dispose();
    const s = t.get(Ci).create();
    this._world = s, s.scene = new ia(t), s.scene.setup(), s.renderer = new Bf(t, this);
    const n = new oa(t);
    s.camera = n;
    const r = new $u(n.threeOrtho, this);
    this._grid = r, s.scene.three.add(r.get()), n.controls.addEventListener(
      "update",
      () => r.regenerate()
    ), setTimeout(async () => {
      s.camera.updateAspect(), n.set("Plan"), await n.controls.setLookAt(0, 0, 100, 0, 0, 0), await n.projection.set("Orthographic"), n.controls.dollySpeed = 3, n.controls.draggingSmoothTime = 0.085, n.controls.maxZoom = 1e3, n.controls.zoom(4);
    });
  }
  get world() {
    return this._world;
  }
  dispose() {
    var t;
    (t = this.world) == null || t.dispose(), this._world = null, this._grid = null;
  }
  connectedCallback() {
    super.connectedCallback(), new ResizeObserver(this.resize).observe(this);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.dispose();
  }
  render() {
    return io`<slot></slot>`;
  }
};
xn.styles = Qr`
    :host {
      position: relative;
      display: flex;
      min-width: 0px;
      height: 100%;
      background-color: var(--bim-ui_bg-base);
    }
  `;
var xt = xn;
Ge([
  G({ type: String, attribute: "grid-color", reflect: true })
], xt.prototype, "gridColor");
Ge([
  G({ type: Number, attribute: "grid-scale-x", reflect: true })
], xt.prototype, "gridScaleX");
Ge([
  G({ type: Number, attribute: "grid-scale-y", reflect: true })
], xt.prototype, "gridScaleY");
Ge([
  G({ type: Number, attribute: "grid-offset-x", reflect: true })
], xt.prototype, "gridOffsetX");
Ge([
  G({ type: Number, attribute: "grid-offset-y", reflect: true })
], xt.prototype, "gridOffsetY");
var Au = Object.defineProperty;
var St = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Au(t, e, n), n;
};
var wn = class wn2 extends Gt {
  constructor() {
    super(...arguments), this._defaults = {
      size: 60
    }, this._cssMatrix3D = "", this._matrix = new Matrix4(), this._onRightClick = new Event("rightclick"), this._onLeftClick = new Event("leftclick"), this._onTopClick = new Event("topclick"), this._onBottomClick = new Event("bottomclick"), this._onFrontClick = new Event("frontclick"), this._onBackClick = new Event("backclick"), this._camera = null, this._epsilon = (t) => Math.abs(t) < 1e-10 ? 0 : t;
  }
  set camera(t) {
    this._camera = t, this.updateOrientation();
  }
  get camera() {
    return this._camera;
  }
  updateOrientation() {
    if (!this.camera)
      return;
    this._matrix.extractRotation(this.camera.matrixWorldInverse);
    const { elements: t } = this._matrix;
    this._cssMatrix3D = `matrix3d(
      ${this._epsilon(t[0])},
      ${this._epsilon(-t[1])},
      ${this._epsilon(t[2])},
      ${this._epsilon(t[3])},
      ${this._epsilon(t[4])},
      ${this._epsilon(-t[5])},
      ${this._epsilon(t[6])},
      ${this._epsilon(t[7])},
      ${this._epsilon(t[8])},
      ${this._epsilon(-t[9])},
      ${this._epsilon(t[10])},
      ${this._epsilon(t[11])},
      ${this._epsilon(t[12])},
      ${this._epsilon(-t[13])},
      ${this._epsilon(t[14])},
      ${this._epsilon(t[15])})
    `;
  }
  render() {
    const t = this.size ?? this._defaults.size;
    return io`
      <style>
        .face,
        .cube {
          width: ${t}px;
          height: ${t}px;
          transform: translateZ(-300px) ${this._cssMatrix3D};
        }

        .face-right {
          translate: ${t / 2}px 0 0;
        }

        .face-left {
          translate: ${-t / 2}px 0 0;
        }

        .face-top {
          translate: 0 ${t / 2}px 0;
        }

        .face-bottom {
          translate: 0 ${-t / 2}px 0;
        }

        .face-front {
          translate: 0 0 ${t / 2}px;
        }

        .face-back {
          translate: 0 0 ${-t / 2}px;
        }
      </style>
      <div class="parent">
        <div class="cube">
          <div
            class="face x-direction face-right"
            @click=${() => this.dispatchEvent(this._onRightClick)}
          >
            ${this.rightText}
          </div>
          <div
            class="face x-direction face-left"
            @click=${() => this.dispatchEvent(this._onLeftClick)}
          >
            ${this.leftText}
          </div>
          <div
            class="face y-direction face-top"
            @click=${() => this.dispatchEvent(this._onTopClick)}
          >
            ${this.topText}
          </div>
          <div
            class="face y-direction face-bottom"
            @click=${() => this.dispatchEvent(this._onBottomClick)}
          >
            ${this.bottomText}
          </div>
          <div
            class="face z-direction face-front"
            @click=${() => this.dispatchEvent(this._onFrontClick)}
          >
            ${this.frontText}
          </div>
          <div
            class="face z-direction face-back"
            @click=${() => this.dispatchEvent(this._onBackClick)}
          >
            ${this.backText}
          </div>
        </div>
      </div>
    `;
  }
};
wn.styles = Qr`
    :host {
      position: absolute;
      z-index: 999;
      bottom: 1rem;
      right: 1rem;
    }

    .parent {
      perspective: 400px;
    }

    .cube {
      position: relative;
      transform-style: preserve-3d;
    }

    .face {
      position: absolute;
      display: flex;
      justify-content: center;
      user-select: none;
      align-items: center;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s;
      color: var(--bim-view-cube--c, white);
      font-size: var(--bim-view-cube--fz, --bim-ui_size-2xl);
    }

    .x-direction {
      // background-color: var(--bim-view-cube_x--bgc, #c93830DD);
      background-color: var(--bim-view-cube_x--bgc, #01a6bcde);
    }

    .x-direction:hover {
      background-color: var(--bim-ui_accent-base, white);
    }

    .y-direction {
      // background-color: var(--bim-view-cube_y--bgc, #54ff19DD);
      background-color: var(--bim-view-cube_y--bgc, #8d0ec8de);
    }

    .y-direction:hover {
      background-color: var(--bim-ui_accent-base, white);
    }

    .z-direction {
      // background-color: var(--bim-view-cube_z--bgc, #3041c9DD);
      background-color: var(--bim-view-cube_z--bgc, #2718afde);
    }

    .z-direction:hover {
      background-color: var(--bim-ui_accent-base, white);
    }

    .face-front {
      transform: rotateX(180deg);
    }

    .face-back {
      transform: rotateZ(180deg);
    }

    .face-top {
      transform: rotateX(90deg);
    }

    .face-bottom {
      transform: rotateX(270deg);
    }

    .face-right {
      transform: rotateY(-270deg) rotateX(180deg);
    }

    .face-left {
      transform: rotateY(-90deg) rotateX(180deg);
    }
  `;
var Z = wn;
St([
  G({ type: Number, reflect: true })
], Z.prototype, "size");
St([
  G({ type: String, attribute: "right-text", reflect: true })
], Z.prototype, "rightText");
St([
  G({ type: String, attribute: "left-text", reflect: true })
], Z.prototype, "leftText");
St([
  G({ type: String, attribute: "top-text", reflect: true })
], Z.prototype, "topText");
St([
  G({ type: String, attribute: "bottom-text", reflect: true })
], Z.prototype, "bottomText");
St([
  G({ type: String, attribute: "front-text", reflect: true })
], Z.prototype, "frontText");
St([
  G({ type: String, attribute: "back-text", reflect: true })
], Z.prototype, "backText");
St([
  xu()
], Z.prototype, "_cssMatrix3D");
var oh = class {
  /**
   * Initializes the custom elements for the BIM application.
   *
   * @remarks
   * This method should be called once during the application's initialization.
   *
   */
  static init() {
    tn.defineCustomElement("bim-view-cube", Z), tn.defineCustomElement("bim-world-2d", xt);
  }
};
export {
  oh as Manager,
  Z as ViewCube,
  xt as World2D,
  nh as buttons,
  sh as tables
};
/*! Bundled license information:

@thatopen/ui-obc/dist/index.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
  * (c) Iconify
  *
  * For the full copyright and license information, please view the license.txt
  * files at https://github.com/iconify/iconify
  *
  * Licensed under MIT.
  *
  * @license MIT
  * @version 2.0.0
  *)
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@thatopen_ui-obc.js.map
